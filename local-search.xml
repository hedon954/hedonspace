<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 常用库丨clap</title>
    <link href="/2024/02/26/rust-crate-clap/"/>
    <url>/2024/02/26/rust-crate-clap/</url>
    
    <content type="html"><![CDATA[<h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li><a href="https://docs.rs/clap/4.5.1/clap/index.html">clap:4.5.1</a></li><li><ahref="https://docs.rs/rpassword/7.3.1/rpassword/index.html">rpassword:7.3.1</a></li></ul><h1 id="结论先行">结论先行</h1><h1 id="cli-概述">CLI 概述</h1><h1 id="clap">clap</h1><h1 id="httpie">Httpie</h1><h1 id="与-go-语言-cobra-比较">与 Go 语言 cobra 比较</h1>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>clap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言类型推断与类型转换</title>
    <link href="/2024/02/25/go-type-infer-trans/"/>
    <url>/2024/02/25/go-type-infer-trans/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出 Go 语言的 GPM 模型（Go1.21）</title>
    <link href="/2024/01/20/go-gpm/"/>
    <url>/2024/01/20/go-gpm/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>在现代软件开发中，有效地利用并发是提高应用性能和响应速度的关键。随着多核处理器的普及，编程语言和框架如何高效、简便地支持并发编程，成为了软件工程师们评估和选择工具时的一个重要考量。在这方面，Go语言凭借其创新的并发模型—GPM（Goroutine, P,M）—在众多编程语言中脱颖而出，为开发者提供了强大的工具，以简单、高效的方式实现并发。</p><p>自从 2009 年首次发布以来，Go语言就以其出色的性能、简洁的语法和对并发的原生支持赢得了广泛的关注。尤其是其并发模型，被设计为能够充分利用现代多核处理器的能力，同时隐藏底层的线程管理和同步复杂性，让开发者能够以更直观、更高级的抽象来构建并发程序。GPM模型，作为 Go 语言并发编程的核心，通过Goroutine、P（processor）、M（machine）三者的协同工作，实现了一种高效且易于管理的并发机制。</p><p>本文将基于 <strong>Go1.21</strong> 深入浅出地探讨 Go 语言的 GPM模型，主要分为几个部分：</p><ul><li>首先从其设计理念出发，详细解析 Goroutine、P 和 M三者的角色、工作原理及其相互之间的交互方式。</li><li>然后引入几个关键问题，我们会从结论上先总结 GPM的核心要点，内容包括协程调度循环、调度策略和调度时机。</li><li>接着我们会深入源码，去一步步洞察 Go 语言设计者是如何实现 GPM模型中的各个要点的，这个过程会比较繁琐，但其实也比较有趣，感兴趣的读者可以阅读这一块，若只是想对GPM 模型有个大概了解，那么停留在上一步也足矣了。</li><li>最后我们基于前面的分析，总结 G、P、M 三大组件在 Go程序运行过程中的状态流转图。</li></ul><p>通过对 GPM 模型的探讨，我们不仅能够理解 Go语言如何在众多现代编程语言中以其并发编程能力脱颖而出，还能够洞察其设计背后的智慧，以及这一模型如何随着Go 语言版本的迭代而不断进化和优化。无论你是对 Go语言充满好奇的新手，还是希望深化理解其并发模型的经验开发者，本文都将为你提供宝贵的视角和深刻的洞见。</p><h1 id="结论先行">结论先行</h1><h2 id="gpm-调度原理图">GPM 调度原理图</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><h2 id="goroutine-底层结构">Goroutine 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><h2 id="调度器-p-底层结构">调度器 P 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="gpm-调度循环">GPM 调度循环</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><h2 id="gpm-协程调度优先级与顺序">GPM 协程调度优先级与顺序</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h2 id="寻找可执行-g-过程">寻找可执行 G 过程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h2 id="协程切换时机">协程切换时机</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240129000028727.png"alt="Go 协程切换时机" /><figcaption aria-hidden="true">Go 协程切换时机</figcaption></figure><h1 id="gpm-模型">GPM 模型</h1><h2 id="概览">1. 概览</h2><p>这里有一张很流行的 Goroutine 调度原理图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>定义位置</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>Sched</td><td>调度器</td><td>proc.c</td><td>维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</td></tr><tr class="even"><td>M</td><td>Machine 系统线程</td><td>runtime.h</td><td>它由操作系统管理的，Goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的Goroutine、随机数发生器等等非常多的信息。</td></tr><tr class="odd"><td>P</td><td>Processor 处理器</td><td>runtime.h</td><td>它的主要用途就是用来执行 Goroutine 的，它维护了一个 Goroutine队列，即 runqueue。Processor 是让我们从 N:1 调度到 M:N调度的重要部分。所有的 P 都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS（可配置）个。</td></tr><tr class="even"><td>G</td><td>Goroutine 实现的核心结构</td><td>runtime.h</td><td>它包含了栈，指令指针，以及其他对调度 Goroutine很重要的信息，例如其阻塞的 channel。</td></tr><tr class="odd"><td>Global Queue</td><td>全局队列</td><td>proc.h</td><td>存放等待运行的 G。全局队列可能被任意的 P 加锁去获取里面的 G。</td></tr><tr class="even"><td>P Local Queue</td><td>P 的本地队列</td><td>proc.h</td><td>同全局队列类似，存放的也是等待运行的 G，但存放的数据有限，不会超过256 个。新建 G 时，G会优先加入本地队列。如果队列满了，则会把本地队列中一半的 G 以及新 G一起移动到全局队列。</td></tr></tbody></table><p>通过这个原理图我们知道 Go 语言的 GPM模型的作用非常简单，它就是一个“精打细算”的工具。以前单进程无法充分利用CPU资源，所以引入了多进程。又因为进程拥有的资源太多，其创建、切换和销毁都会占用很长时间，所以引入了更小粒度的线程。随着计算机科学的进步，现在看来，线程拥有的资源也是“比较多”的，所以线程的创建、切换和销毁代价也是“相对大”的。所以很多编程语言就引入了协程这个概念，其核心目的就是应用层自己抽象一个比线程更小粒度的调度单元，应用层结合操作系统的多线程能力，自己来管理“调度单元”的创建、切换和销毁，从而尽可能减少由线程切换带来的开销，以做到更轻量级的并发。</p><p>不同的编程语言可能有不同的实现，而关键就在于如何让调度更快、开销更小。这便是我们本文要探讨的主要内容。</p><div class="note note-info">            <p><strong>Go 语言的实现：</strong></p><p>线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P的本地队列为空时，M 会尝试从全局队列获得一批 G 放到 P的本地队列，或者从其他 P 的本地队列中“偷”一半 G 放到自己的本地队列。然后M 运行 G，G 执行之后，再从 P 获取下一个 G，如此不断重复下去。</p>          </div><p>在进入更加具体深入的讨论之前，我们需要重点思考以下几个问题：</p><ol type="1"><li>G 我们可以随便创建，可能有成千上万个，那 P 和 M 有多少个呢？</li><li>P 和 M 什么时候被创建呢？</li><li>操作系统只知道线程，所以实际上还是线程在执行任务，那么 G是如何调度到线程上并执行的呢？</li><li>如何防止协程饥饿？</li><li>如何减少频繁地创建和销毁线程？</li><li>多个线程从全局队列拿 G如何解决并发问题？又如何减少这种数据竞争呢？</li><li>在整个 Go 调度协程的过程中，G、P、M有哪些状态？它们又是如何轮转的呢？</li></ol><p>如果你对这几个问题有兴趣，请继续阅读下文。</p><h2 id="p-和-m-的个数问题">2. P 和 M 的个数问题</h2><ol type="1"><li>P 的数量由启动时环境变量 <code>$GOMAXPROCS</code> 或者程序中<code>runtime.GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有 <code>GOMAXPROCS</code> 个Goroutine 在同时运行。</li><li>M 的数量由 Go 语言本身的限制决定，Go 程序启动时会设置 M 的最大数量为<strong>10000</strong>个，但是内核很难支持这么多的线程数，所以这个限制可以忽略。可以使用<code>runtime.SetMaxThreads()</code> 设置 M 的最大数量。</li></ol><h2 id="p-和-m-何时被创建">3. P 和 M 何时被创建</h2><ol type="1"><li>P 的创建时机在确定了 P 的最大数量 n 后，runtime 会根据这个数量创建 n个 P。</li><li>M 创建的时机是在当没有足够的 M 来关联 P 并运行其中可运行的 G的时候，如所有的 M 此时都阻塞住了，而 P中还有很多就绪任务，就会去寻找空闲的 M，如果没有空闲的 M，就会去创建新的M。</li></ol><h2 id="调度循环">4. 调度循环</h2><p>在讨论 G 是如何被调度到 M 去执行的时候，我们需要先介绍 GPM模型中两个比较特殊的角色：<code>m0</code> 和 <code>g0</code>。</p><h3 id="m0">4.1 m0</h3><ul><li><strong>定义</strong>：m0 是 Go 程序启动时创建的第一个 M。它是由 Go运行时系统直接从操作系统线程创建的，不是从线程池中获取的。</li><li><strong>作用</strong>：m0 负责初始化和启动 Go运行时环境，包括创建调度器、分配第一个P（p0），并创建其他系统级别的资源。在程序的整个生命周期中，m0会继续存在，即使它可能不执行任何 Go 代码。</li><li><strong>特点</strong>：m0 不同于其他M，因为它不是从线程池中获取的。它可能没有绑定任何 P，除非程序中只有一个P（即 GOMAXPROCS 设置为 1）。</li></ul><h3 id="g0">4.2 g0</h3><ul><li><strong>定义</strong>：g0 是每个 M 的特殊Goroutine，它不执行任何实际的 Go 代码。每个 M 在创建时都会分配一个g0。</li><li><strong>作用</strong>：g0 主要用于执行调度器代码和进行系统调用。当 M需要执行这些非用户代码时，会切换到 g0 的栈上运行。</li><li><strong>特点</strong>：g0拥有自己的栈，这个栈用于存放调度器函数和系统调用的数据。这意味着当执行这些操作时，不会影响当前运行的用户Goroutine 的栈。</li></ul><h3 id="协程栈切换">4.3 协程栈切换</h3><p>g0 是 M 中负责调度其他 g 的协程，所以一个 M 中的协程调度其实就是在 g和 g0 之间不断切换：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127155030695.png"alt="协程 g 与 协程 g0 的对应关系" /><figcaption aria-hidden="true">协程 g 与 协程 g0 的对应关系</figcaption></figure><p>大致过程如下：</p><ol type="1"><li>当 M 执行一个 G（用户 Goroutine）时，它使用 G的栈来运行用户代码。</li><li>当需要执行系统调用或调度器相关的代码时，M 会切换到 g0。g0拥有自己的栈，专门用于执行系统调用和调度器代码，这样可以避免污染用户Goroutine 的栈空间。在 g0 上，M 可以执行如内存分配、调度决策、处理Goroutine 的创建和销毁等操作。</li><li>完成系统调用或调度器任务后，M 会切换回之前的G，继续执行用户代码。这个过程会从 g0 的栈切换回 G 的栈。</li></ol><p>详细细节我们留到后面的源码分析揭晓。</p><h2 id="调度策略">5. 调度策略</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h3 id="获取本地运行队列">5.1 获取本地运行队列</h3><p>P 会优先尝试从自己的本地队列中寻找就绪的G，它<strong>一般</strong>会优先调度最近加入的。</p><p>因为这个时候可能由其他 P 来窃取 G，所以这里是需要同步机制的，Go采用原子操作来降低同步开销。</p><p>本地队列 G 的个数不超过 <strong>256</strong> 个，<strong>如果在创建 G的时候本地队列满了，会将本地队列中 1/2 的 G 连同新创建的 G一起放入全局队列中。</strong></p><h3 id="获取全局运行队列">5.2 获取全局运行队列</h3><p>P 会优先本地队列，然后才全局队列，这有个好处：</p><ul><li>如果只有全局队列，那么所有的 P 都需要去竞争全局队列中的G，这个时候需要上锁，且数据竞争会比较激烈，性能较差。</li><li>通过每个 P维护一个自己的本地队列可以减少并发冲突，如果实在需要去全局队列拿G，也可以一次性拿多个，大大减少了并发冲突的情况发生。</li></ul><p>但这又带来了一个问题，全局队列中协程的饥饿问题，因为 P会优先调度最近加入到自己本地队列中的 G，那可能会一直有新的 G被创建，导致全局队列中的 G 没有机会被调度到。Go 的解决思路是：</p><ul><li>P 每调度 <strong>61</strong> 次后，就会从全局队列中获取一个 G来运行。</li></ul><h3 id="获取准备就绪的网络协程">5.3 获取准备就绪的网络协程</h3><p>如果本地队列和全局队列都找不到就绪的 G 可以执行的话。调度会通过<code>runtime.netpoll</code> 获取可以运行的网络协程。</p><p>Go 语言的网络模型是对不同操作系统平台上 I/O 多路复用技术的封装。</p><p>当 Goroutine 在进行网络 I/O 时，它会被挂起，线程会去执行其他Goroutine。一旦 I/O 操作完成，该 Goroutine会被唤醒并重新排队等待执行。</p><h3 id="系统调用">5.4 系统调用</h3><p>当一个 Goroutine执行系统调用时，它可能会被阻塞，这时它的执行线程（M）可能会释放当前绑定的处理器（P），以便其他Goroutine 可以在该 P 上运行。</p><h3 id="协程窃取">5.5 协程窃取</h3><p>空闲的 M 如果绑定了 P，那么它的 P 会一直尝试从其他 P 的队列中窃取Goroutine，以平衡负载和避免空闲。这个时候为了让每个 P 都有可能被窃取，Go没有直接顺序遍历 P 列表，而是采用了一种相对随机的方式去遍历 P列表，直到找到可以运行的协程就返回。M 不断寻找可执行 G的这段期间，它被称为<strong>自旋线程</strong>。</p><p>所以为减少创建、切换和销毁线程的开销，Go 做了至少两点努力：</p><ol type="1"><li><p>偷取（Work Stealing）机制</p><p>当本线程无可运行的 G 时，它所绑定的 P 会尝试从其他线程绑定的 P 窃取G，而不是销毁线程。</p></li><li><p>移交（Hand Off）机制</p><p>当本线程因为 G 进行系统调用而阻塞时，线程会释放绑定的 P，把 P移交给其他空闲的线程执行。</p></li></ol><h2 id="调度时机">6. 调度时机</h2><p>Go 语言的调度器结合了抢占式调度和协作式调度，以下是 Go中这两种调度方式的具体实现和特性：</p><h3 id="协作式调度cooperative-scheduling">6.1 协作式调度（CooperativeScheduling）</h3><p><strong>阻塞操作</strong>：</p><ul><li>当 Goroutine执行阻塞操作（如通道操作、等待锁、系统调用等）时，它会主动放弃 CPU控制权，允许调度器切换到其他 Goroutine。</li></ul><p><strong>显式调度</strong>：</p><ul><li>Goroutine 显式请求 <code>runtime.Gosched()</code>调用，调度器进行调度。</li><li>这个时候回从当前协程切换到 g0 协程，取消 G 与 M 之间的绑定关系，把 G放入全局队列中。</li></ul><h3 id="抢占式调度preemptive-scheduling">6.2 抢占式调度（PreemptiveScheduling）</h3><p><strong>基于时间的抢占</strong>：</p><ul><li>从 Go 1.14 开始，调度器引入了基于时间的抢占机制。如果一个 Goroutine运行时间超过 10 毫秒，或者在系统调用中超过了 20微妙，调度器会在安全点（如函数调用、循环迭代、阻塞操作等）尝试暂停该Goroutine。</li><li>这种抢占不依赖于 Goroutine的显式放弃控制，而是由调度器主动触发。</li><li>安全点的选择旨在减少对 Goroutine执行的干扰，同时确保调度的公平性和响应性。</li></ul><p><strong>基于信号的抢占：</strong></p><ul><li>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</li><li>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</li><li>当线程接收到抢占信号时，会进入一个专门的信号处理器。这个处理器会检查是否处于安全点，如果是，则暂停当前Goroutine 并进行上下文切换。</li></ul><h1 id="源码分析">源码分析</h1><p>前面我们对 Go 语言的 GPM模型在基本概念、调度循环、调度策略和调度时机各个方面都进行了详细的阐述。如果读者只是想简单了解一下GPM模型的一些概念和设计思想，那么阅读到这里就基本足够了。如果对其源码实现有兴趣的话，那么请继续往下阅读~</p><p>接下来我们会从以下几个方面来对 Go 语言的 GPM 模型进行源码分析：</p><ol type="1"><li>G、P、M 在 Go 语言中的表示。</li><li>G 的创建过程。</li><li>g 和 g0 的切换过程。</li><li>GPM 的调度机制。</li></ol><h2 id="g-的底层结构">1. G 的底层结构</h2><p>G 在 Go 里面就是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>g</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 栈参数。</span><br><span class="hljs-comment">// stack 描述实际的栈内存：[stack.lo, stack.hi)。</span><br><span class="hljs-comment">// stackguard0 是在 Go 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 通常是 stack.lo+StackGuard，但可以是 StackPreempt 来触发抢占。</span><br><span class="hljs-comment">// stackguard1 是在 C 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 在 g0 和 gsignal 栈上是 stack.lo+StackGuard。</span><br><span class="hljs-comment">// 在其他 goroutine 栈上是 ~0，以触发对 morestackc 的调用（并崩溃）。</span><br>stack       stack   <span class="hljs-comment">// 运行时/CGO 已知的偏移</span><br>stackguard0 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br>stackguard1 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br><br>_panic    *_panic <span class="hljs-comment">// 最内层的 panic - liblink 已知的偏移</span><br>_defer    *_defer <span class="hljs-comment">// 最内层的 defer</span><br>m         *m      <span class="hljs-comment">// 当前 m；arm liblink 已知的偏移</span><br>sched     gobuf   <span class="hljs-comment">// 当前协程的运行现场</span><br>syscallsp <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallsp = sched.sp 在 gc 期间使用</span><br>syscallpc <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallpc = sched.pc 在 gc 期间使用</span><br>stktopsp  <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈顶的预期 sp，用于回溯检查</span><br><span class="hljs-comment">// param 是一个通用的指针参数字段，用于在特定上下文中传递值，</span><br><span class="hljs-comment">// 其他存储参数的方式难以找到。目前有三种用途：</span><br><span class="hljs-comment">// 1. 当通道操作唤醒一个阻塞的 goroutine 时，它将 param 设置为</span><br><span class="hljs-comment">//    指向已完成阻塞操作的 sudog。</span><br><span class="hljs-comment">// 2. 由 gcAssistAlloc1 使用，以向其调用者信号，表明 goroutine 完成了 GC 周期。</span><br><span class="hljs-comment">//    以任何其他方式这样做是不安全的，因为此时 goroutine 的栈可能已经移动。</span><br><span class="hljs-comment">// 3. 由 debugCallWrap 使用，以将参数传递给新的 goroutine，因为在运行时分配闭包是被禁止的。</span><br>param        unsafe.Pointer<br>atomicstatus atomic.Uint32<br>stackLock    <span class="hljs-type">uint32</span> <span class="hljs-comment">// sigprof/scang 锁；<span class="hljs-doctag">TODO:</span> 合并到 atomicstatus</span><br>goid         <span class="hljs-type">uint64</span><br>schedlink    guintptr<br>waitsince    <span class="hljs-type">int64</span>      <span class="hljs-comment">// g 变为阻塞的大致时间</span><br>waitreason   waitReason <span class="hljs-comment">// 如果 status==Gwaiting</span><br><br>preempt       <span class="hljs-type">bool</span> <span class="hljs-comment">// 抢占信号，复制 stackguard0 = stackpreempt</span><br>preemptStop   <span class="hljs-type">bool</span> <span class="hljs-comment">// 在抢占时转换为 _Gpreempted；否则，只是取消调度</span><br>preemptShrink <span class="hljs-type">bool</span> <span class="hljs-comment">// 在同步安全点缩小栈</span><br><br><span class="hljs-comment">// asyncSafePoint 设置为 true 表示 g 在异步安全点停止。</span><br><span class="hljs-comment">// 这意味着栈上有没有精确指针信息的帧。</span><br>asyncSafePoint <span class="hljs-type">bool</span><br><br>paniconfault <span class="hljs-type">bool</span> <span class="hljs-comment">// 在意外的故障地址上触发 panic（而不是崩溃）</span><br>gcscandone   <span class="hljs-type">bool</span> <span class="hljs-comment">// g 已扫描栈；由 _Gscan 位在状态中保护</span><br>throwsplit   <span class="hljs-type">bool</span> <span class="hljs-comment">// 必须不分割栈</span><br><span class="hljs-comment">// activeStackChans 表示有未锁定的通道指向这个 goroutine 的栈。</span><br><span class="hljs-comment">// 如果为 true，栈复制需要获取通道锁来保护这些栈区域。</span><br>activeStackChans <span class="hljs-type">bool</span><br><span class="hljs-comment">// parkingOnChan 表示 goroutine 即将在 chansend 或 chanrecv 上停车。</span><br><span class="hljs-comment">// 用于标记栈缩小的不安全点。</span><br>parkingOnChan atomic.Bool<br><br>raceignore    <span class="hljs-type">int8</span>  <span class="hljs-comment">// 忽略竞态检测事件</span><br>tracking      <span class="hljs-type">bool</span>  <span class="hljs-comment">// 是否跟踪此 G 以获取调度延迟统计</span><br>trackingSeq   <span class="hljs-type">uint8</span> <span class="hljs-comment">// 用于决定是否跟踪此 G</span><br>trackingStamp <span class="hljs-type">int64</span> <span class="hljs-comment">// G 最后开始被跟踪的时间戳</span><br>runnableTime  <span class="hljs-type">int64</span> <span class="hljs-comment">// 可运行时间，运行时清除，仅在跟踪时使用</span><br>lockedm       muintptr<br>sig           <span class="hljs-type">uint32</span><br>writebuf      []<span class="hljs-type">byte</span><br>sigcode0      <span class="hljs-type">uintptr</span><br>sigcode1      <span class="hljs-type">uintptr</span><br>sigpc         <span class="hljs-type">uintptr</span><br>parentGoid    <span class="hljs-type">uint64</span>          <span class="hljs-comment">// 创建此 goroutine 的 goroutine 的 goid</span><br>gopc          <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// 创建此 goroutine 的 go 语句的 pc</span><br>ancestors     *[]ancestorInfo <span class="hljs-comment">// 创建此 goroutine 的祖先 goroutine 的信息（仅在 debug.tracebackancestors 使用）</span><br>startpc       <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// goroutine 函数的 pc</span><br>racectx       <span class="hljs-type">uintptr</span><br>waiting       *sudog         <span class="hljs-comment">// 此 g 正在等待的 sudog 结构（具有有效的 elem 指针）；按锁顺序</span><br>cgoCtxt       []<span class="hljs-type">uintptr</span>      <span class="hljs-comment">// cgo 回溯上下文</span><br>labels        unsafe.Pointer <span class="hljs-comment">// 分析器标签</span><br>timer         *timer         <span class="hljs-comment">// 缓存的计时器，用于 time.Sleep</span><br>selectDone    atomic.Uint32  <span class="hljs-comment">// 我们是否参与 select 并且有人赢得了竞赛？</span><br><br><span class="hljs-comment">// goroutineProfiled 指示当前 goroutine 的栈状态</span><br>  <span class="hljs-comment">// 是否已经被记录在进行中的 goroutine 性能分析中。</span><br>goroutineProfiled goroutineProfileStateHolder<br><br><span class="hljs-comment">// 每个 G 的追踪状态。</span><br>trace gTraceState<br><br><span class="hljs-comment">// 每个 G 的 GC 状态</span><br><br><span class="hljs-comment">// gcAssistBytes 是此 G 的 GC 协助信用，以分配的字节为单位。</span><br><span class="hljs-comment">// 如果为正，则 G 有信用分配 gcAssistBytes 字节而不协助。</span><br><span class="hljs-comment">// 如果为负，则 G 必须通过执行扫描工作来纠正这一点。</span><br><span class="hljs-comment">// 我们以字节为单位跟踪这一点，以便在 malloc 热路径中快速更新和检查债务。</span><br><span class="hljs-comment">// 协助比率决定了这如何对应于扫描工作债务。</span><br>gcAssistBytes <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>g</code> 结构字段非常多，这个结构体的设计反映了 Go语言对并发和协程管理的底层机制，包括栈管理、调度、垃圾回收、异常处理等多个方面。通过这种抽象，Go语言能够有效地管理成千上万的<code>goroutine</code>，使得并发编程变得更加简单和高效。</p><p>这里我们只关注 GPM 模型相关的内容，需要重点关心以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack     stack   <span class="hljs-comment">// 当前协程的协程栈</span><br>m         *m      <span class="hljs-comment">// 当前线程</span><br>sched     gobuf  <span class="hljs-comment">// 保存协程的运行现场</span><br>atomicstatus atomic.Uint32<span class="hljs-comment">// 协程状态</span><br>goid         <span class="hljs-type">uint64</span><span class="hljs-comment">// 协程ID</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程栈-stack">1.1 协程栈 stack</h3><p>其中 <code>stack</code>结构如下，它存储了协程栈的低地址和高地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的低地址</span><br>hi <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的高地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程抽象-m">1.2 线程抽象 m</h3><p>而 <code>m</code> 就是 Go语言对操作系统线程的抽象，这不是实际的线程，这只是 Go语言对线程相关信息的抽象，以方便更好地调度协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>g0      *g     <span class="hljs-comment">// g0 协程，Go 中的主协程</span><br>curg    *g       <span class="hljs-comment">// 现在正在运行的协程</span><br>id      <span class="hljs-type">int64</span> <span class="hljs-comment">// 线程ID</span><br>mOS<span class="hljs-comment">// 当前操作系统对线程的额外描述信息</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>m</code>结构体包含了许多字段，这些字段涉及到线程管理、调度、信号处理、系统调用、锁管理等多个方面。这个结构体是Go 并发模型的核心部分之一，它与 <code>g</code>（goroutine）和<code>p</code>（processor）结构体一起，构成了 Go的调度系统的基础。通过这种设计，Go能够有效地在多个操作系统线程之间调度成千上万的goroutine，实现高效的并发执行。</p><h3 id="协程上下文-gobuf">1.3 协程上下文 gobuf</h3><p><code>gobuf</code> 结构体在 Go 语言的运行时系统中用于保存<code>Goroutine</code>的执行上下文，特别是在调度和系统调用中。这个结构体保存了足够的信息以便在<code>Goroutine</code> 被暂停后能够恢复执行。</p><p>下面是对 <code>gobuf</code> 结构体中各个字段的解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// sp, pc 和 g 的偏移量是已知的（在 libmach 中硬编码）。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ctxt 在 GC 方面比较特殊：它可能是一个堆分配的 funcval，</span><br><span class="hljs-comment">// 因此 GC 需要跟踪它，但它需要在汇编中设置和清除，</span><br><span class="hljs-comment">// 在那里实现写屏障比较困难。然而，ctxt 实际上是一个保存的、活跃的寄存器，</span><br><span class="hljs-comment">// 我们只在真实寄存器和 gobuf 之间交换它。因此，我们在栈扫描期间将其视为根，</span><br><span class="hljs-comment">// 这意味着保存和恢复它的汇编不需要写屏障。它仍然被类型化为指针，</span><br><span class="hljs-comment">// 以便任何其他从 Go 进行的写操作都会获得写屏障。</span><br>sp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 栈指针</span><br>pc   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 程序计数器</span><br>g    guintptr       <span class="hljs-comment">// 指向当前 goroutine 的指针</span><br>ctxt unsafe.Pointer <span class="hljs-comment">// 上下文，用于保存额外的状态或信息</span><br>ret  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于保存函数返回值</span><br>lr   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 链接寄存器（在某些架构中用于函数调用）</span><br>bp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 基指针（在启用帧指针的架构中使用）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点需要关注 2 个字段：</p><ul><li><code>sp</code>：栈指针，表示当前协程运行到栈中的哪个位置了。</li><li><code>pc</code>：程序计数器，表示当前协程运行到哪一行代码了。</li></ul><h3 id="协程状态-atomicstatus">1.4 协程状态 atomicstatus</h3><p>我记得在 Go1.16 版本中，这个字段的类型还是 <code>uint32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p>现在 Go1.21 版本中，已经用了原子操作来减少并发冲突了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus atomic.Uint32<br></code></pre></td></tr></table></figure><p>可以看到 Go 的底层也是随着版本更新不断优化中的。</p><p><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>定义了 G 的各种状态，如：</p><ul><li><code>_Gidle (0)</code>: 表示 G 刚刚被分配，尚未初始化。</li><li><code>_Grunnable (1)</code>: 表示 G在运行队列上。它当前没有执行用户代码。栈不被该 <code>goroutine</code>拥有。</li><li>...</li></ul><p>后面我们会给出 G 状态的流转图。</p><h3 id="举个例子">1.5 举个例子</h3><p>假设我们现在有以下 Go 代码：main() 调用 do1()，do1() 调用do2()，do2() 调用 do3()。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;here is do3&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do2</span><span class="hljs-params">()</span></span> &#123;<br>do3()<span class="hljs-comment">//&lt;---------------</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do1</span><span class="hljs-params">()</span></span> &#123;<br>do2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>do1()<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当这段程序运行到第 6 行的时候，它的底层结构大概如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><p>至于为什么这里有个 <code>goexit()</code>，其实就是为了可以跳回到<code>g0</code> 协程，后面我们会具体分析到。</p><h2 id="p-的底层结构">2. P 的底层结构</h2><p>P 的本质是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>p</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>    id          <span class="hljs-type">int32</span>          <span class="hljs-comment">// P 的唯一标识符</span><br>    status      <span class="hljs-type">uint32</span>         <span class="hljs-comment">// P 的状态，如 pidle/prunning/...</span><br>    link        puintptr       <span class="hljs-comment">// P 链接</span><br>    schedtick   <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次调度器调用时递增</span><br>    syscalltick <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次系统调用时递增</span><br>    sysmontick  sysmontick     <span class="hljs-comment">// sysmon 观察到的最后一个 tick</span><br>    m           muintptr       <span class="hljs-comment">// 关联的 M 的反向链接（如果空闲则为 nil）</span><br>    mcache      *mcache        <span class="hljs-comment">// M 缓存</span><br>    pcache      pageCache      <span class="hljs-comment">// 页面缓存</span><br>    raceprocctx <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于竞态检测的上下文</span><br><br>    <span class="hljs-comment">// 延迟结构体池</span><br>    deferpool    []*_defer<br>    deferpoolbuf [<span class="hljs-number">32</span>]*_defer<br><br>    <span class="hljs-comment">// Goroutine ID 缓存，减少对 runtime·sched.goidgen 的访问</span><br>    goidcache    <span class="hljs-type">uint64</span><br>    goidcacheend <span class="hljs-type">uint64</span><br><br>    <span class="hljs-comment">// 可运行 goroutine 队列，无锁访问</span><br>    runqhead <span class="hljs-type">uint32</span><br>    runqtail <span class="hljs-type">uint32</span><br>    runq     [<span class="hljs-number">256</span>]guintptr<br>    runnext  guintptr <span class="hljs-comment">// 下一个要运行的 G</span><br><br>    <span class="hljs-comment">// 空闲 G 的列表（状态 == Gdead）</span><br>    gFree <span class="hljs-keyword">struct</span> &#123;<br>        gList<br>        n <span class="hljs-type">int32</span><br>    &#125;<br><br>    <span class="hljs-comment">// sudog 缓存</span><br>    sudogcache []*sudog<br>    sudogbuf   [<span class="hljs-number">128</span>]*sudog<br><br>    <span class="hljs-comment">// 堆上 mspan 对象的缓存</span><br>    mspancache <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>        buf [<span class="hljs-number">128</span>]*mspan<br>    &#125;<br><br>    <span class="hljs-comment">// pinner 对象的缓存</span><br>    pinnerCache *pinner<br><br>  <span class="hljs-comment">// P 状态跟踪</span><br>    trace pTraceState<br><br>    <span class="hljs-comment">// 每个 P 的持久分配，避免互斥</span><br>    palloc persistentAlloc <br><br>    <span class="hljs-comment">// 定时器相关字段</span><br>    timer0When             atomic.Int64<br>    timerModifiedEarliest  atomic.Int64<br>    timersLock             mutex<br>    timers                 []*timer<br>    numTimers              atomic.Uint32<br>    deletedTimers          atomic.Uint32<br>    timerRaceCtx           <span class="hljs-type">uintptr</span><br><br>    <span class="hljs-comment">// GC 相关字段</span><br>    gcAssistTime         <span class="hljs-type">int64</span><br>    gcFractionalMarkTime <span class="hljs-type">int64</span><br>    gcw                  gcWork<br>    wbBuf                wbBuf<br><br>    <span class="hljs-comment">// 指示是否在下一个安全点运行特定的函数</span><br>    runSafePointFn <span class="hljs-type">uint32</span><br>  <br>    <span class="hljs-comment">// 指示当前 P 是否正在写入任何统计数据。</span><br>  <span class="hljs-comment">// 偶数时表示没有写入，奇数时表示正在写入。</span><br>    statsSeq       atomic.Uint32<br>  <br>    <span class="hljs-comment">// 指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br><span class="hljs-comment">// 这是实现抢占式调度的一部分，允许调度器在必要时中断长时间运行的 goroutine，</span><br>    <span class="hljs-comment">// 以便其他 goroutine 有机会运行。</span><br>    preempt        <span class="hljs-type">bool</span><br>  <br>    <span class="hljs-comment">// 记录页面分配、释放和清理跟踪信息的缓冲区。</span><br>    pageTraceBuf   pageTraceBuf<br>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 结构体在 Go语言的运行时系统中代表了一个处理器（processor），它是调度器的核心组成部分。每个<code>p</code> 负责管理一组 <code>goroutine</code>的运行。这个结构体包含了许多字段，涉及到 <code>goroutine</code>的调度、内存分配、垃圾回收和其他系统级别的操作。</p><p>我们重点关注以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m           muintptr   <span class="hljs-comment">// 当前负责的线程</span><br>  <br><span class="hljs-comment">// 本地可运行的协程的队列，可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq     [<span class="hljs-number">256</span>]guintptr   <span class="hljs-comment">// 长度为 256</span><br>runnext guintptr <span class="hljs-comment">// 下一个可用的协程的指针</span><br>  <br>  <span class="hljs-comment">// 抢占标识，指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br>  preempt <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="goroutine-的创建">3. Goroutine 的创建</h2><p>Go 并发能力的优秀之处，就在于它启动一个新的协程实在是太方便了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;()<br></code></pre></td></tr></table></figure><p>那么底层究竟做了什么呢？</p><h3 id="newproc">3.1 newproc()</h3><p>Goroutine 通过 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>中的 <code>newproc()</code> 创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>    gp := getg()<br>    pc := getcallerpc()<br>    systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        newg := newproc1(fn, gp, pc)<br><br>        pp := getg().m.p.ptr()<br>        runqput(pp, newg, <span class="hljs-literal">true</span>)<br><br>        <span class="hljs-keyword">if</span> mainStarted &#123;<br>            wakep()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>获取当前 goroutine 和调用者 PC</strong>: <code>getg()</code>获取当前正在执行的 <code>goroutine</code>，<code>getcallerpc()</code>获取调用者的程序计数器地址。</li><li><strong>在系统栈上执行 <code>newproc1</code></strong>:<code>systemstack</code> 确保 <code>newproc1</code>在系统栈上执行，而不是当前 <code>goroutine</code> 的栈。这是因为新的<code>goroutine</code> 可能需要更多的栈空间。</li><li><strong>创建新的 goroutine</strong>: <code>newproc1</code>被调用来实际创建新的 <code>goroutine</code>。</li><li><strong>将新的 goroutine 放入运行队列</strong>: <code>runqput</code>将新创建的 <code>goroutine</code> 放入运行队列。</li><li><strong>唤醒处理器</strong>:如果主函数已经开始执行，<code>wakep</code> 用于唤醒一个空闲的 P来运行新的 <code>goroutine</code>。</li></ol><h3 id="newproc1">3.2 newproc1()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br>    <span class="hljs-comment">// ... (省略了错误检查和获取 M 的代码)</span><br><br>  <span class="hljs-comment">// 尝试从 P 的空闲列表获取一个 G，如果没有则创建一个新的</span><br>    newg := gfget(pp)<br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin)<br>        casgstatus(newg, _Gidle, _Gdead)<br>        allgadd(newg)<br>    &#125;<br><br>    <span class="hljs-comment">// 设置新 G 的栈</span><br>    totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize)<br>    totalSize = alignUp(totalSize, sys.StackAlign)<br>    sp := newg.stack.hi - totalSize<br>  spArg := sp<br>  <br>    <span class="hljs-comment">// 清空并设置新 G 的调度器相关字段</span><br>    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br>    newg.sched.sp = sp<br>    newg.stktopsp = sp<br>    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br>    newg.sched.g = guintptr(unsafe.Pointer(newg))<br>  <br>    <span class="hljs-comment">// 设置新 G 的其他字段</span><br>    gostartcallfn(&amp;newg.sched, fn)<br>    newg.parentGoid = callergp.goid<br>    newg.gopc = callerpc<br>    newg.startpc = fn.fn<br>    <br>  <span class="hljs-comment">// ... (省略了跟踪和调试相关的代码)</span><br><br>    casgstatus(newg, _Gdead, _Grunnable)<br><br>    <span class="hljs-keyword">return</span> newg<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建或获取一个新的 goroutine</strong>: <code>gfget</code>尝试从 P 的空闲列表中获取一个<code>goroutine</code>，如果没有可用的，则通过 <code>malg</code>分配一个新的。</li><li><strong>初始化 goroutine 的栈和调度器</strong>: 设置新<code>goroutine</code>的栈、程序计数器、调用函数等。这里有个非常核心的点<code>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</code>，我们前面留了个疑问，协程栈顶的<code>goexit</code> 是哪里来的，就是这里来的。这里设置新<code>goroutine</code> 的程序计数器（<code>pc</code>）指向<code>goexit</code> 函数。<code>goexit</code> 是每个<code>goroutine</code> 在退出时必须调用的函数，用于执行清理工作并切换到g0 栈。</li><li><strong>设置父 goroutine ID 和创建点</strong>: 记录创建这个新<code>goroutine</code> 的父 <code>goroutine</code> 的 ID 和<code>go</code> 语句的位置。</li><li><strong>更改 goroutine 状态</strong>: 将新 <code>goroutine</code>的状态从 <code>_Gdead</code> 改为<code>_Grunnable</code>，使其准备好被调度。</li><li><strong>返回新的 goroutine</strong>: 函数返回新创建的<code>goroutine</code>。</li></ol><h3 id="runqput">3.3 runqput()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput tries to put g on the local runnable queue.</span><br><span class="hljs-comment">// If next is false, runqput adds g to the tail of the runnable queue.</span><br><span class="hljs-comment">// If next is true, runqput puts g in the pp.runnext slot.</span><br><span class="hljs-comment">// If the run queue is full, runnext puts g on the global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>随机调度器</strong>：如果启用了调度器的随机化（<code>randomizeScheduler</code>），并且<code>next</code> 为 <code>true</code>（newproc 调用的时候永远都是传的true），则有一半的概率将 <code>next</code> 设置为<code>false</code>。这有助于防止调度器的行为过于可预测。</li><li><strong>处理 <code>runnext</code> 槽</strong>：如果<code>next</code> 为 <code>true</code>，函数尝试将 <code>gp</code> 放入<code>pp.runnext</code> 槽。如果该槽已被占用，则将原有的<code>goroutine</code> 移动到常规运行队列，并重试将新的 <code>gp</code>放入 <code>runnext</code>。</li><li><strong>放入本地运行队列</strong>：如果 <code>next</code> 为<code>false</code> 或 <code>runnext</code> 槽已满，函数尝试将<code>gp</code> 放入本地运行队列的尾部。如果队列未满，<code>gp</code>将被成功添加。</li><li><strong>处理队列满的情况</strong>：如果本地运行队列已满，<code>runqputslow</code>被调用，尝试将 <code>gp</code> 连同自己队列中一半的 g放入全局运行队列。如果这也失败了，函数会重试将 <code>gp</code>放入本地队列。</li><li><strong>原子操作</strong>：函数使用原子操作来加载和存储队列头（<code>runqhead</code>）和尾（<code>runqtail</code>）指针，以确保多线程环境下的数据一致性和线程安全。</li></ol><h3 id="runqputslow">3.4 runqputslow()</h3><p><code>runqputslow</code> 函数处理本地运行队列满的情况，将<code>goroutine</code>批量转移到全局队列。这个函数通过原子操作和锁来确保操作的原子性和线程安全。随机化调度器的使用增加了调度的随机性和公平性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>  <span class="hljs-comment">// 从 pp 的本地队列中获取一半的 goroutine</span><br>  <span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br>n := t - h<br>n = n / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>batch[n] = gp<br><br>  <span class="hljs-comment">// 随机打乱 goroutine 的顺序，以增加调度的随机性</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 串成队列</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建批处理数组</strong>：函数首先创建一个 <code>batch</code>数组，用于存储从本地队列中取出的 <code>goroutine</code>。</li><li><strong>从本地队列中获取一批<code>goroutine</code></strong>：函数计算出要从本地队列中取出多少个<code>goroutine</code>（通常是队列长度的一半），并将它们添加到<code>batch</code> 数组中。</li><li><strong>原子操作更新队列头部</strong>：使用原子操作<code>atomic.CasRel</code>更新本地运行队列的头部索引，这是一个释放（release）操作，确保之前的读取操作完成。</li><li><strong>将当前 <code>goroutine</code>添加到批处理中</strong>：将传入的 <code>gp</code> 添加到<code>batch</code> 数组的末尾。</li><li><strong>随机化调度器</strong>：如果启用了随机调度器，函数会随机打乱<code>batch</code> 数组中的 <code>goroutine</code>顺序，以增加调度的随机性。</li><li><strong>链接 <code>goroutine</code></strong>：将 <code>batch</code>数组中的 <code>goroutine</code> 链接起来，形成一个队列。</li><li><strong>准备全局队列</strong>：创建一个 <code>gQueue</code>结构，并设置其头部和尾部指向 <code>batch</code> 数组中的第一个和最后一个<code>goroutine</code>。</li><li><strong>将批处理放入全局队列</strong>：加锁访问全局调度器的锁，然后将整个<code>batch</code> 队列放入全局运行队列。</li></ol><h2 id="调度过程-schedule">4. 调度过程 schedule()</h2><p>Go 的调度器核心执行逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>的 <code>schedule()</code>函数中。我们先不探讨过多的细节，我们先把整个大体脉络理清楚再说。</p><p>简化后的 <code>schedule()</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br>  ...<br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br>  ...<br><span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute()</code> 执行 g，它简化后如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br>..<br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了 <code>gogo()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gogo</span><span class="hljs-params">(buf *gobuf)</span></span><br></code></pre></td></tr></table></figure><p>一般这种格式说明函数是用汇编实现的，我们在 Goland 上可以双击 shift然后搜索 <code>runtime·gogo</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128130637007.png"alt="runtime·gogo" /><figcaption aria-hidden="true">runtime·gogo</figcaption></figure><p>不同的平台有不同的实现，但是核心逻辑都是一样的，它直接操作处理器的寄存器和栈，以实现从一个 <code>goroutine</code>切换到另一个 <code>goroutine</code> 的功能。</p><p>我们后面的发内心会发现 <code>goexit()</code> 最终会调用<code>schedule()</code>。</p><p>这就串起来了，Go 程序启动后会创建 m0 和g0，所以第一个<code>schedule()</code> 是 g0 调用的，最后通过<code>gogo</code> 切换到用户协程 g 上面执行业务方法，完事后 g 通过<code>goexit</code> 回到 <code>schedule()</code>，以此循环反复下去。</p><p>现在我们可以来总结一下 GPM 调度循环的过程，大概如下图表示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><p>下面我们再对这个过程中的关键函数进行细致分析：</p><ul><li><code>schedule()</code>：调度入口。</li><li><code>findRunnable()</code>：寻找可执行的 G。</li><li><code>execute()</code>：执行 G。</li><li><code>gogo()</code>：切换协程栈 g0 到 g。</li><li><code>goexit()</code>：退出 g 协程，切换回 g0 栈。</li></ul><h3 id="schedule">4.1 schedule()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br><br>  <span class="hljs-comment">// 有锁的话抛出异常，避免该情况下调度出现死锁或其他问题</span><br><span class="hljs-keyword">if</span> mp.locks != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// M 被锁定了特定的 G，这个时候直接执行这个锁定的 G。</span><br><span class="hljs-keyword">if</span> mp.lockedg != <span class="hljs-number">0</span> &#123;<br>stoplockedm()<br>execute(mp.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span><br>&#125;<br><br><span class="hljs-comment">// CGO 调用需要 g0 栈，所以这个时候不继续调度了，抛出异常。</span><br><span class="hljs-keyword">if</span> mp.incgo &#123;<br>throw(<span class="hljs-string">&quot;schedule: in cgo&quot;</span>)<br>&#125;<br><br>top:<br>pp := mp.p.ptr()<br>pp.preempt = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 安全点检查：如果当前 M 在自旋的话，应该是没有可执行 G 的。</span><br><span class="hljs-keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) &#123;<br>throw(<span class="hljs-string">&quot;schedule: spinning with local work&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br><br>  <span class="hljs-comment">// 调试的时候系统会处于“冻结”状态，</span><br>  <span class="hljs-comment">// 这里故意通过两次 lock 引入死锁使当前 M 陷入无限等待，</span><br>  <span class="hljs-comment">// 以在调试时保持当前的调度器和运行时状态不变。</span><br><span class="hljs-keyword">if</span> debug.dontfreezetheworld &gt; <span class="hljs-number">0</span> &amp;&amp; freezing.Load() &#123;<br>lock(&amp;deadlock)<br>lock(&amp;deadlock)<br>&#125;<br><br>  <span class="hljs-comment">// 如果当前 M 之前是自旋的，但是现在要准备执行 G 了，那就不是自旋了。</span><br><span class="hljs-keyword">if</span> mp.spinning &#123;<br>resetspinning()<br>&#125;<br><br>  <span class="hljs-comment">// 当用户级调度被禁用时，采用双重检查后如果确实被禁用了，</span><br>  <span class="hljs-comment">// 那么就把当前 g 放在 sched.disable.runnable 列表中，</span><br>  <span class="hljs-comment">// 等待调度重启启用时再处理。</span><br>  <span class="hljs-comment">// 在 gc 的时候会出现这种情况：</span><br>  <span class="hljs-comment">// gcStart()    -&gt;  schedEnableUser(false)</span><br>  <span class="hljs-comment">// gcMarkDone() -&gt;  schedEnableUser(true)</span><br><span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;<br>lock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> schedEnabled(gp) &#123;<br>unlock(&amp;sched.lock)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sched.disable.runnable.pushBack(gp)<br>sched.disable.n++<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要唤醒一个 P。</span><br>  <span class="hljs-comment">// 如果返回的 g 比较特殊，比如要负责 gc，那么这个值会是 true。</span><br><span class="hljs-keyword">if</span> tryWakeP &#123;<br>wakep()<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果 g 已经绑定了 M，则直接启动该 M 去执行 g。</span><br><span class="hljs-keyword">if</span> gp.lockedm != <span class="hljs-number">0</span> &#123;<br>startlockedm(gp)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>  <span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>schedule()</code> 函数是 Go 调度器的核心，负责管理<code>goroutine</code> 的执行。它包括多个步骤，如检查当前 M的状态，处理特殊情况（如 <code>goroutine</code> 被锁定到特定的 M，或者 M正在执行 CGO 调用），以及选择和执行可运行的 <code>goroutine</code>。</p><h3 id="findrunnable">4.2 findRunnable()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finds a runnable goroutine to execute.</span><br><span class="hljs-comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span><br><span class="hljs-comment">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace reader) so the caller should try to wake a P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道这个函数的作用：寻找一个可执行的 goroutine：</p><ol type="1"><li>尝试从其他 P 窃取 g、从本地获取 g、从全局队列获取g、从网络轮询器获取 g；</li><li>如果是一个特殊的 g，如要负责 gc 或 trace，那么会将<code>tryWakeP</code> 置为<code>true</code>，表示调度器需要尝试唤醒或启动一个新的 P 来运行这个g，以确保了即使在系统负载较低时，这些特殊的g 也能得到及时处理。</li></ol><p>我们只关心它的核心部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br>  <span class="hljs-comment">// 获取当前 M</span><br>mp := getg().m<br>top:<br>  <br>  <span class="hljs-comment">// 获取 M 绑定的 P</span><br>pp := mp.p.ptr()<br><br><span class="hljs-comment">// 1. 每 61 次循环调度，就会去全局队列中获取一个 g 来执行</span><br><span class="hljs-keyword">if</span> pp.schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">1</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 从本地队列中获取 g</span><br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 3. 从全局队列中获取 g</span><br><span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">0</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 从网络轮询器中获取 g</span><br><span class="hljs-keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="hljs-number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> list := netpoll(<span class="hljs-number">0</span>); !list.empty() &#123; <span class="hljs-comment">// non-blocking</span><br>gp := list.pop()<br>injectglist(&amp;list)<br>casgstatus(gp, _Gwaiting, _Grunnable)<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoUnpark(gp, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 5. 自旋，从其他 P 窃取 g</span><br>  <span class="hljs-comment">// mp.spinning 这个条件检查当前 M（操作系统线程）是否应该进入自旋状态。</span><br>  <span class="hljs-comment">// 自旋状态意味着 M 会积极地寻找工作，而不是休眠。</span><br>  <span class="hljs-comment">// 2*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load()</span><br>  <span class="hljs-comment">// 这个条件确保系统中自旋的 M 的数量不会超过一定比例。</span><br>  <span class="hljs-comment">// 这是为了防止在低并发情况下过多的 CPU 使用。</span><br><span class="hljs-keyword">if</span> mp.spinning || <span class="hljs-number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;<br><span class="hljs-keyword">if</span> !mp.spinning &#123;<br>mp.becomeSpinning()<br>&#125;<br> <br>gp, inheritTime, tnow, w, newWork := stealWork(now)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> newWork &#123;<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>&#125;<br>  ...<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个过程涉及到几个重要的函数：</p><ul><li><code>globrunqget()</code>：从全局队列中寻找可运行的 G。</li><li><code>runqget()</code>：从本地队列中寻找可运行的 G。</li><li><code>netpoll()</code>：寻找可以运行的网络协程。</li><li><code>stealWork()</code>：从其他 P 窃取可运行的 G。</li></ul><h3 id="globrunqget">4.3 globrunqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">globrunqget</span><span class="hljs-params">(pp *p, max <span class="hljs-type">int32</span>)</span></span> *g &#123;<br>  <span class="hljs-comment">// 抢全局列表的锁</span><br>    assertLockHeld(&amp;sched.lock)<br><br>  <span class="hljs-comment">// 如果为空则直接返回</span><br>    <span class="hljs-keyword">if</span> sched.runqsize == <span class="hljs-number">0</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>  <span class="hljs-comment">// 确定 n 的大小，即要从全局队列中获取的 g 的个数。</span><br>  <span class="hljs-comment">// 这里会结合入参 max 对边界值进行判断，以获得一个合理的 n。</span><br>  <span class="hljs-comment">// 一次性最多拿 len(pp.runq)/2 个 g。</span><br>    n := sched.runqsize/gomaxprocs + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n &gt; sched.runqsize &#123;<br>       n = sched.runqsize<br>    &#125;<br>    <span class="hljs-keyword">if</span> max &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; max &#123;<br>       n = max<br>    &#125;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq))/<span class="hljs-number">2</span> &#123;<br>       n = <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq)) / <span class="hljs-number">2</span><br>    &#125;<br><br>    sched.runqsize -= n<br><br>  <span class="hljs-comment">// 通过 pop() 从全局队列中弹出 g</span><br>    gp := sched.runq.pop()<br>    n--<br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>       gp1 := sched.runq.pop()<br>       <span class="hljs-comment">// 将 g 放入 pp 的本地队列中</span><br>       <span class="hljs-comment">// runqput 在前面创建协程的地方已经介绍过了，这里不赘述。</span><br>       runqput(pp, gp1, <span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runqget">4.4 runqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqget</span><span class="hljs-params">(pp *p)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// runnext 的 g 会优先执行</span><br>next := pp.runnext<br><span class="hljs-keyword">if</span> next != <span class="hljs-number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> next.ptr(), <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 原子操作获取队头指针</span><br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t == h &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 从队头获取 g，并通过原子操作更新队头（即抢这个 g）</span><br>gp := pp.runq[h%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="hljs-number">1</span>) &#123; <br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqget()</code> 函数用于从本地运行队列中获取一个可运行的<code>goroutine</code>。这个函数只能由拥有该队列的处理器（P）执行。下面是对这个函数的详细解释：</p><p><strong>1. 检查 <code>runnext</code></strong>：</p><ul><li><code>runnext</code> 是一个特殊的字段，用于存储下一个要运行的<code>goroutine</code>。如果 <code>runnext</code>非零，并且能成功通过原子操作（CAS）将其设置为零，则直接返回这个<code>goroutine</code>。</li><li>如果成功获取 <code>runnext</code> 指向的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>true</code>，表示这个 <code>goroutine</code>应该继承当前时间片的剩余时间。</li><li>如果没成功，意味着 runnext 的这个 g 已经被其他 P给抢了，因为我们可以发现本 P 只可能将其设置为 0，只有其他 P才会将其设置以为非 0。</li></ul><p><strong>2. 从本地队列中获取 <code>goroutine</code></strong>：</p><ul><li>使用原子操作加载<code>runqhead</code>（队列头指针），<code>runqtail</code>（队列尾指针）。</li><li>如果 <code>runqhead</code> 等于<code>runqtail</code>，表示队列为空，返回 <code>nil</code>。</li><li>否则，从队列中获取 <code>runqhead</code> 指向的<code>goroutine</code>，并尝试通过原子操作（CAS）更新<code>runqhead</code>。</li><li>如果更新成功，返回获取到的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>false</code>，表示这个 <code>goroutine</code>应该开始一个新的时间片。</li></ul><p>两个问题：</p><p><strong>1. 为什么获取 runqhead 需要上锁，获取 runqtail就不需要？</strong></p><p><strong>单一生产者</strong>：每个本地运行队列只有一个生产者，即与之关联的当前P。只有这个 P 可以向队列尾部添加新的<code>goroutine</code>。由于不存在多个生产者的并发写入问题，因此不需要锁来保护队尾。</p><p><strong>2. inheritTime 有什么用？</strong></p><p><code>inheritTime</code> 的主要作用是决定新调度的<code>goroutine</code>是否应该立即开始一个新的时间片，或者继续使用当前时间片的剩余部分。这在以下两种情况下尤为重要：</p><ul><li><strong>继承时间片</strong> (<code>inheritTime == true</code>)：当<code>runqget</code> 从 <code>runnext</code> 字段获取<code>goroutine</code> 时，这个 <code>goroutine</code>被认为是特别优先的，因此它继承了当前时间片的剩余时间。这通常发生在<code>goroutine</code>通过特定的同步机制（如通道操作）被明确唤醒时。</li><li><strong>开始新的时间片</strong>(<code>inheritTime == false</code>)：当 <code>runqget</code>从本地运行队列中正常获取 <code>goroutine</code> 时，这个<code>goroutine</code>将开始一个全新的时间片。这确保了调度的公平性，使得每个<code>goroutine</code> 都有机会在给定的时间片内运行。</li></ul><h3 id="netpoll">4.5 netpoll()</h3><p><code>netpoll()</code> 函数是 Go语言运行时网络轮询机制的一部分，用于检查网络连接是否准备好进行非阻塞 I/O操作。这个函数返回一组已经变为可运行状态的 <code>goroutine</code>，这些<code>goroutine</code> 之前可能因等待网络 I/O 而被挂起。</p><p>这里涉及到 Go 语言网络编程原理，在本文中不细究，就简单带过了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpoll</span><span class="hljs-params">(delay <span class="hljs-type">int64</span>)</span></span> gList &#123;<br>  <span class="hljs-comment">// 检查轮询器是否初始化。</span><br><span class="hljs-keyword">if</span> kq == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br>  <span class="hljs-comment">// 设置轮询超时。</span><br><span class="hljs-keyword">var</span> tp *timespec<br><span class="hljs-keyword">var</span> ts timespec<br><span class="hljs-keyword">if</span> delay &lt; <span class="hljs-number">0</span> &#123;<br>tp = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> delay == <span class="hljs-number">0</span> &#123;<br>tp = &amp;ts<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ts.setNsec(delay)<br><span class="hljs-keyword">if</span> ts.tv_sec &gt; <span class="hljs-number">1e6</span> &#123;<br>ts.tv_sec = <span class="hljs-number">1e6</span><br>&#125;<br>tp = &amp;ts<br>&#125;<br>  <span class="hljs-comment">// 使用 kevent 进行轮询操作，结果放在 events 中。</span><br><span class="hljs-keyword">var</span> events [<span class="hljs-number">64</span>]keventt<br>retry:<br>n := kevent(kq, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>, &amp;events[<span class="hljs-number">0</span>], <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(events)), tp)<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> n != -_EINTR &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: kevent on fd&quot;</span>, kq, <span class="hljs-string">&quot;failed with&quot;</span>, -n)<br>throw(<span class="hljs-string">&quot;runtime: netpoll failed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>  <span class="hljs-comment">// 遍历 events 处理轮询事件。</span><br><span class="hljs-keyword">var</span> toRun gList<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(n); i++ &#123;<br>ev := &amp;events[i]<br><br>    <span class="hljs-comment">// netpollBreakRd 用于唤醒轮询，即唤醒等待中的 goroutine。</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(ev.ident) == netpollBreakRd &#123;<br><span class="hljs-keyword">if</span> ev.filter != _EVFILT_READ &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for&quot;</span>, ev.filter)<br>throw(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for something unexpected&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> tmp [<span class="hljs-number">16</span>]<span class="hljs-type">byte</span><br>read(<span class="hljs-type">int32</span>(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[<span class="hljs-number">0</span>])), <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(tmp)))<br>netpollWakeSig.Store(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>    <span class="hljs-comment">// 根据轮询事件的类型（读或写），唤醒相应等待网络 I/O 的 groutine。</span><br><span class="hljs-keyword">var</span> mode <span class="hljs-type">int32</span><br><span class="hljs-keyword">switch</span> ev.filter &#123;<br><span class="hljs-keyword">case</span> _EVFILT_READ:<br>mode += <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">if</span> ev.flags&amp;_EV_EOF != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">case</span> _EVFILT_WRITE:<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> mode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> pd *pollDesc<br><span class="hljs-keyword">var</span> tag <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">4</span> &#123;<br>pd = (*pollDesc)(unsafe.Pointer(ev.udata))<br>tag = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tp := taggedPointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(ev.udata)))<br>pd = (*pollDesc)(tp.pointer())<br>tag = tp.tag()<br><span class="hljs-keyword">if</span> pd.fdseq.Load() != tag &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>pd.setEventErr(ev.flags == _EV_ERROR, tag)<br>      <span class="hljs-comment">// 标记 goroutine 可执行。</span><br>netpollready(&amp;toRun, pd, mode)<br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 返回可运行的 goroutine 列表。</span><br><span class="hljs-keyword">return</span> toRun<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stealwork">4.6 stealWork()</h3><p><code>stealWork()</code> 函数用于尝试从其他处理器（P）窃取可运行的<code>goroutine</code> 或定时器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stealWork</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>, rnow, pollUntil <span class="hljs-type">int64</span>, newWork <span class="hljs-type">bool</span>) &#123;<br>  <br>  <span class="hljs-comment">// 获取当前 M 绑定的 P。</span><br>pp := getg().m.p.ptr()<br><br>ranTimer := <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 尝试 4 次。</span><br><span class="hljs-keyword">const</span> stealTries = <span class="hljs-number">4</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stealTries; i++ &#123;<br>    <span class="hljs-comment">// 前 3 次尝试窃取 g。</span><br>    <span class="hljs-comment">// 第 4 次尝试窃取 timer，并且尝试获取其他 P 的 runnext 中的 g。</span><br>stealTimersOrRunNextG := i == stealTries<span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 随机选一个 P。</span><br><span class="hljs-keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;<br><span class="hljs-comment">// 如果系统正在 GC，则可以直接返回 true，因为可能要负责 gc 了，有事干了。</span><br>      <span class="hljs-keyword">if</span> sched.gcwaiting.Load() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, <span class="hljs-literal">true</span><br>&#125;<br>      <br>      <span class="hljs-comment">// 获取选中的 P，如果是当前 P 则直接 continue，重试。</span><br>p2 := allp[enum.position()]<br><span class="hljs-keyword">if</span> pp == p2 &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>      <span class="hljs-comment">// 第 4 次尝试去窃取 p2 的 timer。</span><br><span class="hljs-keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 检查并可能执行 timer。</span><br>tnow, w, ran := checkTimers(p2, now)<br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>        <span class="hljs-comment">// 如果执行了 timer，则检查本地队列是否有 g 可以运行，</span><br>        <span class="hljs-comment">// 因为 timer 会唤醒被挂起的 g。</span><br><span class="hljs-keyword">if</span> ran &#123;<br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer<br>&#125;<br>ranTimer = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br>      <span class="hljs-comment">// 前 3 次尝试或者第 4 次尝试没有窃取到 timer 的时候，</span><br>      <span class="hljs-comment">// 就从其他非空闲 P 的本地队列中尝试窃取 g。</span><br><span class="hljs-keyword">if</span> !idlepMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 如果 stealTimersOrRunNextG 为 true，</span><br>        <span class="hljs-comment">// 那么会在窃取的时候，尝试窃取 p2 的 runnext。</span><br><span class="hljs-keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>阅读源码的好处这就体现了，所有人都告诉我们 P 找不到可运行 G的时候就会去窃取其他 P 的G，但没人告诉我们，在这个过程<strong>还可能会去窃取其他 P 的 timer 和runnext</strong>。</p><p>所谓<code>timer</code>，即定时器，用于在指定的时间后执行某些操作。这些操作通常包括唤醒等待特定时间的<code>goroutine</code>，或执行与时间相关的任务。定时器在 Go的并发模型中扮演着重要的角色，特别是在涉及到时间延迟或周期性任务的场景中。在调度器层面，定时器的管理对于确保及时响应时间相关的事件和维持高效的调度至关重要。通过合理地处理定时器事件，Go能够在保持高并发性的同时，有效地管理时间延迟和周期性任务。</p><p>在 Go 语言的调度器中，跨 P 的定时器窃取是一种优化机制，它有 2个好处：</p><ul><li><strong>保持处理器活跃</strong>：当一个 P没有足够的本地工作时，它可以尝试从其他 P窃取定时器任务。这样做可以保持该 P活跃，避免它进入休眠状态，从而提高整体系统的效率。</li><li><strong>平衡系统负载</strong>：在多核系统中，不同的 P可能会有不同的负载。跨 P 的定时器窃取有助于在 P之间平衡负载，特别是在一些 P 非常忙碌而其他 P 相对空闲的情况下。</li></ul><p>好的，回过头来，为什么我们会说窃取的时候会从队头窃取呢？为什么是窃取p2 一半的 g 呢？这个过程就在 <code>runqsteal()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqsteal</span><span class="hljs-params">(pp, p2 *p, stealRunNextG <span class="hljs-type">bool</span>)</span></span> *g &#123;<br>t := pp.runqtail<br>  <br>  <span class="hljs-comment">// 从 p2 中获取 n 个 g。</span><br>n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 返回第 1 个 g，因为它可以直接执行了。</span><br>n--<br>gp := pp.runq[(t+n)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br>  <span class="hljs-comment">// 如果还有剩下的 g，那么就加入到本地队列中。</span><br>  <span class="hljs-comment">// 这里可以看到是从队头加入的，所以需要使用原子操作获取队头。</span><br>h := atomic.LoadAcq(&amp;pp.runqhead)<br><span class="hljs-keyword">if</span> t-h+n &gt;= <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>throw(<span class="hljs-string">&quot;runqsteal: runq overflow&quot;</span>)<br>&#125;<br>atomic.StoreRel(&amp;pp.runqtail, t+n)<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqgrab()</code> 是窃取 n 个 g 的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqgrab</span><span class="hljs-params">(pp *p, batch *[256]guintptr, batchHead <span class="hljs-type">uint32</span>, stealRunNextG <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br>  <span class="hljs-comment">// 使用无限循环来尝试窃取工作，直到成功或确定没有可窃取的工作。</span><br><span class="hljs-keyword">for</span> &#123;<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := atomic.LoadAcq(&amp;pp.runqtail) <br>n := t - h<br>    <br>    <span class="hljs-comment">// 这里可以看到，要窃取的个数，就是 pp 本地队列中 g 个数的一半</span><br>n = n - n/<span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment">// 如果 n 为 0，且 stealRunNextG == true，</span><br>    <span class="hljs-comment">// 那么就尝试窃取 pp 的 runnext 中的 g。</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> stealRunNextG &#123;<br><span class="hljs-keyword">if</span> next := pp.runnext; next != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> !pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>batch[batchHead%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = next<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 如果 n 不为队列长度的一半，则说明队列发生了变化，</span><br>    <span class="hljs-comment">// 这个时候重新尝试窃取。</span><br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>    <span class="hljs-comment">// 将要窃取的 g 从 pp.runq 中转移到 batch 中。</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>g := pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))]<br>batch[(batchHead+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = g<br>&#125;<br>    <span class="hljs-comment">// 使用原子操作尝试更新 pp 的队列头部，即将 g 从 pp.runq 中移除。</span><br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>findRunnable()</code>的全部过程我们总算是梳理完了，这个过程确实非常精彩，Go调度器在提高调度性能、确保调度的公平性、平衡系统负载、降低同步开销、减少资源再分配等方面都做了很多的努力，这才让Go 语言的并发又强大又易用。</p><p>下面是对 <code>findRunnable()</code> 一个简单的总结：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h3 id="execute">4.7 execute()</h3><p><code>findRunnable()</code> 之后就是<code>execute()</code>，它的核心过程如下（有删减）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br><span class="hljs-comment">// 将 g0 d 线程信息复制到即将要调用的协程 gp 中。</span><br>mp.curg = gp<br>gp.m = mp<br>  <span class="hljs-comment">// 修改 gp 的状态为 _Grunning，即运行中。</span><br>casgstatus(gp, _Grunnable, _Grunning)<br>gp.waitsince = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 标记为非抢占</span><br>gp.preempt = <span class="hljs-literal">false</span><br>  <span class="hljs-comment">// 用于栈保护，检测栈溢出</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br>  <span class="hljs-comment">// gogo 会完成 g0 到 g 的协程栈的切换，并从 gp.sched 开始执行。</span><br>  <span class="hljs-comment">// sched 字段我们前面介绍过，它是 gobuf 结构体，存储了 sp 和 pc。</span><br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>execute()</code> 的工作非常简单，其实就是将 g0的线程信息复制到 gp 上，并修改状态和一些元数据，核心部分其实在<code>gogo()</code> 中。</p><h3 id="gogo">4.8 gogo()</h3><p>前面我们说过，<code>gogo()</code> 会完成 g0 栈到 g栈的切换，且在不同平台下有不同的视线，这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/asm_arm64.s">asm_arm64.s</a>为代表来看一下 <code>gogo()</code> 的汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8<br>MOVDbuf+0(FP), R5<br>MOVDgobuf_g(R5), R6<br>MOVD0(R6), R4// make sure g != nil<br>Bgogo&lt;&gt;(SB)<br><br>TEXT gogo&lt;&gt;(SB), NOSPLIT|NOFRAME, $0<br>MOVDR6, g<br>BLruntime·save_g(SB)<br><br>MOVDgobuf_sp(R5), R0<br>MOVDR0, RSP<br>MOVDgobuf_bp(R5), R29<br>MOVDgobuf_lr(R5), LR<br>MOVDgobuf_ret(R5), R0<br>MOVDgobuf_ctxt(R5), R26<br>MOVD$0, gobuf_sp(R5)<br>MOVD$0, gobuf_bp(R5)<br>MOVD$0, gobuf_ret(R5)<br>MOVD$0, gobuf_lr(R5)<br>MOVD$0, gobuf_ctxt(R5)<br>CMPZR, ZR // set condition codes for == test, needed by stack split<br>MOVDgobuf_pc(R5), R6<br>B(R6)<br></code></pre></td></tr></table></figure><p>具体过程如下：</p><ol type="1"><li><strong><code>runtime·gogo</code>函数</strong>：这个函数用于设置新的 <code>goroutine</code>上下文。它接收一个指向 <code>gobuf</code>结构的指针（<code>buf+0(FP)</code>），该结构包含了<code>goroutine</code> 的上下文信息。</li><li><strong>加载 <code>gobuf</code> 并检查 <code>g</code></strong>：加载<code>gobuf</code> 结构，并检查 <code>g</code> 是否为<code>nil</code>。</li><li><strong>跳转到 <code>gogo&lt;&gt;</code></strong>：执行无条件跳转到<code>gogo&lt;&gt;</code> 函数。</li><li><strong><code>gogo&lt;&gt;</code>函数</strong>：这个函数实际上完成了上下文切换。<ul><li>设置当前 <code>goroutine</code>：将 <code>R6</code>寄存器中的值（新的 <code>goroutine</code>）设置为当前<code>goroutine</code>。</li><li>保存当前 <code>goroutine</code>：调用 <code>runtime·save_g</code>保存当前 <code>goroutine</code> 的状态。</li><li>恢复栈指针和其他寄存器：从 <code>gobuf</code>结构中恢复栈指针（<code>RSP</code>）、基指针（<code>R29</code>）、链接寄存器（<code>LR</code>）、返回值（<code>R0</code>）和上下文（<code>R26</code>）。</li><li>清空 <code>gobuf</code> 结构：将 <code>gobuf</code>结构中的字段清零。</li><li>准备跳转到新的程序计数器位置：从 <code>gobuf</code>中加载新的程序计数器地址（<code>gobuf_pc(R5)</code>）到<code>R6</code>。</li><li>跳转执行：通过 <code>B (R6)</code>跳转到新的程序计数器地址，继续执行新 <code>goroutine</code>的代码。</li></ul></li></ol><p>这段汇编代码是 Go 运行时中处理 <code>goroutine</code>上下文切换的关键部分。它直接操作处理器的寄存器和栈，以实现从一个<code>goroutine</code> 切换到另一个 <code>goroutine</code> 的功能。</p><p>在 <code>execute()</code> 中是这么调用 <code>gogo()</code> 的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">gogo(&amp;gp.sched)<br></code></pre></td></tr></table></figure><p>所以完成栈的切换后会从 <code>gp.sched</code>开始，执行代码，前面我们介绍过 <code>sched</code> 是一个<code>gobuf</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>sp   <span class="hljs-type">uintptr</span><br>pc   <span class="hljs-type">uintptr</span><br>g    guintptr<br>ctxt unsafe.Pointer<br>ret  <span class="hljs-type">uintptr</span><br>lr   <span class="hljs-type">uintptr</span><br>bp   <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以会从 pc 处开始执行业务代码，前面在 <code>newproc()</code>的时候，我们提过一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br></code></pre></td></tr></table></figure><p>这行代码的作用，是在协程创建的时候插入一个 <code>goexit</code>函数的地址，因为这个时候 <code>g</code>刚创建，所以其实就是往协程栈顶插入了 <code>goexit</code> 的地址。所以当<code>g</code> 执行完业务代码后，当栈中元素不断弹出后，最终就会弹出<code>goexit</code> 的地址，然后执行 <code>goexit()</code>函数，退出当前 <code>g</code>，切换回 <code>g0</code>。</p><h3 id="goexit">4.9 goexit()</h3><p><code>goexit</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stubs.go">runtime/stubs.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goexit is the return stub at the top of every goroutine call stack.</span><br><span class="hljs-comment">// Each goroutine stack is constructed as if goexit called the</span><br><span class="hljs-comment">// goroutine&#x27;s entry point function, so that when the entry point</span><br><span class="hljs-comment">// function returns, it will return to goexit, which will call goexit1</span><br><span class="hljs-comment">// to perform the actual exit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function must never be called directly. Call goexit1 instead.</span><br><span class="hljs-comment">// gentraceback assumes that goexit terminates the stack. A direct</span><br><span class="hljs-comment">// call on the stack will cause gentraceback to stop walking the stack</span><br><span class="hljs-comment">// prematurely and if there is leftover state it may panic.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit</span><span class="hljs-params">(neverCallThisFunction)</span></span><br></code></pre></td></tr></table></figure><p>通过注释我们可以得到 2 个信息：</p><ul><li><code>goexit</code> 的位于每个 goroutine 调用栈的顶部。每个goroutine 的栈被构造得好像 <code>goexit</code> 调用了 goroutine的入口函数。这意味着当入口函数返回时，它实际上返回到<code>goexit</code>。</li><li>不要直接调用 <code>goexit</code>，应该调用<code>goexit1</code>。</li></ul><p><code>goexit1</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finishes execution of the current goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racegoend()<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoEnd()<br>&#125;<br>mcall(goexit0)<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，它调用了<code>goexit0</code>，原来这才是真正的退出入口，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前的 M 和 P</span><br>mp := getg().m<br>pp := mp.p.ptr()<br><br>  <span class="hljs-comment">// 修改 gp 的状态为 _Gdead，标志它的终止</span><br>casgstatus(gp, _Grunning, _Gdead)<br>  <span class="hljs-comment">// 标记 gc 的栈内存是可以进行 gc 扫描的</span><br>gcController.addScannableStack(pp, -<span class="hljs-type">int64</span>(gp.stack.hi-gp.stack.lo))<br><span class="hljs-comment">// 如果 gp 是系统 goroutine，则将系统 goroutine 的计数减少</span><br>  <span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">-1</span>)<br>&#125;<br>  <span class="hljs-comment">// 清理 gp 的状态</span><br>gp.m = <span class="hljs-literal">nil</span><br>locked := gp.lockedm != <span class="hljs-number">0</span><br>gp.lockedm = <span class="hljs-number">0</span><br>mp.lockedg = <span class="hljs-number">0</span><br>gp.preemptStop = <span class="hljs-literal">false</span><br>gp.paniconfault = <span class="hljs-literal">false</span><br>gp._defer = <span class="hljs-literal">nil</span> <br>gp._panic = <span class="hljs-literal">nil</span><br>gp.writebuf = <span class="hljs-literal">nil</span><br>gp.waitreason = waitReasonZero<br>gp.param = <span class="hljs-literal">nil</span><br>gp.labels = <span class="hljs-literal">nil</span><br>gp.timer = <span class="hljs-literal">nil</span><br><br>  <span class="hljs-comment">// 如果启用了垃圾回收（GC）并且 gp.gcAssistBytes 大于 0，</span><br>  <span class="hljs-comment">// 则将辅助信用归还给全局池。这有助于更好地控制垃圾回收进程。</span><br><span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> &#123;<br>assistWorkPerByte := gcController.assistWorkPerByte.Load()<br>scanCredit := <span class="hljs-type">int64</span>(assistWorkPerByte * <span class="hljs-type">float64</span>(gp.gcAssistBytes))<br>gcController.bgScanCredit.Add(scanCredit)<br>gp.gcAssistBytes = <span class="hljs-number">0</span><br>&#125;<br><br>  <span class="hljs-comment">// 将当前 g 从 P 的运行队列中移除</span><br>dropg()<br><br>  <span class="hljs-comment">// WebAssembly 平台特殊处理</span><br><span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>gfput(pp, gp)<br>schedule() <br>&#125;<br><br>  <span class="hljs-comment">// 将 gp 放回处理器的可用队列中，这样可以复用 g</span><br>gfput(pp, gp)<br><br>  <span class="hljs-comment">// 如果 goroutine 被绑定到当前线程上，</span><br>  <span class="hljs-comment">// 那可能是在做系统调用，cgo 调用或其他特殊任务，</span><br>  <span class="hljs-comment">// 那么就需要切到 g0，让 g0 来完成后面的调度。</span><br>  <span class="hljs-keyword">if</span> locked &#123;<br><span class="hljs-comment">// 如果 goroutine 在终止前曾锁定当前线程，</span><br>    <span class="hljs-comment">// 则根据不同的操作系统执行不同的处理。</span><br>    <span class="hljs-comment">// 在大多数操作系统上，会跳转到 mstart 函数，释放 P 并退出线程。</span><br>    <span class="hljs-comment">// 但在 Plan 9 操作系统上，会清除 lockedExt。</span><br><span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">&quot;plan9&quot;</span> &#123; <span class="hljs-comment">// See golang.org/issue/22227.</span><br>gogo(&amp;mp.g0.sched)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mp.lockedExt = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 继续调度</span><br>  <span class="hljs-comment">// 如果执行了 gogo，那就是 g0 在调度。</span><br>  <span class="hljs-comment">// 如果没有执行 gogo，那就是 gp 在调度。</span><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就完成了对 GPM 调度循环的全过程源码分析了，你可以回到 <ahref="##4.%20调度过程%20schedule()">4. 调度过程 schedule()</a>看一下我总结的那张图，这回你应该会有更加深入的理解了。</p><h2 id="协程切换">5. 协程切换</h2><p>如果要一个协程要一直到执行完毕才退出的话，那很可能会造成其他协程饥饿的问题。所以Go其实会在一些特殊的时机对协程进行切换，这个过程有抢占式调度，也有协作式的调度。</p><p>协程切换的时候，最核心的就是要保存当前协程的现场，以方便回到该协程的时候继续执行剩下的内容。大致过程如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><p>有哪些时机会触发切换呢，这里我直接给出结论：</p><p>基于协作的抢占式调度</p><ul><li>主动挂起：<code>runtime.gopark()</code></li><li>系统调用结束时：<code>exitsyscall()</code></li><li>函数跳转时：<code>morestack()</code></li></ul><p>基于信号的抢占式调度</p><ul><li>信号调度：<code>doSigPreempt()</code></li></ul><h3 id="主动挂起-runtime.gopack">5.1 主动挂起 runtime.gopack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vq4flf5j21j20s4jto.jpg"alt="gopack 协程切换" /><figcaption aria-hidden="true">gopack 协程切换</figcaption></figure><p>这个函数位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopark</span><span class="hljs-params">(unlockf <span class="hljs-keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> reason != waitReasonSleep &#123;<br>checkTimeouts() <br>&#125;<br>mp := acquirem()<br>gp := mp.curg<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;<br>throw(<span class="hljs-string">&quot;gopark: bad g status&quot;</span>)<br>&#125;<br>mp.waitlock = lock<br>mp.waitunlockf = unlockf<br>gp.waitreason = reason<br>mp.waitTraceBlockReason = traceReason<br>mp.waitTraceSkip = traceskip<br>releasem(mp)<br>mcall(park_m)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gopark</code> 函数的主要目的是使 G进入休眠状态，等待被唤醒。</p><p>最后它调用了 <code>mcall()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mcall switches from the g to the g0 stack and invokes fn(g)</span><br><span class="hljs-comment">// mcall 切换到 g0，并执行 fn。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mcall</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(*g)</span></span>)<br></code></pre></td></tr></table></figure><p>所以这里切换回 <code>g0</code>，并执行了 <code>pack_m</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">park_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pack_m()</code> 其实就是调用了 <code>schedule()</code>去进行下一轮调度，这就完成了协程的切换。</p><p>当协程被阻塞的时候，就会去调用 <code>runtime.gopark()</code> 主动让出CPU，切回 <code>g0</code>，等待被唤醒，以此保证最大化利用 CPU资源。比如以下几种情况：</p><ul><li>休眠</li><li>channel 通道阻塞</li><li>网络 I/O 阻塞</li><li>因为执行垃圾回收而暂停</li></ul><h3 id="系统调用结束时-exitsyscall">5.2 系统调用结束时exitsyscall()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h57vx0tfayj21g60r4tb4.jpg"alt="exitsyscall 协程切换" /><figcaption aria-hidden="true">exitsyscall 协程切换</figcaption></figure><p>Go 通过 <code>entersyscall()</code> 进行系统调用，完事后会执行<code>exitsyscall()</code>，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall</span><span class="hljs-params">()</span></span> &#123;<br>...<br>mcall(exitsyscall0)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实它最终也是调用 <code>mcall()</code> 切换到 <code>g0</code>，我们不难猜出，它这里让 <code>g0</code> 去执行 <code>exitsyscall0</code>函数，做完系统调用的善后后，肯定还是会执行 <code>schedule()</code>函数进行协程调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数跳转时-morestack">5.3 函数跳转时 morestack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57w74gg19j21iq0smwgs.jpg"alt="morestack 协程切换" /><figcaption aria-hidden="true">morestack 协程切换</figcaption></figure><p>因为函数跳转意味着“压栈”，函数跳转时都会调用这个方法，它的本意在于检查当前协程栈空间是否有足够内存，如果不够就要扩大该栈空间。</p><p>为了让每个协程都有执行的机会，并且最大化利用 CPU 资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务，系统监控在一个独立的M 上运行，不用绑定逻辑处理器 P。当系统监控到协程运行超过<code>10ms</code>，就将 <code>g.stackguard0</code> 置为<code>stackPreempt</code>（该值是一个抢占标志）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> forcePreemptNS = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 10ms</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retake</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br><span class="hljs-comment">// 遍历所有的 P</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allp); i++ &#123;<br>pp := allp[i]<br>pd := &amp;pp.sysmontick<br>s := pp.status<br>sysretake := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> s == _Prunning || s == _Psyscall &#123;<br>t := <span class="hljs-type">int64</span>(pp.schedtick)<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(pd.schedtick) != t &#123;<br>pd.schedtick = <span class="hljs-type">uint32</span>(t)<br>pd.schedwhen = now<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;<br>        <span class="hljs-comment">// 如果 G 运行时间过长，超过了 forcePreemptNS(10ms)，</span><br>        <span class="hljs-comment">// 则标记抢占</span><br>preemptone(pp)<br>sysretake = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s == _Psyscall &#123;<br>      <span class="hljs-comment">// 如果是系统调用，且已经超过了一个系统监控的 tick(20us)，</span><br>      <span class="hljs-comment">// 则从系统调用中抢占 p。</span><br>      t := <span class="hljs-type">int64</span>(pp.syscalltick)<br><span class="hljs-keyword">if</span> !sysretake &amp;&amp; <span class="hljs-type">int64</span>(pd.syscalltick) != t &#123;<br>pd.syscalltick = <span class="hljs-type">uint32</span>(t)<br>pd.syscallwhen = now<br><span class="hljs-keyword">continue</span><br>&#125;<br>...<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 标记抢占</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptone</span><span class="hljs-params">(pp *p)</span></span> <span class="hljs-type">bool</span> &#123;<br>mp := pp.m.ptr()<br>gp := mp.curg<br>gp.preempt = <span class="hljs-literal">true</span><br>gp.stackguard0 = stackPreempt<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>巧的就是，Go 设计者，让程序在执行 <code>morestack()</code>函数时顺便判断一下 <code>g</code> 中的 <code>stackguard</code>是否已经被置为抢占 <code>stackPreempt</code>，如果的确被标记抢占，就回到<code>schedule()</code> 方法，并将当前协程放回队列中。</p><p><code>morestack</code> 是汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·morestack(SB),NOSPLIT|NOFRAME,$0-0<br>...<br>BLruntime·newstack(SB)<br></code></pre></td></tr></table></figure><p>它最终会调用 <code>newstack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;<br>  thisg := getg()<br>  gp := thisg.m.curg<br>  <span class="hljs-comment">// 1. 判断 gp.stackguard0 是否被标记为抢占</span><br>  stackguard0 := atomic.Loaduintptr(&amp;gp.stackguard0)<br>preempt := stackguard0 == stackPreempt<br>  <span class="hljs-comment">// 2. 如果被标记位抢占，调用 gopreempt_m()</span><br>  <span class="hljs-keyword">if</span> preempt &#123;<br><span class="hljs-comment">// 3. 最终会去调用  schedule() 去调新的协程执行</span><br>gopreempt_m(gp) <span class="hljs-comment">// never return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopreempt_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoPreempt()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号调度-dosigpreempt">5.4 信号调度 doSigPreempt()</h3><p>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</p><p>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</p><p>Go 中是注册了 <code>SIGURG</code> 信号的处理函数<code>doSigPreempt()</code>，在 GC工作时，向目标线程发送信号。线程收到信号后，会触发调度。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57wecvgwdj21hk0ssgny.jpg"alt="doSigPreempt 协程切换" /><figcaption aria-hidden="true">doSigPreempt 协程切换</figcaption></figure><p><code>doSigPreempt</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/signal_unix.go">runtime.signal_unix.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> &#123;<br><span class="hljs-comment">// 检查此 g 是否要被抢占并且安全抢占</span><br><span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &#123;<br><span class="hljs-keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;<br><span class="hljs-comment">// 2. 调整程序计数器 PC 并异步调用 asyncPreempt</span><br>ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>asyncPreempt</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt2</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>gp.asyncSafePoint = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// </span><br><span class="hljs-keyword">if</span> gp.preemptStop &#123;<br>mcall(preemptPark)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mcall(gopreempt_m)<br>&#125;<br>gp.asyncSafePoint = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>asyncPreempt</code> 是汇编实现，最终是调的<code>asyncPreempt2</code>，它会调用 <code>mcall</code> 切回<code>g0</code>，并执行 <code>preemptPark</code> 或<code>gopreempt_m</code>， <code>gopreempt_m</code> 就是前面<code>morestack</code> 最后调的！不出意外，<code>preemptPack</code>最后肯定还是调的 <code>schedule()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptPark</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime.gosched">5.5 runtime.Gosched()</h3><p>在我们实际编程中，你可以通过显式调用 <code>runtime.Gosched()</code>来主动让出 CPU，促进 Go 的下一轮调度，我们来看它的具体实现，肯定还是调的<code>schedule()</code>，没有意外！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;<br>checkTimeouts()<br>mcall(gosched_m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gosched_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoSched()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunning &#123;<br>dumpgstatus(gp)<br>throw(<span class="hljs-string">&quot;bad g status&quot;</span>)<br>&#125;<br>casgstatus(gp, _Grunning, _Grunnable)<br>dropg()<br>lock(&amp;sched.lock)<br>globrunqput(gp)<br>unlock(&amp;sched.lock)<br><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">5.6 总结</h3><p>Go 语言为了确保 P 不会因为 G运行时间过长或系统调用阻塞时间过长而导致性能下降。它会尝试进行协程切换，以确保任务可以适时地被分配和执行。这有助于保持Go程序的并发性能和响应性。而协程切换的方式有基于协作的抢占式调度（主动挂起<code>runtime.gopark()</code>，系统调用结束时<code>exitsyscall()</code>，函数跳转时<code>morestack()</code>），也有基于信号的抢占式调度<code>doSigPreempt()</code>，他们都无一例外的最终调用了<code>schedule()</code>。</p><p>所以总结下来其实还是这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><h1 id="gpm-状态流转">G、P、M 状态流转</h1><p>经过我们前面的分析，你可以自行整理 G、P、M状态的流转，这里我给出几张图供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126224853429.png"alt="Go 协程（G）状态转换图" /><figcaption aria-hidden="true">Go 协程（G）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225021035.png"alt="Go 处理器（P）状态转换图" /><figcaption aria-hidden="true">Go 处理器（P）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225849169.png"alt="Go M（操作系统线程）状态转换" /><figcaption aria-hidden="true">Go M（操作系统线程）状态转换</figcaption></figure><h1 id="总结-1">总结</h1><p>以上便是对 Go 语言 GPM 模型的全部分享啦！GPM 模型使得 Go语言能够并发执行成千上万个协程。</p><p>为了减少线程“相对昂贵”的切换代价，Go 引入了 GPM，将大量的 Goroutine分配到少量的系统线程上去执行，并利用多核并行，实现更强大的并发。</p><p>为了减小并发冲突，Go 在全局队列的基础上引入了本地队列。</p><p>为了避免协程饥饿，Go 又引入了多种协程调度的策略。</p><p>为了避免协程阻塞浪费 CPU，Go 引入了多种协程切换的方式。</p><p>Go 语言设计者进行了如此复杂的调度器实现，最终交付给 Gopher的，仅仅是一个 <code>go</code>关键字这么简单，真的是大道至简，这也是充分印证了那句话：“Go为并发而生”。</p><p>希望本文能对你有所帮助，enjoy~ happy coding~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><a href="https://coding.imooc.com/class/576.html">深入 Go底层原理</a></li><li>ChatGPT4</li></ul><h1 id="作图工具">作图工具</h1><ul><li><a href="https://excalidraw.com/">excalidraw</a></li><li><a href="https://whimsical.com/">whimsical</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨绘制曼德博集</title>
    <link href="/2024/01/17/rust-action-mandelbrot/"/>
    <url>/2024/01/17/rust-action-mandelbrot/</url>
    
    <content type="html"><![CDATA[<h1 id="曼德博集">曼德博集</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2560px-Mandelset_hires-20240118170914026.png"alt="曼德博集" /><figcaption aria-hidden="true">曼德博集</figcaption></figure><p>曼德博集其实是一个“没什么用”的发现。</p><p>曼德博集（MandelbrotSet）是一种在复平面上形成独特且复杂图案的点的集合。这个集合是以数学家本华·曼德博（BenoitMandelbrot）的名字命名的，他在研究复杂结构和混沌理论时发现了这个集合。曼德博集是分形几何的一个经典例子，显示了一个简单的数学公式如何能产生无限复杂和美丽的图案。</p><p>曼德博集的定义相对简单。对于每一个复数 <spanclass="math inline">\(c\)</span>，我们考虑以下迭代序列： <spanclass="math display">\[Z_{n+1} = z_n^2 + c \;\;\\ 其中 \;\; (z_0 = 0)\]</span> <strong>曼德博集合由那些使得上述序列不趋于无限大的复数 <spanclass="math inline">\(c\)</span>组成</strong>。在复平面上，这些点形成了一种独特的图案，通常以一种美丽且艺术的方式呈现。这个图案的边界非常复杂，包含了无限的细节和自相似的结构。这意味着无论你放大图案的哪一部分，你都会发现越来越精细的结构，这些结构在形式上与整体图案相似。</p><p>曼德博集合不仅在数学上有意义，也在艺术和科学中有广泛的应用，尤其是在研究混沌理论和复杂系统时。</p><p>具体可以看</p><ul><li><ahref="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88">维基百科-曼德博集</a></li><li><a href="https://www.bilibili.com/video/BV1kA411T7at">bilibili -2000亿倍放大曼德博集</a></li></ul><h1 id="目标功能">目标功能</h1><p>最终我们将实现一个命令行工具，它会根据我们输入的参数生成曼德博集图，使用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mandelbrot &lt;FILE&gt; &lt;PIXELS&gt; &lt;UPPERLEFT&gt; &lt;LOWERRIGHT&gt;<br></code></pre></td></tr></table></figure><ul><li><code>FILE</code>: 曼德博集图生成的图片路经。</li><li><code>PIXELS</code>: 图片分辨率，如 <code>4x3</code>。</li><li><code>UPPERLEFT</code>: 指定在复平面中图片覆盖的左上角，如<code>4.0,3.0</code>。</li><li><code>LOWERRIGHT</code>: 制定在复平面中图片覆盖的右下角。</li></ul><p>所以我们最终会根据指定的图片范围，截取 <code>PIXELS</code>分辨率大小的曼德博集图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118171322832.png"alt="截取曼德博集示意图" /><figcaption aria-hidden="true">截取曼德博集示意图</figcaption></figure><p>基于以上目标，我们拆分成几个问题：</p><ol type="1"><li>如何表示复数？</li><li>如何解析分辨率和坐标？</li><li>如何将图上像素映射到复数？</li><li>如何生成曼德博集图？即如何找到那些符合曼德博集的点，并将其进行着色标注？</li><li>如何写入图片文件？</li><li>如何渲染曼德博集？</li><li>如何解析命令行参数？</li><li>如何并发写入图片文件？</li></ol><h1 id="能学到什么">能学到什么</h1><ol type="1"><li>曼德博集是什么？</li><li>Rust 中的复数的原理与应用。</li><li>Rust 泛型初探。</li><li>Rust 中的 Option 和 Result 初探。</li><li>Rust 并发初探。</li><li>Rust 中如何解析命令行参数？</li><li>Rust 如何写入图像文件？</li><li>Rust 如何写测试用例？</li><li>Rust 实用 crate<code>num</code>、<code>image</code>、<code>crossbeam</code>。</li></ol><h1 id="版本">版本</h1><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;mandelbrot&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">image</span> = &#123;version = <span class="hljs-string">&quot;0.13.0&quot;</span>, features = [<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>]&#125;<br><span class="hljs-attr">num</span> = <span class="hljs-string">&quot;0.4.1&quot;</span><br><span class="hljs-attr">crossbeam</span> = <span class="hljs-string">&quot;0.8&quot;</span><br></code></pre></td></tr></table></figure><p>完整代码：https://github.com/hedon954/mandelbrot/blob/master/src/main.rs</p><h1 id="编码实现">编码实现</h1><h2 id="创建项目">0. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new mandelbrot<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mandelbrot<br></code></pre></td></tr></table></figure><h2 id="复数表示">1. 复数表示</h2><p>使用复数，我们需要引入一个 crete：<code>num</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add num<br></code></pre></td></tr></table></figure><p>其中定义了一个复数类型 <code>Complex</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// 复数的实部</span><br>    <span class="hljs-keyword">pub</span> re: T,<br>    <span class="hljs-comment">/// 复数的虚部</span><br>    <span class="hljs-keyword">pub</span> im: T,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>T</code> 是 Rust 中的泛型功能，表示任意类型<code>T</code>，确定好这个结构体的 <code>T</code> 的类型后，其中的属性<code>re</code> 和 <code>im</code> 的类型也就随之确定了。</p><h2 id="解析分辨率和坐标">2. 解析分辨率和坐标</h2><ul><li>分辨率格式为：4000x3000</li><li>坐标格式为：-1.0,2.0</li></ul><h3 id="解析数对">2.1 解析数对</h3><p>我们要做的就是，将分辨率拆成 (4000,3000)，将坐标拆为 (-1.0,2.0)。这里：</p><ul><li>带解析的元素 <code>s</code> 是一个字符串<code>&amp;str</code>。</li><li>分隔符 <code>separator</code> 是一个字符 <code>char</code>。</li><li>返回值是一个元组 <code>(T, T)</code>，其中 <code>T</code> 这里可以是u64/f32 等数字，它们都需要能从字符串转化而来，即<code>&lt;T:FromStr&gt;</code>。</li><li>因为解析可能出错，所以我们使用 <code>Option</code> 来承载。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 把字符串 `s`（形如 `&quot;400×600&quot;` 或 ``&quot;1.0,0.5&quot;）解析成一个坐标对</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 具体来说，`s` 应该具有&lt;left&gt;&lt;sep&gt;&lt;right&gt;的格式，其中&lt;sep&gt;是由`separator`</span><br><span class="hljs-comment">/// 参数给出的字符，而&lt;left&gt;和&lt;right&gt;是可以被 `T:from_str` 解析的字符串。</span><br><span class="hljs-comment">/// `separator` 必须是 ASCII 字符</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `s` 具有正确的格式，就返回 `Some(x,y)`，否则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pair</span>&lt;T: FromStr&gt;(s: &amp;<span class="hljs-type">str</span>, separator: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(T, T)&gt; &#123;<br>    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">find</span>(separator) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(index) =&gt; <span class="hljs-keyword">match</span> (T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[..index]), T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[index + <span class="hljs-number">1</span>..])) &#123;<br>            (<span class="hljs-title function_ invoke__">Ok</span>(l), <span class="hljs-title function_ invoke__">Ok</span>(r)) =&gt; <span class="hljs-title function_ invoke__">Some</span>((l, r)),<br>            _ =&gt; <span class="hljs-literal">None</span>,<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以写几个测试用例来验证一下这个函数的正确性，这里我们用到<code>#[test]</code> 和 <code>assert_eq!</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_pair</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;,10&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)));<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20xy&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x1.5&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">1.5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转为复数">2.2 转为复数</h3><p>我们需要的参数 <code>upper_left</code> 和 <code>lower_right</code>都是复平面中的一个点，所以从字符串中将数对解析完毕后，我们将其赋值到复数的实部和虚部，转为复数实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 把一对用逗号隔开的浮点数解析为复数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_complex</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Complex&lt;<span class="hljs-type">f64</span>&gt;&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">parse_pair</span>(s, <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((re, im)) =&gt; <span class="hljs-title function_ invoke__">Some</span>(Complex &#123; re, im &#125;),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将像素点映射成复数">3. 将像素点映射成复数</h2><p>第 2 步我们其实确定了两件事：</p><ol type="1"><li>确定截取曼德博集的哪一部分。</li><li>要在这个部分中画多少个点。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118174407537.png"alt="目标区域中的像素点" /><figcaption aria-hidden="true">目标区域中的像素点</figcaption></figure><p>这一步我们需要把 <code>x</code>点转为复数，即确定它的横坐标和纵坐标。这部分可能需要发挥一下你的几何数学能力了（🤡🤡🤡）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 给定输出图像重像素的行和列，返回复平面中对应的坐标</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `pixed` 是表示给图片中特定像素的 (column, row) 二元组。</span><br><span class="hljs-comment">/// `upper_left` 参数和 `lower_right` 参数是在复平面中表示指定图像覆盖范围的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pixed_to_point</span>(<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ·--------------------&gt; bounds.0  re</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    bounds.1  im</span><br><span class="hljs-comment">     */</span><br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    pixed: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> Complex&lt;<span class="hljs-type">f64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> (width, height) = (<br>        lower_right.re - upper_left.re, <span class="hljs-comment">// 右-左</span><br>        upper_left.im - lower_right.im, <span class="hljs-comment">// 上-下</span><br>    );<br><br>    Complex &#123;<br>        re: upper_left.re + pixed.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * width / bounds.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>        im: upper_left.im - pixed.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * height / bounds.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_pixed_to_point</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">pixed_to_point</span>(<br>            (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>),<br>            (<span class="hljs-number">25</span>, <span class="hljs-number">175</span>),<br>            Complex &#123; re: -<span class="hljs-number">1.0</span>, im: <span class="hljs-number">1.0</span> &#125;,<br>            Complex &#123; re: <span class="hljs-number">1.0</span>, im: -<span class="hljs-number">1.0</span> &#125;<br>        ),<br>        Complex &#123;<br>            re: -<span class="hljs-number">0.5</span>,<br>            im: -<span class="hljs-number">0.75</span>,<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找曼德博集点">4. 寻找曼德博集点</h2><p>什么是曼德博集点？看看上面的定义：<strong>曼德博集合由那些使得上述序列不趋于无限大的复数<span class="math inline">\(c\)</span> 组成</strong>。</p><p>现在我们可以来表示上述的公式 <span class="math inline">\(Z_{n+1} =z_n^2 + c\)</span> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">complex_square_add_loop</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        z = z * z + c<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们将泛型结构体 <code>Complex</code> 的 <code>T</code> 确定为<code>f64</code>，并使用 <code>loop</code> 关键字进行无限循环。</p><p>所以我们的目标是什么？<strong>找到令 <code>z</code>不会“飞到”无穷远的 <code>c</code></strong>。</p><p>由于复数 <span class="math inline">\(c\)</span> 具有实部 re 和虚部im，因此可以把它们视为笛卡尔平面上某个点的 x 坐标和 y 坐标，如果 <spanclass="math inline">\(c\)</span>在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上相应点位运行前面的循环，看看它是否逃逸到无穷远还是永远绕着原点运行，并相应将其着色。</p><p>无限循环肯定是不现实的，我们总要找到退出循环的机会，有 2 个思路：</p><ol type="1"><li>进行有限次数的迭代，这样可以获得该集合的一个不错的近似值，迭代的次数取决了精度的需要；</li><li>业界已证明，<strong>一旦 <code>z</code> 离开了以原点为中心的半径 2的圆，它最终一定会“飞到”无穷远</strong>。</li></ol><p>所以我们最终确定的函数如下，其中 <code>norm_sqr()</code> 会返回<code>z</code> 跟复平面原点的距离的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 尝试测试 `c` 是否位于曼德博集中，使用最多 `limit` 次迭代来判定</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `c` 不是集合成员之一，则返回 `Some(i)`，其中 `i` 是 `c` 离开以原点</span><br><span class="hljs-comment">/// 为中心的半径为 2 的圆时所需的迭代次数。如果 `c` 似乎是集群成员之一（确</span><br><span class="hljs-comment">/// 切而言是达到了迭代次数限制但仍然无法证明 `c` 不是成员），则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">escape_time</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;, limit: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..limit &#123;<br>        <span class="hljs-keyword">if</span> z.<span class="hljs-title function_ invoke__">norm_sqr</span>() &gt; <span class="hljs-number">4.0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Some</span>(i);<br>        &#125;<br>        z = z * z + c<br>    &#125;<br>    <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入图片文件">5. 写入图片文件</h2><p>我们可以使用 <code>image</code> 这个 crate来写入图片文件，它支持多种格式图片的读写，并内置了多种颜色色值。</p><p>这里我们准备生成 png图片，且需要对图片进行不同颜色的着色，所以我们引入 <code>default</code>和 <code>png</code> 这两个 feature。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add image --features default,png<br></code></pre></td></tr></table></figure><h3 id="创建文件-filecreate">5.1 创建文件 File::create()</h3><p>我们可以用标准库中的 <code>File::create(filename)</code>来创建一个文件，成功的话会返回一个文件句柄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = File::<span class="hljs-title function_ invoke__">create</span>(filename)?;<br></code></pre></td></tr></table></figure><h3 id="写入图片-pngencoder">5.2 写入图片 PNGEncoder</h3><p><code>image</code> 中提供了 <code>PNGEncoder</code> 用于写入 png图片，它有两个核心方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;W: Write&gt; PNGEncoder&lt;W&gt; &#123;<br>    <span class="hljs-comment">/// Create a new encoder that writes its output to ```w```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: W) <span class="hljs-punctuation">-&gt;</span> PNGEncoder&lt;W&gt; &#123;<br>        PNGEncoder &#123;<br>            w: w<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/// Encodes the image ```image```</span><br>    <span class="hljs-comment">/// that has dimensions ```width``` and ```height```</span><br>    <span class="hljs-comment">/// and ```ColorType``` ```c```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">self</span>, data: &amp;[<span class="hljs-type">u8</span>], width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>, color: ColorType) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">let</span> (ct, bits) = color.<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">encoder</span> = png::Encoder::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.w, width, height);<br>        encoder.<span class="hljs-title function_ invoke__">set</span>(ct).<span class="hljs-title function_ invoke__">set</span>(bits);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = <span class="hljs-built_in">try!</span>(encoder.<span class="hljs-title function_ invoke__">write_header</span>());<br>        writer.<span class="hljs-title function_ invoke__">write_image_data</span>(data).<span class="hljs-title function_ invoke__">map_err</span>(|e| e.<span class="hljs-title function_ invoke__">into</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>new(w)</code>: 传进目标 writer，即我们上面创建的<code>output</code>。</li><li><code>encode()</code>: 写入图片信息，这里有几个参数：<ul><li><code>width: u32</code>: 图片宽度。</li><li><code>height: u32</code>: 图片高度。</li><li><code>color: ColorType</code>: 颜色类型，可以是 RGB, Gray(8)等。</li><li><code>data: &amp;[u8]</code>: 像素色值列表，它的长度应该由上面 3个字段共同决定，如果选取的颜色是 RGB，意味着需要 3 个 u8才能表示一个像素点的颜色，所以长度为 width * height *3，如果选取的颜色是 Gray(8)，那么我们用 1 个 u8就可以表示一个像素点的灰度值，所以长度为 width * height *1。本文中我们会采用 Gray(8) 来汇总曼德博集的黑白图。</li></ul></li></ul><h2 id="渲染曼德博集">6. 渲染曼德博集</h2><p>这一步我们需要来确定上述 <code>PNGEncoder::encode()</code> 的 4个参数：</p><ul><li><p><code>width: u32</code>:图片宽度由命令行参数中指定即可。</p></li><li><p><code>height: u32</code>:图片高度由命令行参数中指定即可。</p></li><li><p><code>color: ColorType</code>: 本文我们只绘制黑白图，这里使用<code>ColorType::Gray(8)</code>，它表示图像是一个灰度（单色）图像，每个像素用8位（即1个字节）来表示。在这种格式中，每个像素的灰度值范围是0 到 255，其中 0 通常表示黑色，255表示白色，中间值表示不同的灰度。</p></li><li><p><code>data: &amp;[u8]</code>: 像素色值列表，我们需要确定 width *height 个像素的灰度值。</p><p>首先我们根据第 3 步将像素点映射成复数 <spanclass="math inline">\(c\)</span>，然后使用第 4 步中的<code>escape_time()</code> 函数来判断复数 <spanclass="math inline">\(c\)</span>是否位于曼德博集中，如果是，则着黑色，即赋值<code>0</code>，如果不是，则看它迭代了多少次才失败，次数越多，则越接近曼德博集，颜色越深，即越靠近0，所以赋值 <code>255-time</code>。</p></li></ul><p>最终我们实现的函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 将曼德博集对应的矩形渲染到像素缓冲区中</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `bounds` 参数会给缓冲区 `pixels` 的宽度和高度，此缓冲区的每个字节都</span><br><span class="hljs-comment">/// 包含一个灰度像素。`upper_left` 和 `lower_right` 参数分别指定了</span><br><span class="hljs-comment">/// 复平面中对应于像素缓冲区左上角和右上角的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">render</span>(<br>    pixels: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(pixels.<span class="hljs-title function_ invoke__">len</span>(), bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">raw</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">column</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (column, raw), upper_left, lower_right);<br>            pixels[raw * bounds.<span class="hljs-number">0</span> + column] = <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">escape_time</span>(point, <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(count) =&gt; <span class="hljs-number">255</span> - count <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析命令行参数">7. 解析命令行参数</h2><p>核心逻辑部分到这里其实就完成了，现在我们要做最后一步，就是解析命令行参数，让程序可以根据我们的要求绘制曼德博集图。</p><h3 id="解析-stdenvargs">7.1 解析 std::env::args()</h3><p>在 Rust中解析命令行参数的一个常用方法是使用<code>std::env::args</code>函数，这个函数返回一个迭代器，它包含了命令行上传递给程序的所有参数。对于更复杂的命令行参数解析，可以使用像<code>clap</code>或<code>structopt</code>这样的第三方库，这些库提供了更高级的功能和更好的错误处理。</p><p>下面是一个使用<code>std::env::args</code>的基本例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">arg</span> <span class="hljs-keyword">in</span> args.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础版程序">7.2 基础版程序</h3><p>到这里，我们就可以实现完整的基础版程序了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 读取参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// 参数个数 = 1 + 4，其中第 1 个是应用程序名</span><br>    <span class="hljs-keyword">if</span> args.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; FILE PIXELS UPPERLEFT LOWERRIGHT&quot;</span>, args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">eprintln!</span>(<br>            <span class="hljs-string">&quot;Example: &#123;&#125; mandel.png 1000x700 -1.20,0.35 -1,0.20&quot;</span>,<br>            args[<span class="hljs-number">0</span>]<br>        );<br>        std::process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// 解析参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bounds</span> = <span class="hljs-title function_ invoke__">parse_pair</span>(&amp;args[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing image dimensions&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">upper_left</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">3</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing upper left corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lower_right</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">4</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing lower right corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pixels</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 渲染曼德博集</span><br>    <span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br>  <span class="hljs-comment">// 输出图片</span><br>    <span class="hljs-title function_ invoke__">write_image</span>(&amp;args[<span class="hljs-number">1</span>], &amp;pixels, bounds).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error writing PNG file&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在项目根目录下编译一下程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>会在 target/release 下生成可执行文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br></code></pre></td></tr></table></figure><p>执行后你应该可以看到我们生成的曼德博集图如下：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/mandel.png"alt="程序生成的曼德博集" /><figcaption aria-hidden="true">程序生成的曼德博集</figcaption></figure><p>大概是处于这个位置：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118191624303.png"alt="程序截取的局部曼德博集处于整个曼德博集中的位置" /><figcaptionaria-hidden="true">程序截取的局部曼德博集处于整个曼德博集中的位置</figcaption></figure><h2 id="并发渲染">8. 并发渲染</h2><p>在 macOS 或 linux 系统下，我们可以使用 <code>time</code>来输出程序的执行时间：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.30s user 0.01s system 98% cpu 3.341 total<br></code></pre></td></tr></table></figure><p>笔者使用的电脑为 macbook Pro m2 max 芯片 32 G 内存 12核，可以看到在单核模式下，差不多需要 3~4s 的时间。</p><p>几乎所有的现代机器都有多个处理器核心，而当前这个程序只使用了一个。如果可以把此工作分派个机器提供的多个处理器核心，则应该可以更快地画完图像。</p><p>为此，我们可以将图像划分成多个部分，每个处理器负责其中的一个部分，并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/CleanShot%202024-01-18%20at%2021.28.20.jpg"alt="将像素缓冲区划分为一些条带以进行并发渲染" /><figcaptionaria-hidden="true">将像素缓冲区划分为一些条带以进行并发渲染</figcaption></figure><p>crossbeam 是 Rust中的一个并发编程工具箱，它广泛用于提供各种并发和多线程编程的组件。</p><p><code>crossbeam::scope</code> 是 crossbeam提供的一个非常有用的功能，它允许你安全地创建临时的线程，并确保这些线程在离开作用域之前结束。</p><p>这里我们引入 crossbeam：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add crossbeam<br></code></pre></td></tr></table></figure><p>我们将 <code>fn main()</code> 中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br></code></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 8 个线程来并发执行</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">threads</span> = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 计算每个线程负责渲染的高度，向上取整</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">rows_per_band</span> = bounds.<span class="hljs-number">1</span> / threads + <span class="hljs-number">1</span>;<br>&#123;<br>  <span class="hljs-comment">// chunks_mut() 会返回一个迭代器，该迭代器会生成此缓冲区的可变且不可迭代的切片</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(rows_per_band * bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// crossbeam::scope 确保所有子线程在作用域结束之前完成，</span><br>  <span class="hljs-comment">// 这防止了悬垂指针和其他数据竞争问题。</span><br>    crossbeam::<span class="hljs-title function_ invoke__">scope</span>(|spawner| &#123;<br>      <span class="hljs-comment">// 遍历像素缓冲区的各个条带，</span><br>      <span class="hljs-comment">// 这里 into_iter() 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，</span><br>      <span class="hljs-comment">// 确保一次只有一个线程可以写入它。</span><br>        <span class="hljs-keyword">for</span> (i, band) <span class="hljs-keyword">in</span> bands.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 确定每个条带的参数</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = rows_per_band * i;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">height</span> = band.<span class="hljs-title function_ invoke__">len</span>() / bounds.<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, height);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> =<br>                <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + height), upper_left, lower_right);<br>          <span class="hljs-comment">// 创建一个线程，渲染图像</span><br>          <span class="hljs-comment">// move 表示这个闭包会接手它所用遍历的所有权，</span><br>          <span class="hljs-comment">// 所以只有此闭关，即只有此线程可以使用可变切片 band。</span><br>            spawner.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> |_| &#123;<br>                <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">time ./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span><br>./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span>  <span class="hljs-number">3.57</span>s user <span class="hljs-number">0.01</span>s system <span class="hljs-number">335</span>% cpu <span class="hljs-number">1.067</span> total<br></code></pre></td></tr></table></figure><p>可以看到虽然总共使用的 CPU 时间还是3~4s，但是整个程序的执行时间只缩短到 1s 左右了。</p><p>以上就是实用 Rust 绘制曼德博集实战的全部内容，enjoy，happycoding~</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust Web 框架 Axum 指南</title>
    <link href="/2024/01/14/rust-axum/"/>
    <url>/2024/01/14/rust-axum/</url>
    
    <content type="html"><![CDATA[<h1 id="结论先行">结论先行</h1><h1 id="hello-world">Hello World</h1><p>先来看看 Axum 的 Hello World：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> axum::Router;<br><span class="hljs-keyword">use</span> axum::routing::get;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个应用，带一个 / 路由，输出 Hello World</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br><br>    <span class="hljs-comment">// 监听 3000 端口</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = tokio::net::TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:3000&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 启动服务</span><br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这个例子，可以得到的第一个信息就是：<code>Axum</code> 是<code>tokic</code> 生态下的一员。</p><blockquote><p>本文默认读者对 <code>tokio</code> 具有基本的了解。</p></blockquote><p>所以这里我们需要引入两个组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tokio --features macros,rt-multi-thread<br>cargo add axum<br></code></pre></td></tr></table></figure><p>这个例子我们定义了一个路由，下面我们就先从 Axum 的路由开始介绍。</p><h1 id="routing-路由">Routing 路由</h1><h2 id="单个路由">单个路由</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br></code></pre></td></tr></table></figure><p>实际上它等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_hello_world));<br> ...<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handler_hello_world</span> () <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">IntoResponse</span> &#123;<br>    <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>路由注册部分为为 <code>path</code>、<code>method</code> 和<code>handler</code> 三个部分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240114141604009.png"alt="路由注册部分" /><figcaption aria-hidden="true">路由注册部分</figcaption></figure><p>其中 <code>get</code> 可以替换为<code>post</code>、<code>patch</code>、<code>delete</code>、<code>head</code>和 <code>options</code> 等 http method。</p><p>其中 <code>handler</code>的返回值需要满足：<code>impl IntoResponse</code>，常用的<code>字符串</code>、<code>json</code> 和 <code>html</code> 都已经实现了<code>IntoResponse</code>，所以都是可以直接返回的。</p><h2 id="路由分组">路由分组</h2><p>你可以使用 <code>merge()</code> 和 <code>nest()</code>来进行路由分组，其中 <code>nest()</code> 可以指定统一路由前缀：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">merge</span>(<span class="hljs-title function_ invoke__">todo_routers</span>())<br>        .<span class="hljs-title function_ invoke__">nest</span>(<span class="hljs-string">&quot;/v2/todo&quot;</span>, <span class="hljs-title function_ invoke__">todo_routers_v2</span>());<br>...<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers_v2</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态路由">静态路由</h2><p>可以使用同 <code>tokio</code> 生态下的 <code>tower-http</code>来实现静态路由：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">nest_service</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get_service</span>(ServeDir::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;./&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里你需要添加 <code>tower-http</code> 组件，至少需要载入<code>fs</code> 特性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tower-http --features fs<br></code></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://docs.rs/axum/latest/axum/">Rust-Axum</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>web 框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Axum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文彻底掌握浮点数</title>
    <link href="/2023/12/23/floating-point-number/"/>
    <url>/2023/12/23/floating-point-number/</url>
    
    <content type="html"><![CDATA[<h2 id="经典问题">经典问题</h2><p>0.1 + 0.2 = ？</p><p>我们写个 Go 程序来测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float64</span> = <span class="hljs-number">0.1</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float64</span> = <span class="hljs-number">0.2</span><br>fmt.Println(f1+f2 == <span class="hljs-number">0.3</span>)<br>fmt.Println(f1 + f2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span><br>0.30000000000000004<br></code></pre></td></tr></table></figure><p>如此违背 “常识”的结果，其实是因为当下计算机体系中小数的表示方式是浮点数，而计算机中对浮点数的表示并非百分百精确的，在表示和计算过程中都有可能会丢失精度。</p><p>这迫使必须深入理解浮点数在计算机中的存储方式及性质，才能正确处理关于数字的计算问题。</p><h2 id="结论先行">结论先行</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/IEEE-754%20%E6%B5%AE%E7%82%B9%E6%95%B0.jpg"alt="IEEE-754 浮点数" /><figcaption aria-hidden="true">IEEE-754 浮点数</figcaption></figure><h2 id="定点数">定点数</h2><p>要理解浮点数的第一步是考虑含有小数值的二进制数字。在这之前，我们来看看更加熟悉的十进制表示法：<span class="math display">\[d_md_{m-1} ··· d_1d_0 . d_{-1}d_{-2}··· d_{-n}\]</span> 小数点 <code>.</code>左边是整数部分，右边是小数部分。其中每个十进制数 <code>di</code>的取值范围是 0~9。</p><p>如十进制的 <code>12.34</code> 即可以表示为： <spanclass="math display">\[1×10^1+2×10^0+3×10^{-1}+4×10^{-2}\]</span> 那其实二进制也是一样的道理，只不过把其中的 <code>10</code>换成 <code>2</code>，而 <code>di</code> 的取值范围为 0~1。</p><p>如二进制的 <code>101.11</code> 可以表示为： <spanclass="math display">\[1×2^2+0×2^1+1×2^0+1×2^{-1}+1×2^{-2}\]</span> 如果我们仅考虑有限长度的编码，那么十进制表示法不能准确表达像1/3 和 5/7这样的数。类似的，小数的二进制表示法只能表示那些能够被写成以下形式的数：<span class="math display">\[x × 2^y\]</span> 其他的值就只能近似地表示。</p><p>定点数的整数部分是小数部分的位数是固定不变的，在位数有限的情况下，定点数的取值范围和精度都比较差。于是就有了IEEE-754 提出的浮点数表示法。</p><h2 id="浮点数">浮点数</h2><p>所谓“浮点数”（Floating-pointnumbers），即小数点可以“<strong>浮动</strong>”，即小数点的位置不是固定的，而是可以根据数值的大小和精度需求移动的。这种表示法允许在广泛的范围内表示数值，同时保持相对恒定的精度。</p><p>在计算机中，浮点数通常遵循 IEEE-754标准。这个标准定义了浮点数的存储和运算方式，确保了不同计算机系统之间的一致性。IEEE-754用以下形式来表示一个数： <span class="math display">\[V = (-1)^s×M×2^E\]</span> 其中：</p><ul><li><strong>s 符号位（Sign bit）</strong>：表示数值的正负。</li><li><strong>M 尾数（Mantissa）</strong>：表示数值的有效数字。</li><li><strong>E 指数（Exponent）</strong>：决定小数点的位置。</li></ul><p>IEEE-754将浮点数的位表示划分成三个部分，分别对各个部分进行编码，对应上面公式右边的3 个字母：</p><ul><li>一个单独的符号位 <code>s</code> 直接编码符号 <code>s</code>。</li><li><span class="math inline">\(k\)</span> 位的阶码字段 <spanclass="math inline">\(exp=e_{k-1}\cdots e_1e_0\)</span> 编码阶码<code>E</code>。</li><li><span class="math inline">\(n\)</span> 位小数字段 <spanclass="math inline">\(frac=f_{n-1}\cdots f_1f_0\)</span> 编码尾数<code>M</code>，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li></ul><p>在 IEEE-754 标准中，定义了两种精度的浮点数，分别是单精度浮点数（32位）和双精度浮点数（64 位）。</p><p>单精度：</p><ul><li>1 位符号位 s</li><li>8 位指数 exp</li><li>23 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>双精度：</p><ul><li>1 位符号位 s</li><li>11 位指数 exp</li><li>52 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102756244.png"alt="双精度浮点数" /><figcaption aria-hidden="true">双精度浮点数</figcaption></figure><p>根据 <code>exp</code> 的值，浮点数又可以分成三类：</p><ol type="1"><li>规格化的</li><li>非规格化的</li><li>特殊的</li></ol><p>其中第三类“特殊的”又可以根据 <code>frac</code> 分成两类：</p><ol type="1"><li>无穷大</li><li>不是一个数 NaN（Not a Number）</li></ol><p>具体如下表所示：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">exp</th><th style="text-align: center;">frac</th></tr></thead><tbody><tr class="odd"><td>规格化的</td><td style="text-align: center;">≠0 &amp; ≠ 255</td><td style="text-align: center;">f</td></tr><tr class="even"><td>非规格化的</td><td style="text-align: center;">0</td><td style="text-align: center;">f</td></tr><tr class="odd"><td>特殊的</td><td style="text-align: center;">1</td><td style="text-align: center;">f</td></tr><tr class="even"><td>- 无穷大</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr class="odd"><td>- NaN</td><td style="text-align: center;">1</td><td style="text-align: center;">≠0</td></tr></tbody></table><p>对于不同类型的浮点数，在计算公式 <spanclass="math inline">\(V=(-1)^s×M×2^E\)</span>中，<code>exp -&gt; E</code> 和 <code>frac -&gt; M</code>的方式有所不同。</p><p>下面我们来对这几种不同类型进行详细讨论，其中不乏有一些很有趣且充满智慧的设计理念。</p><h3 id="特殊值-special-values">特殊值 Special Values</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：全为 0 则表示无穷大，不全为 0 则表示NaN。</li><li><strong>作用</strong>：特殊值用于表示那些无法用常规数值表示的情况，如无穷大、非数（NaN）等。这些值通常用于操作的错误或特殊情况的结果，如除以0、无效操作等。</li></ul><h3 id="规格化的值-normalize-values">规格化的值 Normalize Values</h3><ul><li><strong>指数部分</strong>：不全为 0 且不全为 1。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：用于表示大多数非零数值</li></ul><p>在规格化值中：</p><ul><li><span class="math inline">\(E=e-bias\)</span></li><li><span class="math inline">\(M=1+f\)</span></li></ul><p>其中 <code>e</code> 即为 <code>exp</code>，，<code>bias</code>是偏置量，它的值为 <span class="math inline">\(2^{k-1} -1\)</span>，其中<code>k</code> 为 <code>exp</code> 的位数，故：</p><ul><li>在单精度中，<spanclass="math inline">\(bias=2^{8-1}-1=2^7-1=128-1=127\)</span></li><li>在双精度中，<spanclass="math inline">\(bias=2^{11-1}-1=2^{10}-1=1024-1=1023\)</span></li></ul><p>其中 <code>f</code> 为 <code>frac</code> 表示的数，范围 <spanclass="math inline">\(0≤f&lt;1\)</span>。</p><p>所以一个规格化数，具体可以表示为： <span class="math display">\[V=(-1)^{sign}×1.frac×2^{(exp-bias)}\]</span> 这里有 4个问题：</p><ol type="1"><li>这个 <code>bias</code> 是什么？</li><li>为什么 <code>E</code> 要 <code>e</code> 去减掉一个<code>bias</code>？</li><li><code>bias</code> 的值是怎么定下的，如单精度为什么是 127，不是 126或 128？</li><li><code>M</code> 为什么需要 <code>f</code> 去加上一个<code>1</code>？</li></ol><p>下面我们来对这 4 个问题进行一一解答。</p><p><strong>第 1 个问题，这个 bias 是什么？</strong></p><blockquote><p><code>bias</code>是一个预设的偏移量，用于将指数部分的值偏移到全正数，从而简化处理。</p></blockquote><p><strong>第 2 个问题：为什么 E 要 e 去减去一个 bias？</strong></p><blockquote><p>先说结论：使用 bias（偏置指数，biasedexponent）可以允许浮点数以统一的方式表示，同时也使得浮点数的排序和比较变得简单。</p></blockquote><p>首先指数肯定得支持正负形式的出现，那么直接使用无符号整型来表示指数肯定是不行的，因为它无法表示负指数。暂时先抛开IEEE-754 定下的标准，我们可以尝试用补码来表示指数。</p><p>假设我们有两个 32 位的浮点数 <code>A</code> 和<code>B</code>，并且我们假设它们的指数部分使用 8 位二进制补码表示（这与IEEE-754 标准不同）。</p><ul><li><code>A</code>的二进制表示：<code>0 0000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示：<code>0 1111110 00000000000000000000000</code></li></ul><p>在这里，第一位是符号位（0 表示正数），接下来的 8位是以补码形式表示的指数，剩下的 23 位是尾数。</p><p>我们想要比较这两个数的大小，需要怎么做呢？</p><p>我们先解析这 2 个数：</p><ul><li>符号位：对于 <code>A</code> 和<code>B</code>，符号位都是0，表示这是两个正数。</li><li>指数部分（使用补码表示）<ul><li><code>A</code> 的指数为 <code>0000010</code>，解读为正数 +2。</li><li><code>B</code> 的指数为<code>1111110</code>，在补码表示中，这是一个负数。先加 1后取反转换为正数 <code>00000010</code>，它表示 -2。</li></ul></li></ul><p>要比较这 2 个数：</p><ul><li>当我们比较 <code>A</code> 和 <code>B</code>时，首先需要考虑它们的指数。</li><li>指数 <code>A</code> 为 +2，而 <code>B</code> 为-2。即使它们的尾数部分相同（在这个例子中都是0），<code>A</code>的实际值要大于<code>B</code>，因为正指数表示的数值范围远大于负指数。</li></ul><p>可以看出：使用补码表示指数增加了比较过程的复杂性，因为我们需要解读补码并考虑其正负。特别是在涉及到负指数的情况下，我们不能仅仅比较二进制表示的大小，而必须将补码转换为实际的数值，然后再进行比较。</p><p>现在回过头来看看 IEEE-754 的设计，假设我们有两个单精度（32位）浮点数<code>A</code> 和 <code>B</code>：</p><ul><li><code>A</code>的二进制表示为：<code>0 10000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示为：<code>0 01111110 00000000000000000000000</code></li></ul><p>解析这两个数：</p><ul><li><code>A</code>：符号位为 0（正数），指数部分为<code>10000010</code>（二进制，对应十进制的 130），尾数部分为全 0。</li><li><code>B</code>：符号位为 0（正数），指数部分为<code>01111110</code>（二进制，对应十进制的 126），尾数部分为全 0。</li></ul><p>计算实际指数值：单精度浮点数的偏置值 <code>bias</code> 为127，故：</p><ul><li><code>A</code> 的实际指数 <code>E = 130 - 127 = 3</code>。</li><li><code>B</code> 的实际指数 <code>E = 126 - 127 = -1</code>。</li></ul><p>比较这两个数：</p><ul><li>在减去 <code>bias</code>后，我们可以直接比较指数部分的二进制表示来确定数值的大小。</li><li>由于 <code>10000010</code>（130）大于<code>01111110</code>（126），因此我们可以直接得出 <code>A</code> 大于<code>B</code>，而无需考虑负指数的复杂表示问题。</li></ul><p>这个例子说明了通过减去偏置值，IEEE-754标准能够简化浮点数的比较和排序操作。偏置后的指数表示方法允许计算机以统一和高效的方式处理浮点数，无论它们的实际数值大小如何。</p><p><strong>第 3 个问题：bias 的值是怎么定下的，如单精度为什么是127，而不是 126 或 128？</strong></p><blockquote><p><code>bias</code>值的选择，是为了平衡正负指数的表示范围，并且充分利用指数部分的存储空间。</p></blockquote><p>以单精度为例，<code>exp</code> 占了 8 位，8位二进制可以表示的值的范围是 <spanclass="math inline">\([0,255]\)</span>。如果我们选择 127 作为<code>bias</code>，则存储的指数范围就是 <spanclass="math inline">\([-127,128]\)</span>。这样可以使得指数部分可以均匀地表示从负大数到正大数的范围（对称）。</p><p>在 IEEE-754 标准中，全 0 的指数表示为非规格化数或 0，而全 1的指数用于表示无穷大或 NaN）。选择 127 作为 <code>bias</code>可以在保留这些特殊值的同时，提供最大的有效指数范围。</p><p><strong>第 4 个问题：M 为什么需要 f 去加上一个 1？</strong></p><blockquote><p>在规格化数中隐含最高位 1是为了提高尾数部分的表示效率，从而增加精度。</p></blockquote><p>其实这跟科学计数法的很像的，为了确保浮点数表示的<strong>唯一性</strong>，IEEE-754规定规格化浮点数最高位一定是非零的。如果不规定最高位非零，同一个数可以有多种不同的浮点表示，例如，在二进制中<code>0.5</code> 可以表示为 <spanclass="math inline">\(1.0×2^{-1}\)</span>，也可以表示位 <spanclass="math inline">\(0.1×2^0\)</span> 或 <spanclass="math inline">\(0.01×2^1\)</span>等等。这种多重表示会使浮点运算变得复杂且低效。</p><p>那既然最高位总是 1，那就没必要显示存储了，还可以使尾数部分中多 1位的存储空间，从而允许存储更多的有效数字，以<strong>提高精度</strong>。</p><h3 id="非规格化的值-denormalized-values">非规格化的值 DenormalizedValues</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：<ul><li>提供表示数值 0 的方法。因为规格化中 <spanclass="math inline">\(M≥1\)</span>，所以无法表示 0。</li><li>用于表示非常接近于 0的数值，这些数值太小，无法用规格化格式表示。它们填补了 0和最小规格化正数之间的间隙，提供了渐近于0的连续表示，防止了所谓的“下溢”。</li></ul></li></ul><p>在非规格化值中：</p><ul><li><span class="math inline">\(E=1-bias\)</span></li><li><span class="math inline">\(M=f\)</span></li></ul><p>所以一个规格化数，具体可以表示为： <span class="math display">\[V=(-1)^{sign}×0.frac×2^{(1-bias)}\]</span> 那这里又有 2 个问题了：</p><ol type="1"><li>为什么指数部分不是 <span class="math inline">\(0-bias\)</span> 而是<span class="math inline">\(1-bias\)</span>？</li><li>为什么 M 不需要隐含的 1 了？</li></ol><p><strong>第 1 个问题：为什么指数部分不是 0-bias 而是1-bias？</strong></p><blockquote><p>这是一个特殊的设计，旨在使非规格化数能够平滑地连接到规格化数的最小正值。</p></blockquote><p>最小的规格化数的指数为<code>1 - bias</code>。为了在数值上平滑地过渡到非规格化数，非规格化数的实际指数也被设定为<code>1 - bias</code>。这样，非规格化数就可以代表那些小于最小规格化正数的数值，而不会出现一个数值的“间隙”。</p><p><strong>第 2 个问题：为什么 M 不需要隐含的 1 了？</strong></p><blockquote><p>不包含隐含的 1 使得非规格化数能够在浮点数表示中填补 0和最小规格化数之间的空隙，提供对极小数值的连续表示。</p></blockquote><ul><li><strong>避免下溢</strong>：非规格化数通过允许尾数部分不以隐含的 1开始（而是以显式的 0开始），使得它们可以表示比最小规格化数还要小的数值。这对于避免数值下溢至0 非常重要，尤其是在累积了多次运算后的场合。</li><li><strong>精度牺牲</strong>：使用非规格化数的代价是牺牲了一些精度。由于没有隐含的最高位1，非规格化数的精度较低。但这是为了在非常小的数值范围内提供数值的连续性所做的必要妥协。</li></ul><h3 id="总结">总结</h3><p>规格化值、非规格化值和特殊值三种类型共同构成了 IEEE-754浮点数标准的完整表示体系，使得浮点数能够在计算机中有效低处理从非常小到非常大的数值范围，同时还能应对特殊的计算情况。</p><h3 id="举例">举例</h3><p>参考《深入理解计算机系统》，我们以 8 位浮点数为例，其中：</p><ul><li>1 位符号 s</li><li>4 位指数 exp</li><li>3 位尾数 frac</li></ul><p>可以算出 <spanclass="math inline">\(bias=2^{4-1}-1=2^3-1=8-1=7\)</span>。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/544558-20211104211145834-189368139.png"alt="8 位浮点数（≥0部分）" /><figcaption aria-hidden="true">8 位浮点数（≥0部分）</figcaption></figure><p>其中靠近 0 的是非规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130157112.png"alt="8 位浮点数 - 非规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 非规格化值</figcaption></figure><p>以 <code>0 0000 001</code> 为例： <span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×0.frac×2^{1-bias} \\= (-1)^0×(0+(1/8))×2^{1-7} \\= 1×1/8×2^{-6} \\=2^{(-9)} \\= 1/512\]</span></p><p>再往下，就是规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130849986.png"alt="8 位浮点数 - 规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 规格化值</figcaption></figure><p>以 <code>0 0110 110</code> 为例： <span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= (-1)^0×(1+6/8)×2^{6-7} \\=1×14/8×2^{-1} \\= 14/16 \\=7/8\]</span></p><h2 id="整型转为浮点型">整型转为浮点型</h2><p>下面以一个例子来直观感受一下一个整型是如何转为浮点型的。</p><p>现在我们有一个 int32 的整型<code>123</code>，我们希望将其转为单精度浮点型 <code>123.0</code>。</p><p><strong>1. 将整型用二进制表示出来</strong> <spanclass="math display">\[12345_{(10)} = 1111011_{(2)}\]</span> <strong>2. 规范化表示</strong> <span class="math display">\[1111011= 1.111011×2^6\]</span> <strong>3. 计算指数</strong> <span class="math display">\[exp = 6 + 127 = 133_{(10)} = 10000101_{(2)}\]</span> <strong>4. 确定尾数</strong>**</p><p>这是个规范化值，所以 <code>1.frac</code> 的 <code>1</code>省略，又因为单精度浮点数 <code>frac</code> 占 23 位，所以我们需要在<code>111011</code> 后面再填 17 个 0，即： <span class="math display">\[frac = 111011 0000 0000 0000 0000 0\]</span> <strong>5. 确定符号位</strong> <span class="math display">\[s = 0_{(2)}\]</span> <strong>6. 组合起来</strong></p><p><code>12345.0</code> =<code>0  10000101 11101100000000000000000</code></p><h2 id="浮点数舍入">浮点数舍入</h2><p>由于浮点数的表示具有固定的精度，在进行运算或表示时，经常会遇到无法精确表示的数值，这就需要采用舍入方法来近似表示这些数值。IEEE-754标准定义了几种不同的舍入模式，以适应不同的计算需求。</p><h3 id="舍入模式">舍入模式</h3><p><strong>最近舍入（Round to Nearest）</strong>:</p><ul><li>这是最常用的舍入模式，也是默认的模式。</li><li>规则是向最接近的可表示值舍入。如果精确结果位于两个可表示值的中点，通常舍入到最近的偶数（即尾数的最后一位为0）。</li><li>这种方法减少了累积误差，确保了在多次运算后的总体精度。</li></ul><p><strong>向零舍入（Round Toward Zero）</strong>:</p><ul><li>这种模式总是舍入到零的方向，即舍去小数部分。</li><li>对于正数，这相当于取下限，对于负数，相当于取上限。</li></ul><p><strong>向上舍入（Round Up）</strong>:</p><ul><li>无论正负，都向远离零的方向舍入。</li><li>对于正数，舍入后的值不小于原值；对于负数，舍入后的值不大于原值。</li></ul><p><strong>向下舍入（Round Down）</strong>:</p><ul><li>无论正负，都向接近零的方向舍入。</li><li>对于正数，舍入后的值不大于原值；对于负数，舍入后的值不小于原值。</li></ul><h3 id="舍入的影响">舍入的影响</h3><ul><li><strong>精度损失</strong>：由于固定的尾数位数，舍入可能导致精度的损失。</li><li><strong>舍入误差</strong>：舍入操作本身可能引入误差，这些误差在连续运算中可能会累积。</li><li><strong>选择合适的舍入模式</strong>：不同的舍入模式适合不同的应用场景。例如，金融计算可能更倾向于使用向零舍入，而科学计算通常使用最近舍入以减少累积误差。</li></ul><h3 id="实例">实例</h3><table><thead><tr class="header"><th>Mode</th><th style="text-align: center;">1.40</th><th style="text-align: center;">1.60</th><th style="text-align: center;">1.50</th><th style="text-align: center;">2.50</th><th style="text-align: center;">-1.50</th></tr></thead><tbody><tr class="odd"><td>最近舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr><tr class="even"><td>向零舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-1</td></tr><tr class="odd"><td>向上舍入</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">-1</td></tr><tr class="even"><td>向下舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr></tbody></table><h2 id="浮点数运算">浮点数运算</h2><p>因为浮点数本身就存在精度问题，所以浮点数运算在计算机中是一个近似过程，涉及到精确度的权衡、特殊值的处理、错误的传播，以及舍入规则的应用。</p><h3 id="浮点数加减">浮点数加减</h3><ol type="1"><li>浮点数加法和减法首先需要对操作数进行对齐，使得它们的指数相同。这可能涉及将尾数的二进制表示向右移位，可能导致精度损失。</li><li>然后执行加法或减法操作。</li><li>对结果进行规范化和舍入。</li></ol><p>注意，浮点数的加减法<strong>不满足</strong>结合律、交换律和分配律，这你简单分析下应该就可以理解了，这里不赘述了。</p><p>假设我们要在单精度浮点数格式下计算： <span class="math display">\[12.375 + 0.1 = ?\]</span> <strong>第 1 步：转为二进制表示</strong></p><p>其中 12.375 我们可以用二进制精确表示： <span class="math display">\[12.375_{(10)} = 1100.011_{(2)}\]</span> 而 0.1 就比较特殊了，用二进制表示的话它会无限循环。</p><blockquote><p>将十进制小数转换为二进制表示涉及到重复乘以 2的过程，并提取每次乘法后整数部分作为二进制位。这个过程是一个不断重复的过程，直到小数部分变为0 或开始循环。</p></blockquote><ol type="1"><li><p>取 <code>0.1</code> 的小数部分乘以 2（即<code>0.1 × 2 = 0.2</code>），整数部分是 <code>0</code>，小数部分是<code>0.2</code>。</p></li><li><p>再次取小数部分乘以 2（即 <code>0.2 × 2 = 0.4</code>），整数部分是<code>0</code>，小数部分是 <code>0.4</code>。</p></li><li><p>继续这个过程，我们得到以下序列：</p><p><code>0.4 × 2 = 0.8</code> → 整数部分 <code>0</code></p><p><code>0.8 × 2 = 1.6</code> → 整数部分 <code>1</code></p><p><code>0.6 × 2 = 1.2</code> → 整数部分 <code>1</code></p><p><code>0.2 × 2 = 0.4</code> → 整数部分 <code>0</code></p><p>…（循环开始）</p></li></ol><p>所以，<code>0.1</code> 的二进制表示开始为<code>0.0001100110011…</code>，并且这个模式会无限循环下去。</p><p><strong>第 2 步：规格化</strong></p><p>回顾一下这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>所以 12.375 规格化表示为：</p><ul><li>先规范化为 1.xxxx 形式： <span class="math inline">\(1100.011_{(2)}= 1.100011 × 2^3\)</span></li><li>指数为：<span class="math inline">\(3 + 127 = 130 =10000010_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10001100000000000000000（23\;位，右边补\;0）\)</span></li><li>汇总：<spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li></ul><p>而 0.1 由于无限循环，我们在单精度下只能保留 23位，并采用<strong>最近舍入</strong>，所以 0.1 规格化表示为：</p><ul><li>先规范为 1.xxxx 形式：<spanclass="math inline">\(0.00011001100110011001100(循环) =1.10011001100110011001100 × 2^-4\)</span></li><li>指数为：<span class="math inline">\(-4 + 127 = 123 =01111011_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10011001100110011001100\)</span></li><li>汇总：<spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p><strong>第 3 步：对齐指数</strong></p><p>先把 2 个浮点表示放在一起，好对比：</p><ul><li><spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li><li><spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p>将两个数的指数对齐，较小的指数增加，同时相应地调整尾数。</p><p>这里需要调整将 <code>0.1</code> 的指数从 <code>01111011</code> 调整到<code>10000010</code>，这里加了 <code>7</code>，所以 <code>0.1</code>的尾数 <code>1.10011001100110011001100</code>需要右移 <code>7</code>位，即：<code>0.00000011001100110011001</code>。</p><p><strong>第 4 步：相加</strong></p><p>现在两个数的指数相同了，我们可以直接把它们的尾数相加： <spanclass="math display">\[\;\;\;1.10001100000000000000000 \\+\;0.00000011001100110011001 \\=\;1.10001111001100110011001\]</span> <strong>第 5 步：规范化结果</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里没有进位，不需要舍入。</p><p><strong>第 7 步：浮点化表示</strong> <span class="math display">\[0\;10000010\;10001111001100110011001\]</span> <strong>第 8 步：转为十进制</strong> <spanclass="math display">\[V =(-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= 1.10001111001100110011001 × 2^3 \\= 1100.01111001100110011001_{(2)} \\= 12.47499942779541015625_{(10)} \\≈ 12.475_{(10)}\]</span></p><h3 id="浮点数乘法">浮点数乘法</h3><ol type="1"><li><strong>符号位计算</strong>：结果的符号由两个操作数的符号位决定。如果符号位相同（都是正数或都是负数），结果为正；如果符号位不同，结果为负。</li><li><strong>指数相加</strong>：两个数的指数相加，并减去偏置值（单精度浮点数中为127，双精度为1023）。</li><li><strong>尾数相乘</strong>：两个数的尾数相乘。这里的尾数包括隐含的最高位1。</li><li><strong>结果规范化</strong>：如果乘法的结果需要规范化（即调整为<code>1.xxxx</code> 的形式），则相应调整指数。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入以适应目标格式。</li><li><strong>检查溢出或下溢</strong>：如果指数超出了表示范围，则发生溢出（结果可能为无穷大或特殊值）；如果指数太小，发生下溢（结果可能为0 或非规格化数）。</li></ol><p>假设我们要在单精度浮点数格式下计算： <span class="math display">\[2.0 × 3.0 = ?\]</span> <strong>第 1 步：转为二进制表示</strong> <spanclass="math display">\[2.0_{(10)} = 1_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span> <strong>第 2 步：规范化</strong> <span class="math display">\[1 = 1.0 × 2^0 \\11 = 1.1 × 2^1\]</span> <strong>第 3 步：浮点化</strong> <span class="math display">\[2.0 = 0\;00000001\;00000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span> <strong>第 4 步：乘法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数相加并减去偏置值：<spanclass="math inline">\((127+1)+(127+1)-127=129\)</span></li><li>尾数相乘：<span class="math inline">\(1.0_{(2)}×1.1_{(2)} =1.1_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong> <span class="math display">\[0\;00000010\;10000000000000000000000\]</span> <strong>第 8 步：转为十进制</strong> <spanclass="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.1 × 2^2 \\= 110_{(2)} \\= 6.0_{(10)}\]</span></p><h3 id="浮点数除法">浮点数除法</h3><p>浮点数除法类似于乘法，但有一些不同：</p><ol type="1"><li><strong>符号位计算</strong>：与乘法类似，结果的符号由两个操作数的符号位决定。</li><li><strong>指数相减</strong>：被除数的指数减去除数的指数，再加上偏置值。</li><li><strong>尾数相除</strong>：被除数的尾数除以除数的尾数。</li><li><strong>结果规范化</strong>：如果必要，调整结果使其规范化。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入。</li><li><strong>检查溢出或下溢</strong>：与乘法类似的检查。</li></ol><p>假设我们要在单精度浮点数格式下计算： <span class="math display">\[6.0 ÷ 3.0 =?\]</span> <strong>第 1 步：转为二进制表示</strong> <spanclass="math display">\[6.0_{(10)} = 110_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span> <strong>第 2 步：规范化</strong> <span class="math display">\[6.0 = 110 = 1.10 × 2^2 \\3.0 = 11 = 1.1 × 2^1\]</span> <strong>第 3 步：浮点化</strong> <span class="math display">\[6.0 = 0\;00000020\;10000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span> <strong>第 4 步：除法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数减并加上偏置值：<spanclass="math inline">\((127+2)-(127+1)+127=128\)</span></li><li>尾数相除：<span class="math inline">\(1.1_{(2)}×1.1_{(2)} =1.0_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong> <span class="math display">\[0\;00000001\;00000000000000000000000\]</span> <strong>第 8 步：转为十进制</strong> <spanclass="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.0 × 2^1 \\= 10_{(2)} \\= 2.0_{(10)}\]</span></p><h2 id="go-语言输出浮点数">Go 语言输出浮点数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> number <span class="hljs-type">float32</span> = <span class="hljs-number">12.375</span><br>fmt.Printf(<span class="hljs-string">&quot;浮点数：%f\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;科学计数法：%e\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;保留 2 位小数：%.2f\n&quot;</span>, number)<br><br>bits := math.Float32bits(number)<br>bitsStr := fmt.Sprintf(<span class="hljs-string">&quot;%.32b&quot;</span>, bits)<br>fmt.Printf(<span class="hljs-string">&quot;输出32位浮点表示：%s %s %s\n&quot;</span>, bitsStr[:<span class="hljs-number">1</span>], bitsStr[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>], bitsStr[<span class="hljs-number">9</span>:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mathbig">math/big</h2><p>Go 语言的 <code>math/big</code>包提供了对大数的精确计算支持，这些大数的大小超出了标准整数类型（如<code>int64</code>）或浮点类型（如<code>float64</code>）的范围。这个包主要用于需要高精度计算的领域，如加密、科学计算等。</p><p>主要功能：</p><ul><li><strong>算术运算</strong>：支持基本的加、减、乘、除等算术运算。</li><li><strong>比较操作</strong>：可以比较两个大数的大小。</li><li><strong>位操作</strong>：对大整数进行位操作，如位移、与、或、异或等。</li><li><strong>解析和格式化</strong>：可以从字符串解析大数，也可以将大数格式化为字符串。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := big.NewFloat(math.MaxFloat64)<br>b := big.NewFloat(math.MaxFloat64)<br>sum := big.NewFloat(<span class="hljs-number">0</span>)<br>sum.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;a:&quot;</span>, a)<br>fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, sum)<br>sum2 := big.NewFloat(<span class="hljs-number">0</span>).<br>SetPrec(<span class="hljs-number">15</span>).        <span class="hljs-comment">// 设置精度，prec 越大，精度越高，计算越复杂</span><br>SetMode(big.ToZero) <span class="hljs-comment">// 设置舍入策略</span><br>sum2.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;sum2:&quot;</span>, sum2)<br>&#125;<br><br><span class="hljs-comment">// a: 1.7976931348623157e+308</span><br><span class="hljs-comment">// sum: 3.5953862697246314e+308</span><br><span class="hljs-comment">// sum2: 3.5953e+308</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li><strong>性能考虑</strong>：由于 <code>math/big</code>提供的是任意精度计算，其性能通常低于原生的固定大小数值类型。</li><li><strong>内存使用</strong>：大数运算可能会消耗更多的内存。</li><li><strong>方法链式调用</strong>：<code>math/big</code>的许多方法返回接收者本身，支持链式调用。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754</a></li><li>深入理解计算机系统</li><li>Go 语言底层原理剖析</li><li>https://www.bilibili.com/video/BV1zK4y1j7Cn</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机原理</tag>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go1.21.0 程序启动过程</title>
    <link href="/2023/12/07/go-start/"/>
    <url>/2023/12/07/go-start/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Go 1.21.0</li><li>操作系统：Windows11 Intel64</li></ul><h2 id="结论先行">结论先行</h2><h3 id="开发关注版">开发关注版</h3><p>在 Go 语言中，启动顺序通常如下：</p><ol type="1"><li><strong>导入包</strong>：首先，Go 编译器按照源文件中的<code>import</code> 语句导入所有需要的包。</li><li><strong>初始化常量和变量</strong>：接着，编译器会初始化包级别（全局）的常量和变量。它们的初始化顺序按照它们在源文件中出现的顺序进行。</li><li><strong>执行 init 函数</strong>：然后，编译器会执行包级别的<code>init</code> 函数。如果一个包有多个 <code>init</code>函数，它们的执行顺序和它们在源文件中出现的顺序一致。</li><li><strong>执行 main.main 函数</strong>：最后，编译器会执行<code>main</code> 函数。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/710735-20211213134644475-1604352048.png"alt="Go 程序启动流程 - 开发关注版" /><figcaption aria-hidden="true">Go 程序启动流程 - 开发关注版</figcaption></figure><h3 id="深入原理版">深入原理版</h3><ol type="1"><li><strong>命令行参数复制</strong>：读取命令行参数，复制到 argc 和argv。</li><li><strong>初始化 g0 栈</strong>：g0 是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li><strong>runtime.check 运行时检查</strong>：<ol type="1"><li>类型长度</li><li>指针操作</li><li>结构体字段偏移量</li><li>CAS</li><li>atomic 操作</li><li>栈大小是否为 2 的幂次。</li></ol></li><li><strong>runtime.args 参数初始化</strong>：将 argc 和 argv的参数赋值到 Go 的变量中。</li><li><strong>runtime.osinit初始化操作系统特点的设置</strong>：主要是判断系统字长和 CPU 核数。</li><li><strong>runtime.schedinit 初始化调度器</strong>：<ol type="1"><li>锁初始化</li><li>竞态检测器初始化</li><li>调度器设置，设置调度器可以管理的最大线程（M）数目</li><li>系统初始化，初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础</li><li>设置当前 M 的信号掩码</li><li>解析程序参数和环境变量</li><li>垃圾收集器初始化</li><li>设置 process 的数量</li></ol></li><li><strong>runtime.newproc 创建主协程 g0并将其放入队列中等待执行</strong>。</li><li><strong>runtime. mstart 启动调度器</strong>：初始化 m0，并调度 g0去执行 <code>runtime.main</code>。</li><li><strong>runtime.main 程序真正入口</strong>：<ol type="1"><li>runtime.init</li><li>启动 gc</li><li>执行用户包 init</li><li>执行用户函数 main.main</li></ol></li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210224929126.png"alt="Go 程序启动流程 - 深入原理版" /><figcaption aria-hidden="true">Go 程序启动流程 - 深入原理版</figcaption></figure><blockquote><p>如果只是想对 Go语言程序的启动过程有一个简单的了解，那么阅读到这里就可以结束了。</p></blockquote><h2 id="runtime">Runtime</h2><p>在分析 Go 程序的启动过程之前，我们需要先了解一下 Go 中的Runtime。所谓 Runtime，即 Go 的运行时环境，可以理解为 Java 的JVM、JavaScript 依赖的浏览器内核。</p><p>Go 的 Runtime是一份代码，它会随着用户程序一起打包成二进制文件，随着程序一起运行。</p><p>Runtime 具有内存管理、GC、协程、屏蔽不同操作系统调用等能力。</p><p>综上，Go 程序的运行都依赖于 Runtime 运行，所以我们在分析 Go语言程序的启动过程的时候，首先要确定程序的入口，即 Runtime。</p><p>这部分代码位于 go 源码中 <ahref="https://github.com/golang/go/tree/go1.21.0/src/runtime">src/runtime</a>目录下，当你在本机安装 go 后，你可以进入相应的代码目录下，在 Windows上，你可以在该目录下运行下面命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> | findstr <span class="hljs-string">&quot;rt0&quot;</span> |  findstr <span class="hljs-string">&quot;amd&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们输出 go 官方为多种 <code>amd</code>处理器架构的操作系统所实现的 runtime，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">754</span> rt0_android_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">399</span> rt0_darwin_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">448</span> rt0_dragonfly_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">442</span> rt0_freebsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_illumos_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">425</span> rt0_ios_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">307</span> rt0_linux_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">309</span> rt0_netbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_openbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">481</span> rt0_plan9_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_solaris_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>           <span class="hljs-number">1166</span> rt0_windows_amd64.s<br></code></pre></td></tr></table></figure><p>到这里也就明白了，前面所说的 Go Runtime 能力之“屏蔽不同操作系统调用能力”的方式便是针对每一种操作系统单独做实现，最后在编译的时候根据操作系统选择对应的实现即可。</p><p>这里我们以 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/rt0_windows_amd64.s">rt0_windows_amd64.s</a>为例，看看这个文件写了些什么：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> _rt0_amd64_windows(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME,$-8</span><br><span class="hljs-title">JMP_rt0_amd64(SB)</span><br></code></pre></td></tr></table></figure><p>这里我们可以看到它会直接跳到 <code>_rt0_amd64(SB)</code> 这里，在Goland IDE 中，你可以双击 Shift 键打开搜索，搜索<code>TEXT _rt0_amd64</code>，就可以发现这个函数位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，查看该文件：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// _rt0_amd64 is common startup code for most amd64 systems when using</span><br><span class="hljs-comment">// internal linking. This is the entry point for the program from the</span><br><span class="hljs-comment">// kernel for an ordinary -buildmode=exe program. The stack holds the</span><br><span class="hljs-comment">// number of arguments and the C-style argv.</span><br><span class="hljs-symbol">TEXT</span> _rt0_amd64(<span class="hljs-built_in">SB</span>),NOSPLIT,$-<span class="hljs-number">8</span><br>MOVQ<span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>), DI<span class="hljs-comment">// argc</span><br>LEAQ<span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>), SI<span class="hljs-comment">// argv</span><br>JMPruntime·rt0_go(<span class="hljs-built_in">SB</span>)<br></code></pre></td></tr></table></figure><p>翻译一下上面的注释：<code>_rt0_amd64</code> 是大多数<code>amd64</code> 系统在使用内部链接时的通用启动代码。这是<code>exe</code> 程序从内核进入程序的入口点。堆栈保存了参数的数量和 C语言风格的 argv。</p><p>到这里我们就可以非常确定地找到了对应操作系统的 Go语言程序启动入口了，接下来只需要沿着该入口继续分析即可。</p><h2 id="runtimert0_go">runtime·rt0_go</h2><p>上面我们分析到 <code>_rt0_adm64</code> 会 JMP 到<code>runtime·rt0_go</code> 执行，这个函数也位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，通过分析这个函数，我们可以了解到 Go 语言程序的整个启动过程。</p><p>下面将对这整个函数进行一个概览，后面会对重点过程逐个详述。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·rt0_go(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME|</span>TOPFRAME,<span class="hljs-number">$0</span><br><span class="hljs-comment">// 读取命令行参数，复制参数变量 argc 和 argv 到栈上</span><br>MOVQDI, AX<span class="hljs-comment">// argc</span><br>MOVQSI, <span class="hljs-keyword">BX</span><span class="hljs-comment">// argv</span><br>SUBQ$(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>), <span class="hljs-built_in">SP</span><br>ANDQ$~<span class="hljs-number">15</span>, <span class="hljs-built_in">SP</span><br>MOVQAX, <span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>)<br>MOVQBX, <span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>)<br><br><span class="hljs-comment">// 从给定的（操作系统）堆栈创建istack。</span><br><span class="hljs-comment">// 这是在设置 g0 的堆栈，g0 是运行时系统的一个特殊的 goroutine。</span><br><span class="hljs-comment">// 它在程序启动时被创建，用于执行系统调用和协程调度。</span><br><span class="hljs-comment">// 这里只是初始化 g0 的堆栈，还没有启动 g0。</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), DI<br>LEAQ(-<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)(<span class="hljs-built_in">SP</span>), <span class="hljs-keyword">BX</span><br>MOVQBX, g_stackguard0(DI)<br>MOVQBX, g_stackguard1(DI)<br>MOVQBX, (g_stack+stack_lo)(DI)<br>MOVQ<span class="hljs-built_in">SP</span>, (g_stack+stack_hi)(DI)<br><br><span class="hljs-comment">// 检查 CPU 的厂商 ID：</span><br><span class="hljs-comment">//如果没有 CPU 信息，则跳转到 nocpuinfo；</span><br><span class="hljs-comment">//如果是 Intel 的 CPU，就设置 runtime·isIntel=1，否则跳到 notintel。</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEnocpuinfo<br>CMPLBX, <span class="hljs-number">$0x756E6547</span>  <span class="hljs-comment">// &quot;Genu&quot;</span><br>JNEnotintel<br>CMPLDX, <span class="hljs-number">$0x49656E69</span>  <span class="hljs-comment">// &quot;ineI&quot;</span><br>JNEnotintel<br>CMPLCX, <span class="hljs-number">$0x6C65746E</span>  <span class="hljs-comment">// &quot;ntel&quot;</span><br>JNEnotintel<br>MOVB<span class="hljs-number">$1</span>, runtime·isIntel(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">notintel:</span>  <span class="hljs-comment">// 加载 EXA=1 的 cpuid 标志和版本信息</span><br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>MOVLAX, runtime·processorVersionInfo(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">nocpuinfo:</span>  <br><span class="hljs-comment">// 如果有 _cgo_init 就调用它</span><br>MOVQ_cgo_init(<span class="hljs-built_in">SB</span>), AX<br>TESTQAX, AX<br><span class="hljs-comment">// 如果 _cgo_init 不存在，那么跳过后面的代码，</span><br><span class="hljs-comment">// 直接进入到 needtls 进行 TLS 的初始化。</span><br><span class="hljs-comment">// TLS，全称为Thread-Local Storage（线程局部存储），</span><br><span class="hljs-comment">// 是操作系统提供的一种机制，允许每个线程拥有一份自己的数据副本。</span><br><span class="hljs-comment">// 这些数据在同一线程的所有函数中都是可见的，但对其他线程是不可见的。</span><br><span class="hljs-comment">// 这样，每个线程可以访问和修改自己的数据，而不会影响其他线程。</span><br>JZneedtls<br><span class="hljs-comment">// 将 setg_gcc 函数的地址加载到 SI 寄存器中。</span><br><span class="hljs-comment">// 这是 _cgo_init 函数的第二个参数。</span><br>MOVQ$setg_gcc&lt;&gt;(<span class="hljs-built_in">SB</span>), SI <span class="hljs-comment">// arg 2: setg_gcc</span><br><span class="hljs-comment">// 在使用平台的TLS时不使用这第3和第4个参数。</span><br>MOVQ<span class="hljs-number">$0</span>, DX<br>MOVQ<span class="hljs-number">$0</span>, CX<br><span class="hljs-comment">#ifdef GOOS_android</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// arg 4: TLS base, stored in slot 0 (Android&#x27;s TLS_SLOT_SELF).</span><br><span class="hljs-comment">// Compensate for tls_g (+16).</span><br>MOVQ-<span class="hljs-number">16</span>(TLS), CX<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// 调整 Win64 的调用约定。</span><br>MOVQCX, <span class="hljs-built_in">R9</span> <span class="hljs-comment">// arg 4</span><br>MOVQDX, <span class="hljs-built_in">R8</span> <span class="hljs-comment">// arg 3</span><br>MOVQSI, DX <span class="hljs-comment">// arg 2</span><br>MOVQDI, CX <span class="hljs-comment">// arg 1</span><br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">// 前面 MOVQ_cgo_init(SB), AX，这里就是调用 _cgo_init</span><br>CALLAX<br><span class="hljs-comment">// 在 _cgo_init 之后更新 stackguard</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQ(g_stack+stack_lo)(CX), AX<br>ADDQ$const_stackGuard, AX<br>MOVQAX, g_stackguard0(CX)<br>MOVQAX, g_stackguard1(CX)<br><br><span class="hljs-comment">#ifndef GOOS_windows</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 针对不同操作系统对 TLS 进行设置</span><br><span class="hljs-symbol">needtls:</span>  <br><span class="hljs-comment">#ifdef GOOS_plan9</span><br><span class="hljs-comment">// skip TLS setup on Plan 9</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_solaris</span><br><span class="hljs-comment">// skip TLS setup on Solaris</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_illumos</span><br><span class="hljs-comment">// skip TLS setup on illumos</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_darwin</span><br><span class="hljs-comment">// skip TLS setup on Darwin</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_openbsd</span><br><span class="hljs-comment">// skip TLS setup on OpenBSD</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>CALLruntime·wintls(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">#endif</span><br><br>LEAQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), DI<br>CALLruntime·settls(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 检查 TLS 是否正常工作</span><br>get_tls(BX)<br>MOVQ<span class="hljs-number">$0x123</span>, g(BX)<br>MOVQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), AX<br>CMPQAX, <span class="hljs-number">$0x123</span><br>JEQ <span class="hljs-number">2</span>(<span class="hljs-built_in">PC</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">ok:</span><br><span class="hljs-comment">//设置 g0 和 m0 和 TLS</span><br>get_tls(BX)<br>LEAQruntime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQCX, g(BX)<br>LEAQruntime·m0(<span class="hljs-built_in">SB</span>), AX<br>MOVQCX, m_g0(AX)<br>MOVQAX, g_m(CX)<br>CLD<br><br><span class="hljs-comment">// 下面的 ifdef NEED_xxx 主要是在检查 CPU 是否支持 Go 运行时系统需要的特性。</span><br><span class="hljs-comment">// 我们需要在设置了 TLS 之后做这个，</span><br><span class="hljs-comment">// 如果失败就跳转到 bad_cpu 报告错误。</span><br><span class="hljs-comment">#ifdef NEED_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEbad_cpu<br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>ANDL$NEED_FEATURES_CX, CX<br>CMPLCX, $NEED_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_MAX_CPUID</span><br>MOVL<span class="hljs-number">$0x80000000</span>, AX<br>CPUID<br>CMPLAX, $NEED_MAX_CPUID<br>JLbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_BX</span><br>MOVL<span class="hljs-number">$7</span>, AX<br>MOVL<span class="hljs-number">$0</span>, CX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_BX, <span class="hljs-keyword">BX</span><br>CMPLBX, $NEED_EXT_FEATURES_BX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0x80000001</span>, AX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_CX, CX<br>CMPLCX, $NEED_EXT_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_OS_SUPPORT_AX</span><br>XORL    CX, CX<br>XGETBV<br>ANDL$NEED_OS_SUPPORT_AX, AX<br>CMPLAX, $NEED_OS_SUPPORT_AX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_DARWIN_SUPPORT</span><br>MOVQ$commpage64_version, <span class="hljs-keyword">BX</span><br>CMPW(BX), <span class="hljs-number">$13</span>  <span class="hljs-comment">// cpu_capabilities64 undefined in versions &lt; 13</span><br>JLbad_cpu<br>MOVQ$commpage64_cpu_capabilities64, <span class="hljs-keyword">BX</span><br>MOVQ(BX), <span class="hljs-keyword">BX</span><br>MOVQ$NEED_DARWIN_SUPPORT, CX<br>ANDQCX, <span class="hljs-keyword">BX</span><br>CMPQBX, CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 检查完 AMD64 不同操作系统是否支持 Go 运行时系统需要的特性后，</span><br><span class="hljs-comment">// 这里执行 runtime·check 对代码做一下运行时检查。</span><br>CALLruntime·check(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 复制 argc（命令行参数的数量）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVL<span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVLAX, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 复制 argv（命令行参数的数组）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVQ<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 调用 runtime·args 函数处理命令行参数。</span><br>CALLruntime·args(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·osinit 函数初始化操作系统特定的设置。</span><br>CALLruntime·osinit(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·schedinit 函数初始化调度器。</span><br>CALLruntime·schedinit(<span class="hljs-built_in">SB</span>)<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   补充：这是该文件下面对 runtime·mainPC 的声明</span><br><span class="hljs-comment">    // mainPC is a function value for runtime.main, to be passed to newproc.</span><br><span class="hljs-comment">    // The reference to runtime.main is made via ABIInternal, since the</span><br><span class="hljs-comment">    // actual function (not the ABI0 wrapper) is needed by newproc.</span><br><span class="hljs-comment">    DATAruntime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)</span><br><span class="hljs-comment">    */</span><br>        <br>    <span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br>    <span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br>MOVQ$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br>PUSHQAX<br>    <span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br>    <span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br>    <span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br>CALLruntime·newproc(<span class="hljs-built_in">SB</span>)<br>POPQAX<br><br><span class="hljs-comment">// 调用 runtime·mstart 函数启动 M（machine，代表一个操作系统线程），</span><br><span class="hljs-comment">// 开始执行 goroutines。</span><br>CALLruntime·mstart(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">//  如果 runtime·mstart 函数返回，那么就调用 runtime·abort 函数终止程序。</span><br><span class="hljs-comment">// 因为 runtime·mstart 函数在正常情况下是不应该返回的，如果返回了，说明有错误发生。</span><br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<span class="hljs-comment">// mstart should never return</span><br>RET<br><br><span class="hljs-symbol">bad_cpu:</span> <span class="hljs-comment">// 当前 CPU 不支持 Go 运行时系统需要的时候的错误报告。</span><br>MOVQ<span class="hljs-number">$2</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ$bad_cpu_msg&lt;&gt;(<span class="hljs-built_in">SB</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ<span class="hljs-number">$84</span>, <span class="hljs-number">16</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·write(<span class="hljs-built_in">SB</span>)<br>MOVQ<span class="hljs-number">$1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·exit(<span class="hljs-built_in">SB</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br>RET<br><br><span class="hljs-comment">// Prevent dead-code elimination of debugCallV2, which is</span><br><span class="hljs-comment">// intended to be called by debuggers.</span><br>MOVQ$runtime·debugCallV2&lt;ABIInternal&gt;(<span class="hljs-built_in">SB</span>), AX<br>RET<br></code></pre></td></tr></table></figure><p>整理一下，<code>runtime·rt0_go</code> 的大体过程如下：</p><ol type="1"><li>读取命令行参数，复制参数变量 argc 和 argv 到栈上。</li><li>初始化 g0 栈，g0 是为了调度协程而产生的协程，是 g0是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li>获取 CPU 信息。</li><li>如果存在 <code>_cgo_init</code>，这调用它。</li><li>检查并设置线性局部存储（TLS）。</li><li>检查 CPU 是否支持 Go 运行时系统需要的特性。</li><li>完成运行时系统检查和初始化：<ul><li>调用 <code>runtime·check</code> 对代码进行运行时检查。</li><li>调用 <code>runtime·args</code> 函数处理命令行参数。</li><li>调用 <code>runtime·osinit</code> 函数初始化操作系统特定的设置。</li><li>调用 <code>runtime·schedinit</code> 函数初始化调度器。</li></ul></li><li>调用 <code>runtime·newproc</code> 创建一个新的 goroutine来运行程序的主函数。</li><li>调用 <code>runtime·mstart</code> 启动当前的 machine，执行goroutines，执行程序。</li></ol><p>一句话：<code>runtime·rt0_go</code> 是 Go语言运行时的入口点，它负责设置和初始化运行时环境，然后创建 g0 和 m0来运行程序的主函数。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/3EGyo5Q3LRKr4XdNg1dHFr.png"alt="Go 运行时系统初始化流程" /><figcaption aria-hidden="true">Go 运行时系统初始化流程</figcaption></figure><p>了解完 Go 程序的整体启动流程后，我们重点来分析一下其中的<code>runtime·check</code>、<code>runtime·args</code>、<code>runtime·osinit</code>、<code>runtime·schedinit</code>、<code>runtime·newproc</code>和 <code>runtime·mstart</code>。</p><blockquote><p>对了，充分理解 Go 启动流程，可能需要你对 Go 的 GMP 模型有一定的了解。// TODO</p></blockquote><h2 id="runtimecheck">runtime·check</h2><p>在 Goland IDE 上，我们双击 Shift，全局搜索 <code>runtime·check</code>会发现找不到函数的实现。</p><p>Go 语言的运行时系统大部分是用 Go自己编写的，但是有一部分，特别是与平台相关的部分，是用汇编语言编写的。在汇编语言中，调用Go 函数的一种方式是使用 <code>CALL</code>指令和函数的全名，包括包名和函数名。在这种情况下，<code>runtime·check</code>就是调用 <code>runtime</code> 包下的 <code>check()</code> 函数。</p><p>所以我们需要双击 Shift，搜索 <code>runtine.check</code>，即将<code>·</code> 换成<code>.</code>（后面所有函数均是这个道理）。我们会发现<code>check()</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime1.go">runtime/runtime1.go</a>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>a     <span class="hljs-type">int8</span><br>b     <span class="hljs-type">uint8</span><br>c     <span class="hljs-type">int16</span><br>d     <span class="hljs-type">uint16</span><br>e     <span class="hljs-type">int32</span><br>f     <span class="hljs-type">uint32</span><br>g     <span class="hljs-type">int64</span><br>h     <span class="hljs-type">uint64</span><br>i, i1 <span class="hljs-type">float32</span><br>j, j1 <span class="hljs-type">float64</span><br>k     unsafe.Pointer<br>l     *<span class="hljs-type">uint16</span><br>m     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>)<br><span class="hljs-keyword">type</span> x1t <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">type</span> y1t <span class="hljs-keyword">struct</span> &#123;<br>x1 x1t<br>y  <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">var</span> x1 x1t<br><span class="hljs-keyword">var</span> y1 y1t<br>    <span class="hljs-comment">// 检查各种类型的变量的大小是否符合预期</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(a) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad a&quot;</span>)<br>&#125;<br>    ...<br>    <span class="hljs-comment">// 检查指针操作</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(k) != goarch.PtrSize &#123;<br>throw(<span class="hljs-string">&quot;bad k&quot;</span>)<br>&#125;<br>    ...<br><span class="hljs-comment">// 检查结构体中字段的偏移量是否符合预期 </span><br><span class="hljs-keyword">if</span> unsafe.Offsetof(y1.y) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad offsetof y1.y&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// timediv 函数的目的是在 32 位处理器上实现 64 位的除法运算。</span><br>    <span class="hljs-comment">// 由于在 32 位处理器上，64 位的除法运算会被转换为 _divv() 函数调用，</span><br>    <span class="hljs-comment">// 这可能会超出 nosplit 函数的栈限制，所以需要这个特殊的函数来进行处理。</span><br>    <span class="hljs-comment">// //go:nosplit 是一个编译器指令，它告诉编译器不要在这个函数中插入栈分割检查。</span><br>    <span class="hljs-comment">// 这意味着这个函数必须在当前的栈帧中运行，不能增加栈的大小。</span><br>    <span class="hljs-comment">// 如果这个函数需要更多的栈空间，那么它将会导致栈溢出。</span><br><span class="hljs-keyword">if</span> timediv(<span class="hljs-number">12345</span>*<span class="hljs-number">1000000000</span>+<span class="hljs-number">54321</span>, <span class="hljs-number">1000000000</span>, &amp;e) != <span class="hljs-number">12345</span> || e != <span class="hljs-number">54321</span> &#123;<br>throw(<span class="hljs-string">&quot;bad timediv&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// CAS 操作检查</span><br><span class="hljs-keyword">var</span> z <span class="hljs-type">uint32</span><br>z = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> !atomic.Cas(&amp;z, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;cas1&quot;</span>)<br>&#125;<br>...<br>    <span class="hljs-comment">// 检查 atomic 原子操作</span><br>m = [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>atomic.Or8(&amp;m[<span class="hljs-number">1</span>], <span class="hljs-number">0xf0</span>)<br><span class="hljs-keyword">if</span> m[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">1</span>] != <span class="hljs-number">0xf1</span> || m[<span class="hljs-number">2</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">3</span>] != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;atomicor8&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试浮点数 NaN（Not a Number）的行为</span><br>*(*<span class="hljs-type">uint64</span>)(unsafe.Pointer(&amp;j)) = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> j == j &#123;<br>throw(<span class="hljs-string">&quot;float64nan&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !(j != j) &#123;<br>throw(<span class="hljs-string">&quot;float64nan1&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试 64 位原子操作</span><br>testAtomic64()<br>    <span class="hljs-comment">// 检查栈大小是否是 2 的 n 次幂</span><br><span class="hljs-keyword">if</span> fixedStack != round2(fixedStack) &#123;<br>throw(<span class="hljs-string">&quot;FixedStack is not power-of-2&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 上报编代码的运行时检查中是否有异常</span><br><span class="hljs-keyword">if</span> !checkASM() &#123;<br>throw(<span class="hljs-string">&quot;assembly checks failed&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上：<code>runtime·check</code> 主要是做一些运行时的检查。</p><ol type="1"><li>使用 <code>unsafe.Sizeof</code>函数检查各种类型的变量的大小是否符合预期。</li><li>使用 <code>unsafe.Offsetof</code>函数检查结构体中字段的偏移量是否符合预期。</li><li>测试 <code>timediv</code> 函数检查在 32 位机器上进行 64位除法运算的结果是否符合预期。</li><li>使用 <code>atomic.Cas</code> 函数（Compare andSwap）进行原子比较和交换测试。</li><li>使用 <code>atomic.Or8</code> 和 <code>atomic.And8</code>函数进行原子位操作测试。</li><li>测试浮点数 NaN（Not a Number）的行为。</li><li>调用 <code>testAtomic64</code> 函数测试 64 位的原子操作。</li><li>检查 <code>fixedStack</code> 栈大小是否是 2 的幂。</li><li>调用 <code>checkASM</code>函数检查汇编代码检查运行时中是否有异常。</li></ol><h2 id="runtimeargs">runtime·args</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">var</span> (<br>argc <span class="hljs-type">int32</span><br>argv **<span class="hljs-type">byte</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">args</span><span class="hljs-params">(c <span class="hljs-type">int32</span>, v **<span class="hljs-type">byte</span>)</span></span> &#123;<br>argc = c<br>argv = v<br>sysargs(c, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简单，就是将命令行参数拷贝到 <code>runtime</code>包下的全局变量 <code>argc</code> 和 <code>argv</code> 上。后面在<code>shcedinit()</code> 函数中会调用 <code>goargs()</code> 来遍历 argv将参数复制到 slice 上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goargs</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>argslice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, argc)<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>); i &lt; argc; i++ &#123;<br>argslice[i] = gostringnocopy(argv_index(argv, i))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeosinit">runtime·osinit</h2><p>这里函数主要是初始化操作系统特点的设置，可以看到这里针对不同操作系统都做了实现：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231209131939116.png"alt="osinit" /><figcaption aria-hidden="true">osinit</figcaption></figure><p>这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/os_windows.go">os_windows.go</a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">osinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取 asmstdcall 函数的地址，并将其转换为一个不安全的指针。</span><br>    <span class="hljs-comment">// 这通常在需要直接操作内存或进行系统调用的时候使用。</span><br>asmstdcallAddr = unsafe.Pointer(abi.FuncPCABI0(asmstdcall))<br><br>    <span class="hljs-comment">// 加载一些可选的系统调用。</span><br>loadOptionalSyscalls()<br><br>    <span class="hljs-comment">// 阻止显示错误对话框。这可能是为了防止在出现错误时打断用户。</span><br>preventErrorDialogs()<br><br>    <span class="hljs-comment">// 初始化异常处理器，用于处理运行时发生的异常。</span><br>initExceptionHandler()<br><br>    <span class="hljs-comment">// 初始化高分辨率计时器，用于精确的时间测量。</span><br>initHighResTimer()<br>timeBeginPeriodRetValue = osRelax(<span class="hljs-literal">false</span>)<br><br>    <span class="hljs-comment">// 初始化系统目录</span><br>initSysDirectory()<br>    <br>    <span class="hljs-comment">// 启用长路径支持。</span><br>    <span class="hljs-comment">// 在 Windows 中，路径的长度通常限制为 260 个字符。启用长路径支持可以突破这个限制。</span><br>initLongPathSupport()<br><br>    <span class="hljs-comment">// 码获取处理器的数量并将其赋给 ncpu。</span><br>    ncpu = getproccount()<br><br>    <span class="hljs-comment">// 获取内存页的大小并将其赋给 physPageSize，为了后面进行内存管理。</span><br>physPageSize = getPageSize()<br><br>    <span class="hljs-comment">// 调用 SetProcessPriorityBoost 函数，禁用动态优先级提升。</span><br>    <span class="hljs-comment">// 在 Windows 中，动态优先级提升是一种机制，可以根据线程的类型和行为自动调整其优先级。</span><br>    <span class="hljs-comment">// 但在 Go 的环境中，所有的线程都是等价的，都可能进行 GUI、IO、计算等各种操作，</span><br>    <span class="hljs-comment">// 所以动态优先级提升可能会带来问题，因此这里选择禁用它。</span><br>stdcall2(_SetProcessPriorityBoost, currentProcess, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeschedinit">runtime·schedinit ★</h2><p>这个函数就非常重要了，从名字就可以看出来，这是 Go语言调度器的初始化过程。这个函数位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>。</p><p>我们可以先来看看 <code>schedinit()</code> 的函数注释，这里也透露了 Go语言程序的启动流程的核心顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:启动流程顺序：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//call osinit  1. 调用 osinit</span><br><span class="hljs-comment">//call schedinit2. 调用 schedinit</span><br><span class="hljs-comment">//make &amp; queue new G3. 创建一个协程 G</span><br><span class="hljs-comment">//call runtime·mstart4. 调用 mstart</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The new G calls runtime·main. 5. G 执行 runtime.main</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们详细来看看 <code>schedinit()</code> 都做了些什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化各种锁，其中 lockRankXXX 指定锁的级别。</span><br>lockInit(&amp;sched.lock, lockRankSched)<br>lockInit(&amp;sched.sysmonlock, lockRankSysmon)<br>lockInit(&amp;sched.deferlock, lockRankDefer)<br>lockInit(&amp;sched.sudoglock, lockRankSudog)<br>lockInit(&amp;deadlock, lockRankDeadlock)<br>lockInit(&amp;paniclk, lockRankPanic)<br>lockInit(&amp;allglock, lockRankAllg)<br>lockInit(&amp;allpLock, lockRankAllp)<br>lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)<br>lockInit(&amp;finlock, lockRankFin)<br>lockInit(&amp;cpuprof.lock, lockRankCpuprof)<br>traceLockInit()<br>lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)<br><br><span class="hljs-comment">// 如果启用了竞态检测，则初始化竞态检测器，</span><br>    <span class="hljs-comment">// 即我们使用 -race 的时候会执行这里。</span><br>gp := getg()<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>gp.racectx, raceprocctx0 = raceinit()<br>&#125;<br><br>    <span class="hljs-comment">// 限制 M 的数量，即线程的数量。</span><br>    <span class="hljs-comment">// maxmcount    int32    // maximum number of m&#x27;s allowed (or die)</span><br>sched.maxmcount = <span class="hljs-number">10000</span><br><br><span class="hljs-comment">// 将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</span><br>worldStopped()<br><br>    <span class="hljs-comment">// 进行一系列的系统初始化（内存管理、CPU 设置、栈、算法等）</span><br>moduledataverify()<br>stackinit()<br>mallocinit()<br>godebug := getGodebugEarly()<br>initPageTrace(godebug) <span class="hljs-comment">// must run after mallocinit but before anything allocates</span><br>cpuinit(godebug)       <span class="hljs-comment">// must run before alginit</span><br>alginit()              <span class="hljs-comment">// maps, hash, fastrand must not be used before this call</span><br>fastrandinit()         <span class="hljs-comment">// must run before mcommoninit</span><br>mcommoninit(gp.m, <span class="hljs-number">-1</span>)<br>modulesinit()   <span class="hljs-comment">// provides activeModules</span><br>typelinksinit() <span class="hljs-comment">// uses maps, activeModules</span><br>itabsinit()     <span class="hljs-comment">// uses activeModules</span><br>stkobjinit()    <span class="hljs-comment">// must run before GC starts</span><br><br>    <span class="hljs-comment">// 设置和保存当前 M 的信号掩码</span><br>sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br><br>    <span class="hljs-comment">// 解析程序参数和环境变量</span><br>goargs()<br>goenvs()<br>secure()<br>parsedebugvars()<br>    <br>    <span class="hljs-comment">// 初始化垃圾回收器</span><br>gcinit()<br><br><span class="hljs-comment">// 如果设置了 disableMemoryProfiling，即禁用内存分析，</span><br>    <span class="hljs-comment">// 则将 MemProfileRate 置为 0，关闭内存分析。</span><br><span class="hljs-keyword">if</span> disableMemoryProfiling &#123;<br>MemProfileRate = <span class="hljs-number">0</span><br>&#125;<br><br>    <span class="hljs-comment">// 锁定调度器，处理环境变量 GOMAXPROCS，这是开发者可以设置的允许的最多的 P 的数量。</span><br>lock(&amp;sched.lock)<br>sched.lastpoll.Store(nanotime())<br>procs := ncpu<br><span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;<br>procs = n<br>&#125;<br><span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)<br>&#125;<br>unlock(&amp;sched.lock)<br><br><span class="hljs-comment">// 将调度器设置为开始状态。</span><br>worldStarted()<br><br>    <span class="hljs-comment">// 确保构建版本和模块信息被保留在最终的二进制文件中。</span><br><span class="hljs-keyword">if</span> buildVersion == <span class="hljs-string">&quot;&quot;</span> &#123;<br>buildVersion = <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(modinfo) == <span class="hljs-number">1</span> &#123;<br>modinfo = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<code>schedinit</code> 是 Go语言运行时中的一个函数，负责初始化调度器及其相关组件，如锁、信号掩码、内存分配、以及其他系统级别的设置，确保并发执行环境的正确配置和高效运作。</p><p>具体过程如下：</p><ol type="1"><li><strong>锁初始化</strong>:<ul><li>函数开始时，通过 <code>lockInit</code> 调用初始化了多个锁。在 Go的调度器中，锁用于保护共享资源和调度数据结构，确保在多个线程或协程中的安全访问。每个锁都有一个特定的级别，这有助于防止死锁。</li></ul></li><li><strong>竞态检测器初始化</strong>:<ul><li>如果启用了竞态检测(<code>raceenabled</code>)，则初始化竞态上下文。这对于在开发阶段检测和避免竞态条件非常重要。</li></ul></li><li><strong>调度器设置</strong>:<ul><li><code>sched.maxmcount = 10000</code>设置调度器可以管理的最大线程（M）数目，这对于控制资源使用和性能调优很重要。</li><li><code>worldStopped()</code>将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</li></ul></li><li><strong>系统初始化</strong>:<ul><li>接下来调用一系列函数（如 <code>moduledataverify</code>,<code>mallocinit</code>, <code>cpuinit</code>, <code>alginit</code>等）来初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础。</li></ul></li><li><strong>环境和调试变量设置</strong>:<ul><li>解析程序参数、环境变量、安全设置和调试变量。</li></ul></li><li><strong>垃圾收集器初始化</strong>:<ul><li><code>gcinit()</code> 初始化垃圾收集器，这是 Go运行时的关键组成部分，负责自动内存管理。</li></ul></li><li><strong>内存分析设置</strong>:<ul><li>根据 <code>disableMemoryProfiling</code>标志决定是否关闭内存分析功能。</li></ul></li><li><strong>处理器数量设置和调度器锁</strong>:<ul><li>锁定调度器来安全地基于环境变量 <code>GOMAXPROCS</code>设置处理器（<code>procs</code>）数量。</li><li>使用 <code>procresize</code>函数根据处理器数量调整调度器的内部结构。</li></ul></li><li><strong>最终步骤和错误检查</strong>:<ul><li>调用 <code>worldStarted()</code>表示调度器已准备好开始调度协程。</li><li>检查和设置构建版本和模块信息，保证这些信息在最终的二进制文件中。</li></ul></li></ol><p>这里有几个地方比较有趣，我们来做一下简单的了解。（可跳过）</p><h3 id="初始化锁-lockinitmutex-rank">初始化锁 lockInit(mutex, rank)</h3><p>我们知道 <code>lockInit(mutex,rank)</code> 是用来初始化锁的，第 2个参数 <code>rank</code> 便是锁的等级。如果这个时候你链接到<code>lcokInit</code> 实现的地方，你会发现默认会跳到 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_off.go">lockrank_off.go</a>，而且你会发现，它的实现是空的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build !goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lockInit</span><span class="hljs-params">(l *mutex, rank lockRank)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>lockInit</code> 还有另外一个实现，在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_on.go">lockrank_on.go</a>文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">const</span> staticLockRanking = <span class="hljs-literal">true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLockRank</span><span class="hljs-params">(l *mutex)</span></span> lockRank &#123;<br><span class="hljs-keyword">return</span> l.rank<br>&#125;<br></code></pre></td></tr></table></figure><p>这什么意思呢？通过文件名称我们其实就可以猜到了，<code>lockrank_off.go</code>是提供了无锁级别的锁，而 <code>lockrank_on.go</code>是提供了有锁级别的锁。至于应该采用哪一个，是通过 go build 中的<code>goexperiment.staticlockranking</code> 参数来控制的。</p><p>这里涉及一个概念，叫做锁排序（Lock Ranking）：</p><ul><li>锁排序是一种用于避免死锁的技术。在这种机制中，每个锁都被赋予一个等级（或称为“rank”），并且有规则确保锁的获取遵循这些等级的顺序。</li><li>通常，这意味着一个线程在获取等级较低的锁之前，必须先释放所有等级较高的锁。这样可以防止死锁，因为它避免了循环等待条件的发生。</li><li>Go 语言中锁的等级和顺序定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank.go">lockrank.go</a>文件中。</li></ul><p>锁排序的作用：</p><ul><li>在 Go的并发模型中，锁是同步共享资源访问的重要机制。<code>lockInit</code>函数在运行时初始化锁，为其分配等级，有助于维护程序的稳定性和性能。</li><li>锁排序功能的开启或关闭取决于是否需要额外的死锁检测。在开发和调试阶段，开启锁排序可以帮助发现死锁问题。然而，它可能引入额外的性能开销，因此在生产环境中可能会被关闭。</li></ul><p>最后我们来看一下 <code>schedinit()</code> 都初始化了哪些锁：</p><table><thead><tr class="header"><th>Lock</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>sched.lock</td><td>初始化调度器的主锁。这个锁用于控制对调度器的访问，保证调度过程的正确性。</td></tr><tr class="even"><td>sched.sysmonlock</td><td>系统监控锁，用于保护系统监控相关的数据结构。</td></tr><tr class="odd"><td>sched.deferlock</td><td>用于控制延迟执行函数列表的锁。</td></tr><tr class="even"><td>sched.sudoglock</td><td>sudog 是 Go 中表示等待通信的 goroutine 的结构。这个锁保护与 sudog相关的操作。</td></tr><tr class="odd"><td>deadlock</td><td>可能用于检测或防止死锁的锁。</td></tr><tr class="even"><td>paniclk</td><td>在处理 panic 时使用的锁。</td></tr><tr class="odd"><td>allglock</td><td>用于控制对所有 goroutine 列表的访问。</td></tr><tr class="even"><td>allpLock</td><td>控制对所有处理器（P）的访问。</td></tr><tr class="odd"><td>reflectOffs.lock</td><td>用于反射操作的锁。</td></tr><tr class="even"><td>finlock</td><td>管理终结器列表的锁。</td></tr><tr class="odd"><td>cpuprof.lock</td><td>用于 CPU 分析数据的锁。</td></tr><tr class="even"><td>traceLockInit()</td><td>专门用于追踪系统的锁初始化函数。</td></tr><tr class="odd"><td>memstats.heapStats.noPLock</td><td>这是一个特殊的锁，被标记为<code>lockRankLeafRank</code>，意味着它应该是锁层级中的最末端（leaf）。这样的锁应该只在非常短的关键部分中使用，以避免成为死锁的源头。</td></tr></tbody></table><h3 id="信号掩码-initsigmask">信号掩码 initSigmask</h3><p>这两行代码是在搞啥呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br></code></pre></td></tr></table></figure><ul><li><code>sigmask</code> 的中文意思是 <code>信号掩码</code>。</li></ul><p>先看一下源码中 <code>initSigmast</code> 的注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Value to use for signal mask for newly created M&#x27;s.</span><br><span class="hljs-keyword">var</span> initSigmask sigset<br></code></pre></td></tr></table></figure><ul><li><code>initSigmask</code> 是一个变量，存储着用于新创建的M（Machine，即操作系统线程）的初始信号掩码。</li></ul><p>什么是信号掩码：</p><ul><li>信号掩码是操作系统中用于控制信号传递给进程或线程的一种机制。它允许进程或线程指定哪些信号可以被阻塞（暂时忽略）或允许。在多线程环境中，这个机制尤其重要，因为它帮助确保线程安全地处理信号。</li></ul><p>信号掩码的作用：</p><ul><li>信号掩码定义了一组信号，这些信号在特定时间内不会传递给进程或线程，即使这些信号发生了也会被系统挂起。这允许进程或线程在一个稳定的状态下运行，不被特定信号中断。</li><li>这种机制对于处理那些可能在关键操作期间导致不稳定状态的信号特别重要。</li></ul><p>信号掩码的重要性：</p><ul><li>在多线程程序中，不同的线程可能需要响应不同的信号或以不同方式处理相同的信号。通过为每个线程设置适当的信号掩码，可以确保线程只处理对它们来说重要的信号。</li><li>这有助于防止线程在执行关键代码时被不相关的信号打断。</li></ul><p><strong>sigsave(&amp;gp.m.sigmask)</strong>：</p><ul><li><code>sigsave(&amp;gp.m.sigmask)</code> 这个调用是在保存当前 M的信号掩码。<code>gp</code> 指的是当前的 goroutine，<code>gp.m</code>是该 goroutine 正在运行的 M（操作系统线程）。</li><li><code>sigsave</code> 函数的作用是将 <code>gp.m</code>的当前信号掩码保存到提供的地址（在这里是<code>&amp;gp.m.sigmask</code>）。这对于恢复线程的信号掩码到一个已知状态是非常有用的。</li></ul><p><strong>initSigmask = gp.m.sigmask</strong>：</p><ul><li>这一行将 <code>gp.m</code> 的信号掩码赋值给<code>initSigmask</code>。这意味着 <code>initSigmask</code>现在保存了当前 M 的信号掩码，这个掩码将被用作新创建的 M的初始信号掩码。</li><li>这是一个重要的步骤，因为它确保了所有新创建的 M 都将具有与当前 M相同的信号处理行为。</li><li>这意味着所有新线程都会以一致的信号掩码启动，这有助于避免由于不同线程处理信号的不一致性导致的问题。</li></ul><p>总体来说，Go语言在其运行时中这样处理信号掩码，是为了确保在并发执行和线程调度中能够安全、一致地处理信号，这对于维护高效和稳定的运行时环境至关重要。</p><h3 id="初始化垃圾回收器-gcinit">初始化垃圾回收器 gcinit()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcinit</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 检查 workbuf 结构体的大小是否等于预期的 _WorkbufSize。</span><br>    <span class="hljs-comment">// 如果不是，抛出异常。这是为了确保 workbuf 的大小是最优的，</span><br>    <span class="hljs-comment">// workbuf 用于垃圾回收过程中的内部工作。</span><br>    <span class="hljs-keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;<br>       throw(<span class="hljs-string">&quot;size of Workbuf is suboptimal&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 第一个垃圾回收周期不进行扫描操作。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收过程中，扫描是回收前清理内存的重要步骤。</span><br>    sweep.active.state.Store(sweepDrainedMask)<br><br>    <span class="hljs-comment">// 使用环境变量 GOGC 和 GOMEMLIMIT 来设置初始的垃圾回收百分比和内存限制。</span><br>    gcController.init(readGOGC(), readGOMEMLIMIT())<br><br>    <span class="hljs-comment">// 初始化用于控制垃圾回收工作流程的信号量。</span><br>    <span class="hljs-comment">// 这些信号量用于同步垃圾回收过程中的不同阶段。</span><br>    work.startSema = <span class="hljs-number">1</span><br>    work.markDoneSema = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment">// 初始化了用于垃圾回收过程中的各种锁。</span><br>    <span class="hljs-comment">// 这些锁用于保护垃圾回收相关数据结构的并发访问，确保垃圾回收过程的线程安全。</span><br>    lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)<br>    lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)<br>    lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *gcControllerState)</span></span> init(gcPercent <span class="hljs-type">int32</span>, memoryLimit <span class="hljs-type">int64</span>) &#123;<br>    <span class="hljs-comment">// 设置 heapMinimum 为默认的最小堆大小。</span><br>    <span class="hljs-comment">// 这是垃圾回收器考虑启动新回收周期前的最小堆内存大小。</span><br>c.heapMinimum = defaultHeapMinimum<br>    <br>    <span class="hljs-comment">// 将 triggered 设置为 uint64 的最大值。</span><br>    <span class="hljs-comment">// 这个字段用于表示触发垃圾回收的内存阈值，</span><br>    <span class="hljs-comment">// 这里的设置意味着在初始状态下不会自动触发垃圾回收</span><br>c.triggered = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-comment">// 设置垃圾回收的百分比阈值。</span><br>    <span class="hljs-comment">// gcPercent 参数表示触发垃圾回收的内存增长百分比。</span><br>    <span class="hljs-comment">// 这个设置控制了堆内存增长到多少百分比时会触发垃圾回收。</span><br>c.setGCPercent(gcPercent)<br>    <br>    <span class="hljs-comment">// 设置内存限制。</span><br>    <span class="hljs-comment">// memoryLimit 参数可能表示堆内存的最大限制，</span><br>    <span class="hljs-comment">// 用于控制垃圾回收器在内存使用方面的行为。</span><br>c.setMemoryLimit(memoryLimit)<br>    <br>    <span class="hljs-comment">// 提交垃圾回收控制器的当前设置，并指示第一次垃圾回收周期没有扫描（sweep）阶段。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收中，扫描是回收周期的一部分，这里指明在第一次垃圾回收时跳过扫描阶段。</span><br>c.commit(<span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimenewproc">runtime·newproc ★</h2><p>初始化完调度器后，就进入到创建 g0的阶段了，我们需要一个协程来运行程序的入口：<code>runtime.main</code>。</p><p><code>newproc()</code> 的作用如注释所说：<strong>创建一个新的goroutine 来执行 <code>fn</code>，并将它放入等待运行的 g队列中。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create a new g running fn.</span><br><span class="hljs-comment">// Put it on the queue of g&#x27;s waiting to run.</span><br><span class="hljs-comment">// The compiler turns a go statement into a call to this.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>gp := getg()<span class="hljs-comment">// 获取当前协程</span><br>pc := getcallerpc()<span class="hljs-comment">// 获取当前程序计数器</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 在系统栈上执行新 goroutine 的创建</span><br>newg := newproc1(fn, gp, pc)<span class="hljs-comment">// 创建新 goroutine</span><br><br>pp := getg().m.p.ptr()<span class="hljs-comment">// 获取当前 M 绑定的 P</span><br>runqput(pp, newg, <span class="hljs-literal">true</span>)<span class="hljs-comment">// 将新创建的 goroutine 放入 P 的本地队列中</span><br><br><span class="hljs-keyword">if</span> mainStarted &#123;<br>wakep()<span class="hljs-comment">// 如果主程序已经启动，则唤醒或启动一个 M，以确保新的 goroutine 有机会被执行</span><br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>重点来看一下 <code>newproc1()</code> 和 <code>runqput()</code>。</p><h3 id="创建协程-newproc1">创建协程 newproc1()</h3><p>这段代码的主要作用是创建一个新的 goroutine并设置其初始状态，以便它可以被调度器安排运行。它处理了从分配 goroutine的内存到设置其栈空间和调度信息等一系列步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个新的 goroutine，状态为 _Grunnable，从函数 fn 开始执行。</span><br><span class="hljs-comment">// callerpc 是创建此 goroutine 的 go 语句的地址。</span><br><span class="hljs-comment">// 调用者负责将新的 g 添加到调度器中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br><span class="hljs-keyword">if</span> fn == <span class="hljs-literal">nil</span> &#123;<br>fatal(<span class="hljs-string">&quot;go of nil func value&quot;</span>) <span class="hljs-comment">// 如果 fn 是 nil，抛出致命错误</span><br>&#125;<br><br>mp := acquirem() <span class="hljs-comment">// 禁用抢占，因为我们在局部变量中持有 M 和 P</span><br>pp := mp.p.ptr()<br>newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br><span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>&#125;<br><span class="hljs-keyword">if</span> newg.stack.hi == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;newproc1: newg missing stack&quot;</span>) <span class="hljs-comment">// 如果新的 g 没有栈，抛出异常</span><br>&#125;<br><br><span class="hljs-keyword">if</span> readgstatus(newg) != _Gdead &#123;<br>throw(<span class="hljs-string">&quot;newproc1: new g is not Gdead&quot;</span>) <span class="hljs-comment">// 确保新的 g 的状态为 _Gdead</span><br>&#125;<br><br>totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>*(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>prepGoExitFrame(sp)<br>spArg += sys.MinFrameSize<br>&#125;<br><br>memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched)) <span class="hljs-comment">// 清除调度器的内存</span><br>newg.sched.sp = sp <span class="hljs-comment">// 设置调度器的栈指针</span><br>newg.stktopsp = sp <span class="hljs-comment">// 设置栈顶指针</span><br><span class="hljs-comment">// 设置调度器的程序计数器，+PCQuantum 使得前一个指令在同一函数中</span><br>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <br>newg.sched.g = guintptr(unsafe.Pointer(newg)) <span class="hljs-comment">// 设置调度器的 g 指针</span><br>gostartcallfn(&amp;newg.sched, fn) <span class="hljs-comment">// 启动新的 g 执行函数 fn</span><br>newg.parentGoid = callergp.goid <span class="hljs-comment">// 设置新 g 的父 goroutine ID</span><br>newg.gopc = callerpc <span class="hljs-comment">// 设置新 g 的创建位置</span><br>newg.ancestors = saveAncestors(callergp) <span class="hljs-comment">// 保存祖先信息</span><br>newg.startpc = fn.fn <span class="hljs-comment">// 设置新 g 的起始函数地址</span><br><span class="hljs-keyword">if</span> isSystemGoroutine(newg, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 如果是系统 goroutine，增加计数</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> mp.curg != <span class="hljs-literal">nil</span> &#123;<br>newg.labels = mp.curg.labels <span class="hljs-comment">// 只有用户 goroutines 继承 pprof 标签</span><br>&#125;<br><span class="hljs-keyword">if</span> goroutineProfile.active &#123;<br>newg.goroutineProfiled.Store(goroutineProfileSatisfied) <span class="hljs-comment">// 标记不需要纳入 goroutine 分析</span><br>&#125;<br>&#125;<br>newg.trackingSeq = <span class="hljs-type">uint8</span>(fastrand()) <span class="hljs-comment">// 设置追踪序列号</span><br><span class="hljs-keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="hljs-number">0</span> &#123;<br>newg.tracking = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否启用追踪</span><br>&#125;<br>casgstatus(newg, _Gdead, _Grunnable) <span class="hljs-comment">// 将新 g 的状态从 _Gdead 改为 _Grunnable</span><br>gcController.addScannableStack(pp, <span class="hljs-type">int64</span>(newg.stack.hi-newg.stack.lo)) <span class="hljs-comment">// 将新 g 的栈添加到可扫描栈列表</span><br><br><span class="hljs-keyword">if</span> pp.goidcache == pp.goidcacheend &#123;<br>pp.goidcache = sched.goidgen.Add(_GoidCacheBatch) <span class="hljs-comment">// 分配新的 goroutine ID</span><br>pp.goidcache -= _GoidCacheBatch - <span class="hljs-number">1</span><br>pp.goidcacheend = pp.goidcache + _GoidCacheBatch<br>&#125;<br>newg.goid = pp.goidcache <span class="hljs-comment">// 设置新 g 的 ID</span><br>pp.goidcache++<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>newg.racectx = racegostart(callerpc) <span class="hljs-comment">// 设置竞态检测上下文</span><br>newg.raceignore = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> newg.labels != <span class="hljs-literal">nil</span> &#123;<br>racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync)) <span class="hljs-comment">// 同步竞态检测和信号处理</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoCreate(newg, newg.startpc) <span class="hljs-comment">// 记录追踪信息</span><br>&#125;<br>releasem(mp) <span class="hljs-comment">// 释放当前 M</span><br><br><span class="hljs-keyword">return</span> newg <span class="hljs-comment">// 返回新创建的 goroutine</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231623561.png"alt="newproc1() 函数概述" /><figcaption aria-hidden="true">newproc1() 函数概述</figcaption></figure><p>有几个地方比较有趣，我们可以来研究一下。</p><h4 id="获取-g">获取 g</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The minimum size of stack used by Go code</span><br>stackMin = <span class="hljs-number">2048</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>    newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>        casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>        allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>    &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看出，Go 语言每个新创建的协程分配的默认大小就是<code>stackMin</code>，即 <code>2KB</code>。</p><p>其实 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stack.go">statck.go</a>还定义了另外一个字段，即栈最大为 <code>2GB</code>，所以我们可以知道，Go协程栈大小 <code>[2KB, 2GB]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> maxstacksize <span class="hljs-type">uintptr</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">// enough until runtime.main sets it for real</span><br></code></pre></td></tr></table></figure><p>另外我们可以看出来，Go 语言会尽可能重用现有的空闲goroutine，以减少内存分配的开销，提供创建新 goroutine 的效率。</p><p>重用的具体逻辑在 <code>gfget(pp)</code> 中，这个函数的作用是从与当前M 绑定的 P 的空闲列表中获取一个空闲的g，如果没有，则尝试从全局空闲列表中获取 g。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get from gfree list.</span><br><span class="hljs-comment">// If local list is empty, grab a batch from global list.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gfget</span><span class="hljs-params">(pp *p)</span></span> *g &#123;<br>retry:<br>    <span class="hljs-comment">// 如果当前 P 的空闲队列为空，并且全局空闲队列中有可用的 goroutine，则进行下列操作。</span><br><span class="hljs-keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;<br>        <span class="hljs-comment">// 枷锁全局空闲列表</span><br>lock(&amp;sched.gFree.lock)<br><span class="hljs-comment">// 将最多 32 个空闲的 g 从全局列表中移动到当前 P 的空闲列表</span><br><span class="hljs-keyword">for</span> pp.gFree.n &lt; <span class="hljs-number">32</span> &#123;<br><span class="hljs-comment">// 优先选择有栈的 g</span><br>gp := sched.gFree.stack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 实在没有栈，也可以接受</span><br>gp = sched.gFree.noStack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>sched.gFree.n--<br>pp.gFree.push(gp)<br>pp.gFree.n++<br>&#125;<br>unlock(&amp;sched.gFree.lock)<br>        <span class="hljs-comment">// 一直尝试，知道 P 有空闲 g，或者全局列表也没有空闲 g 了，就退出 for 循环，进行下面的操作。</span><br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>    <br>    <span class="hljs-comment">// 从 P 的空闲列表中取出一个 g</span><br>gp := pp.gFree.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>pp.gFree.n--<br>    <br>    <span class="hljs-comment">// 检查获取到的 g 是否有一个有效的栈，如果栈不符合预期的大小，则释放旧栈</span><br><span class="hljs-keyword">if</span> gp.stack.lo != <span class="hljs-number">0</span> &amp;&amp; gp.stack.hi-gp.stack.lo != <span class="hljs-type">uintptr</span>(startingStackSize) &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>stackfree(gp.stack)<br>gp.stack.lo = <span class="hljs-number">0</span><br>gp.stack.hi = <span class="hljs-number">0</span><br>gp.stackguard0 = <span class="hljs-number">0</span><br>&#125;)<br>&#125;<br>    <span class="hljs-comment">// 如果 g 没有有效的栈，或者刚刚被释放了，则分配新栈给 g</span><br><span class="hljs-keyword">if</span> gp.stack.lo == <span class="hljs-number">0</span> &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gp.stack = stackalloc(startingStackSize)<br>&#125;)<br>gp.stackguard0 = gp.stack.lo + stackGuard<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> asanenabled &#123;<br>asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>startingStackSize</code> 表示新创建的 goroutine开始时的栈大小。它被初始化为 <code>fixedStack</code>的值。<code>startingStackSize</code>在每次垃圾回收（GC）后可能会更新，以反映在 GC过程中扫描的栈的平均大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> startingStackSize <span class="hljs-type">uint32</span> = fixedStack<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcComputeStartingStackSize</span><span class="hljs-params">()</span></span> &#123;<br>...<br>    <span class="hljs-comment">// 求出栈平均大小</span><br>avg := scannedStackSize/scannedStacks + stackGuard<br><br><span class="hljs-keyword">if</span> avg &gt; <span class="hljs-type">uint64</span>(maxstacksize) &#123;<br>avg = <span class="hljs-type">uint64</span>(maxstacksize)<br>&#125;<br><span class="hljs-keyword">if</span> avg &lt; fixedStack &#123;<br>avg = fixedStack<br>&#125;<br>    <span class="hljs-comment">// 更新 startingStackSize</span><br>startingStackSize = <span class="hljs-type">uint32</span>(round2(<span class="hljs-type">int32</span>(avg)))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化协程栈">初始化协程栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>    *(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>    prepGoExitFrame(sp)<br>    spArg += sys.MinFrameSize<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1. 计算额外的栈空间大小</strong>:</p><p><code>totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize)</code>这行代码计算新 goroutine 需要的额外栈空间大小。</p><p><code>4*goarch.PtrSize</code>是为了留出足够的空间来存储函数调用过程中的一些额外信息（例如返回地址、寄存器保存等）。</p><p><code>sys.MinFrameSize</code>：是系统为每个栈帧保留的最小空间，用于存储一些特定于架构的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MinFrameSize is the size of the system-reserved words at the bottom</span><br><span class="hljs-comment">// of a frame (just above the architectural stack pointer).</span><br><span class="hljs-comment">// It is zero on x86 and PtrSize on most non-x86 (LR-based) systems.</span><br><span class="hljs-comment">// On PowerPC it is larger, to cover three more reserved words:</span><br><span class="hljs-comment">// the compiler word, the link editor word, and the TOC save word.</span><br><span class="hljs-keyword">const</span> MinFrameSize = goarch.MinFrameSize<br></code></pre></td></tr></table></figure><p><code>goarch.PtrSize</code>：指针大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span><br><span class="hljs-comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span><br><span class="hljs-keyword">const</span> PtrSize = <span class="hljs-number">4</span> &lt;&lt; (^<span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>)<br></code></pre></td></tr></table></figure><p><strong>2. 栈空间对齐</strong>:</p><p><code>totalSize = alignUp(totalSize, sys.StackAlign)</code>:根据系统的栈对齐要求调整 <code>totalSize</code>的大小。栈对齐是为了确保栈上的数据按照硬件要求的边界对齐，这通常是为了提高访问效率或满足特定的硬件要求。</p><p><strong>3. 设置栈指针 (<code>sp</code>)</strong>:</p><p><code>sp := newg.stack.hi - totalSize</code>: 计算新 goroutine的栈顶指针。<code>newg.stack.hi</code> 是分配给这个 goroutine的栈的高地址（栈顶），从这里向下分配空间。通过从栈顶地址减去计算出的<code>totalSize</code>，设置新的栈顶位置。</p><p><strong>4. 处理链接寄存器（LR）架构</strong>:</p><p>在某些架构上（如ARM、PowerPC），函数调用的返回地址不是存储在栈上，而是存储在一个名为链接寄存器（LR）的特殊寄存器中。这几行代码检查是否在这种架构上运行(<code>usesLR</code>)。</p><ul><li>如果是，则在栈上的适当位置存储一个 0 值作为返回地址，并调用<code>prepGoExitFrame</code> 来准备 goroutine退出时的栈帧。这是为了模拟在非 LR 架构上的栈帧结构。</li><li><code>spArg</code>是一个辅助变量，用于记录参数传递时应该使用的栈地址。在 LR架构上，它需要根据 <code>sys.MinFrameSize</code>进行调整，以保证函数参数的正确位置。</li></ul><h3 id="放入队列-runqput">放入队列 runqput()</h3><p><code>runqput()</code> 负责将 goroutine (<code>gp</code>)放入到本地可运行队列或全局队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput 尝试将 g 放入当前的执行队列中</span><br><span class="hljs-comment">// 如果 next=false，则将 g 放在队列末尾，</span><br><span class="hljs-comment">// 如果 next=true，则将 g 放在 pp.runnext，即下一个要执行的 goroutine。</span><br><span class="hljs-comment">// 如果本地队列满了，则加入到全局队列。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果启用了随机调度器 (randomizeScheduler)，</span><br>    <span class="hljs-comment">// 并且调用者指示将 goroutine 放入 runnext 位置 (next 为 true)，</span><br>    <span class="hljs-comment">// 则有 50% 的概率将 next 设置为 false，以随机地将 goroutine 放入队列尾部。</span><br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>        <span class="hljs-comment">// 如果为 next，则尝试将 p 放入 pp.runnext 插槽</span><br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前没有被占用，则直接返回</span><br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前已经被占用了，则剔除旧 goroutine，</span><br>        <span class="hljs-comment">// 然后进行下面的逻辑，即将其放入常规的运行队列中</span><br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <span class="hljs-comment">// 取出队列头部</span><br>t := pp.runqtail<span class="hljs-comment">// 取出队列尾部</span><br>    <span class="hljs-comment">// 如果还没满，则将 gp 放入本地队列中（可能是新 g，也可能是之前在 runnext 的 g</span><br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <span class="hljs-comment">// store-release, makes the item available for consumption</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">// 如果本地队列满了，则尝试将其放入全局队列中</span><br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>runqputslow()</code> 不仅会尝试将 <code>gp</code>放入全局队列中，还会尝试将本地队列的部分 g放入全局队列中，因为这个时候本地队列已经满了，放入全局队列中就有机会被其他P 所调度，减少饥饿。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化一个数组 batch，大小为本地队列的一半，</span><br>    <span class="hljs-comment">// 它用来存储将要移动到全局队列的 goroutine。</span><br><span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br><br>n := t - h<br>n = n / <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 只有本地队列满才这么操作</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 将本地队列一半的 g 复制到 batch 中</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br>    <span class="hljs-comment">// CAS 更新本地队列头指针，如果失败，则返回</span><br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="hljs-comment">// cas-release, commits consume</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 将当前要调度的 gp 放入 batch 的末尾</span><br>batch[n] = gp<br><br>    <span class="hljs-comment">// 如果启动了随机调度器，则随机化 batch 数组</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 链接 goroutine，以便它们可以作为一个连续的队列被处理</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 将 batch 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231353833.png"alt="runqput() 函数概述" /><figcaption aria-hidden="true">runqput() 函数概述</figcaption></figure><h3 id="总结">总结</h3><p>到这里我们可以总结，<code>runtime·newproc</code>的核心功能就是初始化一个新的goroutine，并将其放入队列中进行调度。其中</p><ul><li><code>newproc1()</code> 会新建或复用空闲的goroutine，然后初始化其栈空间和调度信息；</li><li><code>runqput()</code> 会优先将 g放入本地队列中调度，如果本地队列满了，会连带本地队列中一半的 goroutine一起转移到全局队列中调度。</li></ul><h2 id="runtimemstart">runtime·mstart</h2><p>调度器 m0 和主协程 g0都初始化完毕了，这个时候就可以启动调度器来调度协程工作了。</p><p>我们找到 <code>mstart()</code> 函数的声明，位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mstart is the entry-point for new Ms.</span><br><span class="hljs-comment">// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>可以看到，这里 <code>mstart()</code>是没用函数体的，通过注释我们可以知道这个函数的实现部分是用汇编实现的，Go编译器会在编译的时候往这个函数里面插入相关指令。另外注释也告诉我们，这里最终其实就是调用<code>mstart0()</code> 函数。我们找到相关的汇编代码，果然是如此：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·mstart(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|TOPFRAME,$0</span><br><span class="hljs-title">CALLruntime·mstart0(SB)</span><br><span class="hljs-title">RET // not reached</span><br></code></pre></td></tr></table></figure><p><code>mstart0()</code> 就在 <code>mstart()</code> 的下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart0</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>osStack := gp.stack.lo == <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> osStack &#123;<br><span class="hljs-comment">// Initialize stack bounds from system stack.</span><br><span class="hljs-comment">// Cgo may have left stack size in stack.hi.</span><br><span class="hljs-comment">// minit may update the stack bounds.</span><br>size := gp.stack.hi<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br>size = <span class="hljs-number">8192</span> * sys.StackGuardMultiplier<br>&#125;<br>gp.stack.hi = <span class="hljs-type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))<br>gp.stack.lo = gp.stack.hi - size + <span class="hljs-number">1024</span><br>&#125;<br><span class="hljs-comment">// Initialize stack guard so that we can start calling regular</span><br><span class="hljs-comment">// Go code.</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br><span class="hljs-comment">// This is the g0, so we can also call go:systemstack</span><br><span class="hljs-comment">// functions, which check stackguard1.</span><br>gp.stackguard1 = gp.stackguard0<br>mstart1()<br><span class="hljs-comment">// Exit this thread.</span><br><span class="hljs-keyword">if</span> mStackIsSystemAllocated() &#123;<br><span class="hljs-comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span><br><span class="hljs-comment">// the stack, but put it in gp.stack before mstart,</span><br><span class="hljs-comment">// so the logic above hasn&#x27;t set osStack yet.</span><br>osStack = <span class="hljs-literal">true</span><br>&#125;<br>mexit(osStack)<br>&#125;<br></code></pre></td></tr></table></figure><p>简单过一下 <code>mstart0()</code> 后，我们会发现其实<code>mstart0()</code> 也不是关键，关键是 <code>mstart1()</code>。</p><p>我们先对 <code>mstart0()</code> 做一个简单的总结：它是 Go语言运行时中新M（操作系统线程）的入口点。这个函数负责初始化新线程的栈和一些其他设置，然后调用<code>mstart1</code> 来继续线程的初始化过程。</p><p>我们继续来看<code>mstart1()</code>，它用于进一步设置新线程并最终将控制权交给调度器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 获取当前协程</span><br>gp := getg()<br>    <span class="hljs-comment">// 只有 g0 协程可以执行 mstart1()，即启动 m0。</span><br>    <span class="hljs-comment">// 每一个 M 都有一个特殊的 goroutine，其被称为 g0，它用于执行系统级任务。</span><br><span class="hljs-keyword">if</span> gp != gp.m.g0 &#123;<br>throw(<span class="hljs-string">&quot;bad runtime·mstart&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置 gp.sched 调度信息，以便 goroutine 能够在未来被正确调度。</span><br>gp.sched.g = guintptr(unsafe.Pointer(gp))<span class="hljs-comment">// goroutine 指针</span><br>gp.sched.pc = getcallerpc()<span class="hljs-comment">// 程序计数器</span><br>gp.sched.sp = getcallersp()<span class="hljs-comment">// 栈指针</span><br><br>    <span class="hljs-comment">// 初始化于汇编相关的设置。</span><br>asminit()<br>    <span class="hljs-comment">// 初始化当前 M 的线程局部存储和其他线程相关的数据。</span><br>minit()<br><br><span class="hljs-comment">// 如果是 m0，则安装信号处理器</span><br><span class="hljs-keyword">if</span> gp.m == &amp;m0 &#123;<br>mstartm0()<br>&#125;<br><br>    <span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br><br>    <span class="hljs-comment">// 如果当前现场不是 m0（主线程），则获取一个 P，准备开始执行 goroutine</span><br><span class="hljs-keyword">if</span> gp.m != &amp;m0 &#123;<br>acquirep(gp.m.nextp.ptr())<br>gp.m.nextp = <span class="hljs-number">0</span><br>&#125;<br>    <span class="hljs-comment">// 调用 schedule() 将控制权交给调度器，开始执行 goroutine</span><br>schedule()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstartm0</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> (iscgo || GOOS == <span class="hljs-string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;<br>cgoHasExtraM = <span class="hljs-literal">true</span><br>newextram()<br>&#125;<br>    <span class="hljs-comment">// 安装信号处理器</span><br>initsig(<span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>schedule()</code> 是调度器的具体调度过程，这部分会在 GMP篇章进行展开（TODO 😁）。</p><p>注意这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>    fn()<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们提到 <code>runtime·newproc</code> 的时候，获取并设置了<code>runtime.main</code> 的函数地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br><span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br><span class="hljs-symbol">MOVQ</span>$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br><span class="hljs-symbol">PUSHQ</span>AX<br><span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br><span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br><span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br><span class="hljs-symbol">CALL</span>runtime·newproc(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">POPQ</span>AX<br></code></pre></td></tr></table></figure><p>所以这里其实就是调用<code>runtime.main()</code>，到这里，我们终于开始执行程序的主函数了。</p><h2 id="runtime.main">runtime.main ★</h2><p>终于我们到了 <code>runtime.main</code> 这个 Go 语言世界中 “真正”的主函数了，它位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The main goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取当前的 M</span><br>mp := getg().m<br><br>mp.g0.racectx = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 限制栈大小的上限，64 位系统为 1G，32 位系统为 250M</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">8</span> &#123;<br>maxstacksize = <span class="hljs-number">1000000000</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>maxstacksize = <span class="hljs-number">250000000</span><br>&#125;<br><br><span class="hljs-comment">// 这里就将栈的上限提升 2 倍，用于避免在分配过大的栈时崩溃。</span><br>    <span class="hljs-comment">// 所以其实 64 位系统最大栈 2G，32 位系统最大栈 500M。</span><br>maxstackceiling = <span class="hljs-number">2</span> * maxstacksize<br><br><span class="hljs-comment">// 将 mainStarted 置为 true，允许 newproc 启动新的 M。</span><br>mainStarted = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// WebAssemby 上暂时没有线程和系统监视器，所以这里过滤掉。</span><br><span class="hljs-keyword">if</span> GOARCH != <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>        <span class="hljs-comment">// 其他架构就启动系统监视器。</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>newm(sysmon, <span class="hljs-literal">nil</span>, <span class="hljs-number">-1</span>)<br>&#125;)<br>&#125;<br><br><span class="hljs-comment">// 在初始化期间将 g0 锁定在 m0 上。</span><br>lockOSThread()<br><br>    <span class="hljs-comment">// 只有 m0 可以运行 runtime.main</span><br><span class="hljs-keyword">if</span> mp != &amp;m0 &#123;<br>throw(<span class="hljs-string">&quot;runtime.main not on m0&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 记录 runtime 的开始时间，需要在 doInit() 之前，因为这样才把 init 也追踪上。</span><br>runtimeInitTime = nanotime()<br><span class="hljs-keyword">if</span> runtimeInitTime == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;nanotime returning zero&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 初始化 trace</span><br><span class="hljs-keyword">if</span> debug.inittrace != <span class="hljs-number">0</span> &#123;<br>inittrace.id = getg().goid<br>inittrace.active = <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 执行 runtime 的 init() 方法</span><br>doInit(runtime_inittasks) <span class="hljs-comment">// Must be before defer.</span><br>    <br><span class="hljs-comment">// defer 解锁，以便在初始化期间调用 runtime.Goexit 时也能解锁。</span><br>needUnlock := <span class="hljs-literal">true</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> needUnlock &#123;<br>unlockOSThread()<br>&#125;<br>&#125;()<br><br>    <span class="hljs-comment">// 启动垃圾回收期</span><br>gcenable()<br><br>    <span class="hljs-comment">// 监听初始化完成的信号</span><br>main_init_done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>    <br>    <span class="hljs-comment">// 如果使用 cgo，则进行相关的初始化</span><br><span class="hljs-keyword">if</span> iscgo &#123;<br>...<br>cgocall(_cgo_notify_runtime_init_done, <span class="hljs-literal">nil</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 执行所有模块的 init()</span><br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> activeModules() &#123;<br>doInit(m.inittasks)<br>&#125;<br><br><span class="hljs-comment">// 初始化任务都完成后，则禁用初始化 trace。</span><br>inittrace.active = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// 关闭初始化完成的信号通道</span><br><span class="hljs-built_in">close</span>(main_init_done)<br><br>    <span class="hljs-comment">// 解锁 m0 线程</span><br>needUnlock = <span class="hljs-literal">false</span><br>unlockOSThread()<br><br>    <span class="hljs-comment">// 以 -buildmode=(c-archive|c-shared) 方式进行构建程序的话，则不执行 main.main</span><br><span class="hljs-keyword">if</span> isarchive || islibrary &#123;<br><span class="hljs-comment">// A program compiled with -buildmode=c-archive or c-shared</span><br><span class="hljs-comment">// has a main, but it is not executed.</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 main.main() 函数，也就是我们自己写的 main()</span><br>fn := main_main <br>fn()  <span class="hljs-comment">// 如果我们启动了一个 server 服务，这里就会被阻塞住，直到我们的 main 返回。</span><br>    <br>    <span class="hljs-comment">// 静态检测输出</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>runExitHooks(<span class="hljs-number">0</span>) <span class="hljs-comment">// run hooks now, since racefini does not return</span><br>racefini()<br>&#125;<br><br><span class="hljs-comment">// 处理在 main 返回时同时存在的其他 goroutine 的 panic</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">1000</span>; c++ &#123;<br>            <span class="hljs-comment">// 执行 defer</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>Gosched()<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 阻塞 g0 的执行，直到所有的 panic 都处理完毕</span><br><span class="hljs-keyword">if</span> panicking.Load() != <span class="hljs-number">0</span> &#123;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonPanicWait, traceBlockForever, <span class="hljs-number">1</span>)<br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 hook 退出函数</span><br>runExitHooks(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 退出程序，0 表示正常退出</span><br>exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 理论上 exit(0) 应该退出程序的，</span><br>    <span class="hljs-comment">// 如果还没退出，使用 nil 指针强行赋值，引发崩溃，强行退出程序。</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> x *<span class="hljs-type">int32</span><br>*x = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，<code>runtime.main()</code> 干这么几件事：</p><ol type="1"><li>首先进行一些基本的设置和检查，包括设置栈大小限制和锁定主 goroutine到主 OS 线程。</li><li>然后，函数执行一系列初始化操作，包括启动垃圾回收器、处理 CGo交互、执行包的 init()。</li><li>在完成所有 init() 后，函数调用用户定义的 <code>main.main</code>函数。</li><li>最后，函数处理程序退出，包括执行 defer、等待 panic处理完成，并正式退出程序。</li></ol><p>所以这里我们就知道了为什么 <code>init()</code> 会在<code>main.main()</code> 之前被执行，而且如果一个 package在整个程序路径都没有被 import 的时候，<code>init()</code>是不会被执行的，就是因为 <code>runtime.main()</code> 只处理了<code>activeModules()</code> 的 <code>initTasks()</code>。</p><div class="note note-info">            <p>到这里，还有个遗留问题，开发时我们需要关注的 <code>init()</code> 和<code>main.main()</code>可以讨论过了，那全局变量的初始化是在哪里做的呢？</p><p>在 Go语言的编译过程中，全局变量的初始化主要发生在链接阶段。编译器首先编译每个包，生成对象文件。然后在链接阶段，编译器或链接器将这些对象文件合并成一个可执行文件。在这个过程中，编译器或链接器负责生成初始化全局变量的代码，并安排这些代码在程序启动时执行。</p><p>这些初始化代码通常嵌入在程序的启动序列中，确保在执行任何包级<code>init</code> 函数或用户定义的 <code>main</code>函数之前，所有全局变量已经被初始化。由于这些操作是编译器在内部执行的，它们不会直接显示在源代码或运行时代码中。</p>          </div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210232155964.png"alt="runtime.main 函数概述" /><figcaption aria-hidden="true">runtime.main 函数概述</figcaption></figure><hr /><p>至此，我们就分析完 Go语言程序的整个启动过程了。具体的启动流程总结，可以回到开头的 “结论先行”查看。</p><h2 id="参考">参考</h2><ul><li><ahref="https://coding.imooc.com/class/576.html">慕课网-深入Go底层原理</a></li><li>Go1.21.0 官方源码</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go1.21.0 程序编译过程</title>
    <link href="/2023/11/29/go-compilation/"/>
    <url>/2023/11/29/go-compilation/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Go 1.21</li></ul><h2 id="官方文档">官方文档</h2><p>Go 语言官方文档详细阐述了 Go 语言编译器的具体执行过程，Go1.21版本可以看这个：https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile</p><p>大致过程如下：</p><ol type="1"><li><strong>解析</strong> (<code>cmd/compile/internal/syntax</code>):<ul><li><strong>词法分析器和语法分析器</strong>：源代码被分词（词法分析）并解析（语法分析）。</li><li><strong>语法树构建</strong>：为每个源文件构建一个语法树。</li></ul></li><li><strong>类型检查</strong>(<code>cmd/compile/internal/types2</code>):<ul><li><strong>类型检查</strong>：<code>types2</code> 包是<code>go/types</code> 的一个移植版本，它使用 <code>syntax</code> 包的AST（抽象语法树）而不是 <code>go/ast</code>。</li></ul></li><li><strong>IR 构建（"noding"）</strong>:<ul><li><strong>编译器类型</strong>(<code>cmd/compile/internal/types</code>)</li><li><strong>编译器 AST</strong>(<code>cmd/compile/internal/ir</code>)</li><li><strong>AST 转换</strong>(<code>cmd/compile/internal/typecheck</code>)</li><li><strong>创建编译器 AST</strong>(<code>cmd/compile/internal/noder</code>)</li><li>这个阶段使用自己的 AST 定义和 Go 类型的表示，这些定义和表示形式是用C编写时遗留下来的。它的所有代码都是根据这些编写的，因此类型检查后的下一步是转换语法和<code>types2</code> 表示形式到 <code>ir</code> 和<code>types</code>。这个过程被称为“noding”。</li></ul></li><li><strong>中间阶段</strong>:<ul><li><strong>死代码消除</strong>(<code>cmd/compile/internal/deadcode</code>)</li><li><strong>函数调用内联</strong>(<code>cmd/compile/internal/inline</code>)</li><li><strong>已知接口方法调用的去虚拟化</strong>(<code>cmd/compile/internal/devirtualize</code>)</li><li><strong>逃逸分析</strong>(<code>cmd/compile/internal/escape</code>)</li><li>在 IR表示上执行几个优化过程：死代码消除、（早期的）去虚拟化、函数调用内联和逃逸分析。</li></ul></li><li><strong>Walk</strong> (<code>cmd/compile/internal/walk</code>):<ul><li><strong>求值顺序和语法糖</strong>：这是对 IR表示的最后一次遍历，它有两个目的：将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；将高级Go 构造转换为更原始的构造。</li></ul></li><li><strong>通用 SSA</strong> (<code>cmd/compile/internal/ssa</code> 和<code>cmd/compile/internal/ssagen</code>):<ul><li>在这个阶段，IR被转换为静态单赋值（SSA）形式，这是一种具有特定属性的低级中间表示，使得从中实现优化并最终生成机器代码变得更容易。</li></ul></li><li><strong>生成机器代码</strong> (<code>cmd/compile/internal/ssa</code>和 <code>cmd/internal/obj</code>):<ul><li>这是编译器的机器依赖阶段，以“lower”过程开始，将通用值重写为它们的机器特定变体。然后进行最终的代码优化过程。最后，Go函数被转换为一系列 <code>obj.Prog</code>指令，这些指令被汇编器（<code>cmd/internal/obj</code>）转换为机器代码，并写出最终的目标文件。</li></ul></li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img5eRkfKJ8cMojTjPoZzjr1i-20231129143006857.png"alt="Go编译器概览" /><figcaption aria-hidden="true">Go编译器概览</figcaption></figure><h2 id="编译过程">编译过程</h2><p>Go程序的编译过程符合经典编译原理的过程拆解，即三阶段编译器，分别为编译器前端、中端和后端：</p><ul><li><strong>前端（Front End）：</strong>前端的任务是进行语法分析和语义分析。这一阶段会将源代码转换为一个中间表示。在这个过程中，编译器会检查代码的语法和语义，比如语法错误、类型错误等。前端通常是依赖于具体语言的，比如Go 的前端和 C++ 的前端就会有很大的不同。</li><li><strong>中间端（Middle End）：</strong>中间端的任务是对中间表示进行优化。这一阶段的优化是语言无关的，比如常量折叠、死代码消除、循环优化等。这些优化可以提高生成的代码的性能，但是不会改变程序的语义。</li><li><strong>后端（Back End）：</strong>后端的任务是将优化后的中间表示转换为目标机器代码。这一阶段会进行更多的优化，比如寄存器分配、指令选择、指令调度等。后端通常是依赖于具体机器的，比如x86 的后端和 ARM 的后端就会有很大的不同。</li></ul><p>参考《Go 语言底层原理剖析（郑建勋）》一书，本文将 Go语言编译器执行流程拆分为以下几个阶段：</p><ul><li>词法解析</li><li>语法解析</li><li>抽象语法树构建</li><li>类型检查</li><li>死代码消除</li><li>去虚拟化</li><li>函数内联</li><li>逃逸分析</li><li>变量捕获</li><li>闭包重写</li><li>遍历函数</li><li>SSA 生成</li><li>机器码生成</li></ul><p>下面本文将以此书为参考并结合 Go1.21.0 版本，对每个过程进行阐述。</p><blockquote><p>如果只想对 Go程序的编译过程做一个简单的了解，那阅读到这里就已经足够了。</p></blockquote><h2 id="词法解析">词法解析</h2><p>词法解析过程主要负责将源代码中的字符序列转换成一系列的标记（tokens），这些标记是编译器更进一步处理的基本单位。在Go 语言的编译器中，<code>tokens.go</code>文件包含了与词法分析有关的标记定义。</p><p>词法解析的过程可以分为几个关键步骤：</p><ol type="1"><li><strong>扫描（Scanning）</strong>：编译器的扫描器会逐字符读取源代码，识别出基本的语法单位，如标识符、关键字、字面量、运算符等。</li><li><strong>标记生成（TokenGeneration）</strong>：每当扫描器识别出一个有效的语法单位时，它会生成一个相应的标记。例如，对于一个变量名，扫描器会生成一个标识符标记。</li><li><strong>去除空白字符和注释</strong>：在生成标记的过程中，扫描器还会忽略空白字符（如空格、换行符）和注释，因为它们对程序的逻辑没有影响。</li><li><strong>错误处理</strong>：如果扫描器在源代码中遇到无法识别的字符或序列，它会生成一个错误消息。</li></ol><p>我们来看以下 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/tokens.go">tokens.go</a>文件中的 <code>token</code> 定义，它们实质上是用 <code>iota</code>声明的一系列整数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_    token = <span class="hljs-literal">iota</span><br>_EOF       <span class="hljs-comment">// EOF</span><br><br><span class="hljs-comment">// names and literals</span><br>_Name    <span class="hljs-comment">// name</span><br>_Literal <span class="hljs-comment">// literal</span><br><br><span class="hljs-comment">// operators and operations</span><br><span class="hljs-comment">// _Operator is excluding &#x27;*&#x27; (_Star)</span><br>_IncOp    <span class="hljs-comment">// opop</span><br>    _Define   <span class="hljs-comment">// :=</span><br>    ...<br><br><span class="hljs-comment">// delimiters</span><br>_Lparen    <span class="hljs-comment">// (</span><br>_Rparen    <span class="hljs-comment">// )</span><br>...<br><br><span class="hljs-comment">// keywords</span><br>_Break       <span class="hljs-comment">// break</span><br>...<br><br><span class="hljs-comment">// empty line comment to exclude it from .String</span><br>tokenCount <span class="hljs-comment">//</span><br>)<br></code></pre></td></tr></table></figure><p>举个例子，<code>a := b + c(12)</code>这个表达式，被解析后，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202200135678.png"alt="Go 语言编译器词法解析示例图" /><figcaption aria-hidden="true">Go 语言编译器词法解析示例图</figcaption></figure><h2 id="语法解析">语法解析</h2><p>语法解析发生在词法解析之后，其主要目的是分析源代码中标记（tokens）的排列和结构，以确定它们是否形成了有效的语句。核心算法位于两个文件中：</p><ul><li><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/nodes.go">syntax/nodes.go</a>：定义了语法节点（SyntaxNodes），这些节点是构成抽象语法树（AST）的基本元素。每个节点代表了 Go语法中的一个构造，比如变量声明、函数调用、表达式等。通过这些节点，编译器能够理解和表示程序代码的结构。</li><li><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax/parser.go</a>：包含了解析器的实现。解析器负责读取词法分析阶段生成的标记流，并根据这些标记构建AST。它遵循 Go语言的语法规则，确保代码符合语法结构，并在遇到语法错误时提供相应的反馈。</li></ul><p>Go 语言采用了标准的自上而下的递归下降（Top-DownRecursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描。</p><p>下面我们来看下 <code>nodes.go</code>文件中对各个节点的声明（以下都省略了 struct 中的具体属性）：</p><h3 id="声明-declarations">声明 Declarations</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Decl <span class="hljs-keyword">interface</span> &#123;<br>Node<br>aDecl()<br>&#125;<br>ImportDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 导入声明</span><br>ConstDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 常量声明</span><br>TypeDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 类型声明</span><br>VarDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 变量声明</span><br>FuncDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 函数声明</span><br>)<br></code></pre></td></tr></table></figure><h3 id="表达式-expressions">表达式 Expressions</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Expr <span class="hljs-keyword">interface</span> &#123;<br>Node<br>typeInfo<br>aExpr()<br>&#125;<br><span class="hljs-comment">// 省略了结构体属性</span><br>BadExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 无效表达式</span><br>Name <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>BasicLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>CompositeLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Type &#123; ElemList[0], ElemList[1], ... &#125;</span><br>    KeyValueExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Key: Value</span><br>FuncLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// func Type &#123; Body &#125;</span><br>ParenExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// (X)</span><br>SelectorExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.Sel</span><br>IndexExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index]</span><br>SliceExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index[0] : Index[1] : Index[2]]</span><br>AssertExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.(Type)</span><br>TypeSwitchGuard <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Lhs := X.(type)</span><br>Operation <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 操作 +-*\</span><br>CallExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Fun(ArgList[0], ArgList[1], ...)</span><br>ListExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ElemList[0], ElemList[1], ...</span><br>ArrayType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// [Len]Elem</span><br>SliceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// []Elem</span><br>DotsType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ...Elem</span><br>StructType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// struct &#123; FieldList[0] TagList[0]; FieldList[1] TagList[1]; ... &#125;</span><br>Field <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Name Type</span><br>InterfaceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// interface &#123; MethodList[0]; MethodList[1]; ... &#125;</span><br>    FuncType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// type FuncName func (param1, param2) return1, return2</span><br>MapType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// map[Key]Value</span><br>ChanType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// chan Elem, &lt;-chan Elem, chan&lt;- Elem</span><br>)<br></code></pre></td></tr></table></figure><h3 id="语句-statements">语句 Statements</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>    <span class="hljs-comment">// 所有语句的通用接口</span><br>    Stmt <span class="hljs-keyword">interface</span> &#123;<br>       Node<br>       aStmt()<br>    &#125;<br><span class="hljs-comment">// 更加简单语句的通用接口</span><br>    SimpleStmt <span class="hljs-keyword">interface</span> &#123;&#125;<br><br>    EmptyStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 空语句</span><br>    LabeledStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 标签语句</span><br>    BlockStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 代码块语句</span><br>    ExprStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 表达式语句</span><br>    SendStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 发送语句，用于 channel</span><br>    DeclStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 声明语句</span><br>    AssignStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 赋值语句</span><br>    BranchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 分支语句，break, continue</span><br>    CallStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 调用语句</span><br>    ReturnStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 返回语句</span><br>    IfStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// if 条件语句</span><br>    ForStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// for 循环语句</span><br>    SwitchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// switch 语句</span><br>    SelectStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// select 语句</span><br>)<br></code></pre></td></tr></table></figure><p>我们可以重点来看一下最常用的赋值语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AssignStmt <span class="hljs-keyword">struct</span> &#123;<br>    Op       Operator <span class="hljs-comment">// 操作符 0 means no operation</span><br>    Lhs, Rhs Expr     <span class="hljs-comment">// 左右两个表达式 Rhs == nil means Lhs++ (Op == Add) or Lhs-- (Op == Sub)</span><br>    simpleStmt<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例">举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-keyword">type</span> String <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s String = <span class="hljs-string">&quot;hello &quot;</span> + word<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源代码会被解析成如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202195439495.png"alt="Go 编译器语法解析示例图" /><figcaption aria-hidden="true">Go 编译器语法解析示例图</figcaption></figure><p>再来看一个赋值语句是如何解析的，就以之前的<code>a := b + c(12)</code> 为例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003155036.png"alt="特定赋值语句的语法解析示例" /><figcaption aria-hidden="true">特定赋值语句的语法解析示例</figcaption></figure><h2 id="抽象语法树构建">抽象语法树构建</h2><p>编译器前端必须构建程序的中间表示形式，以便在编译器中端及后端使用，抽象语法树（AbstractSyntax Tree，AST）是一种常见的树状结构的中间态。</p><h3 id="抽象语法树">抽象语法树</h3><p>抽象语法树（AST，Abstract SyntaxTree）是源代码的树状结构表示，它用于表示编程语言的语法结构，但不包括所有语法细节。AST是编译器设计中的关键概念，广泛应用于编译器的各个阶段。</p><p>基本概念：</p><ul><li>结构：AST是一种树形结构，其中每个节点代表程序中的一种构造（如表达式、语句等）。</li><li>抽象性：它抽象出了代码的语法结构，省略了某些语法细节（如括号、特定的语法格式等）。</li></ul><p>节点类型：</p><ul><li>根节点：代表整个程序或一段完整代码。</li><li>内部节点：通常代表控制结构（如循环、条件语句）和操作符（如加、减、乘、除）。</li><li>叶节点：代表程序中的基本元素，如常量、变量和标识符。</li></ul><p>构建过程：</p><ul><li>词法分析：源代码首先经过词法分析，分解为一系列标记（tokens）。</li><li>语法分析：然后，基于这些标记，语法分析器根据编程语言的语法规则构建AST。</li><li>树的构建：在这个过程中，分析器会根据语言的语法创建不同类型的节点，并按照程序的结构将它们组织成树。</li></ul><p>使用场景：</p><ul><li>语义分析：编译器使用 AST 来进行类型检查和其他语义分析。</li><li>代码优化：在优化阶段，编译器会对 AST进行变换，以提高代码的执行效率。</li><li>代码生成：编译器根据 AST 生成中间代码或目标代码。</li></ul><p>优点：</p><ul><li>简化处理：由于省略了不必要的语法细节，AST使得编译器的设计更为简洁和高效。</li><li>灵活性：AST 可以轻松地进行修改和扩展，便于实现各种编译器功能。</li><li>可视化：AST的树形结构使得代码的逻辑结构一目了然，有助于理解和调试。</li></ul><h3 id="go-构建抽象语法树">Go 构建抽象语法树</h3><p>在 Go 语言源文件中的任何一种 Declarations 都是一个根节点，如下<code>pkgInit(decls)</code>函数将源文件中的所有声明语句都转换为节点（Node），代码位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/syntax.go">syntax/syntax.go</a>和 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax/parser.go</a>中。</p><h4 id="parse">Parse()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode)</span></span> (_ *File, first <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err, ok := p.(Error); ok &#123;<br>first = err<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-built_in">panic</span>(p)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> p parser<br>p.init(base, src, errh, pragh, mode)<br>p.next()<br><span class="hljs-keyword">return</span> p.fileOrNil(), p.first<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是对 <code>Parse()</code> 函数的一个简单解释：</p><ul><li>作用：解析单个 Go 源文件并返回相应的语法树。</li><li>参数<ul><li><code>base</code>: 位置基础信息。</li><li><code>src</code>: 要解析的源文件。</li><li><code>errh</code>: 错误处理函数。</li><li><code>pragh</code>: 用于处理每个遇到的编译指令（pragma）。</li><li><code>mode</code>: 解析模式。</li></ul></li><li>返回值：返回一个 <code>File</code> 类型的指针，表示解析后的AST，以及可能的错误。</li><li>错误处理<ul><li>如果 <code>errh</code>不为空：将会调用它处理每个遇到的错误，解析器尽可能多地处理源文件。此时，只有在没有找到正确的包声明时，返回的语法树才为<code>nil</code>。</li><li>如果 <code>errh</code>为空：解析器在遇到第一个错误时立即终止，返回的语法树为<code>nil</code>。</li></ul></li></ul><p>其中 <code>File</code> 类型结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>Pragma    Pragma <span class="hljs-comment">// 编译指令</span><br>PkgName   *Name  <span class="hljs-comment">// 包名</span><br>DeclList  []Decl <span class="hljs-comment">// 源文件中的各种声明</span><br>EOF       Pos <span class="hljs-comment">// 解析位置</span><br>GoVersion <span class="hljs-type">string</span> <span class="hljs-comment">// go 版本</span><br>node<span class="hljs-comment">// 该源文件的 AST 根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parser.fileornil">parser.fileOrNil()</h4><p>具体的解析过程在 <code>parser.fileOrNil()</code> 方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *parser)</span></span> fileOrNil() *File &#123;<br><span class="hljs-keyword">if</span> trace &#123;<br><span class="hljs-keyword">defer</span> p.trace(<span class="hljs-string">&quot;file&quot;</span>)()<br>&#125;<br><br>    <span class="hljs-comment">// 1. 初始化文件节点</span><br>f := <span class="hljs-built_in">new</span>(File)<br>f.pos = p.pos()<br><br><span class="hljs-comment">// 2. 解析包声明</span><br>f.GoVersion = p.goVersion<br>p.top = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> !p.got(_Package) &#123;<span class="hljs-comment">// 包声明必须放在第一位，这跟我们学 Go 语法对应上了</span><br>p.syntaxError(<span class="hljs-string">&quot;package statement must be first&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>f.Pragma = p.takePragma() <span class="hljs-comment">// 获取编译指令</span><br>f.PkgName = p.name()<span class="hljs-comment">// 获取包名</span><br>    p.want(_Semi) <span class="hljs-comment">// _Semi 在之前的 tokens.go 中可以发现是分号（;)，是的，包声明后面就是得带分号</span><br><br><span class="hljs-comment">// 3. 处理包声明错误</span><br><span class="hljs-keyword">if</span> p.first != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 4. 循环解析顶层声明</span><br>    <span class="hljs-comment">// 循环处理文件中的所有声明，包括 import、const、type、var 和 func</span><br>    <span class="hljs-comment">// 对每种类型的声明，调用其解析函数，如 importDecl、constDecl 进行解析</span><br>prev := _Import<br><span class="hljs-keyword">for</span> p.tok != _EOF &#123;<br><span class="hljs-keyword">if</span> p.tok == _Import &amp;&amp; prev != _Import &#123;<br>p.syntaxError(<span class="hljs-string">&quot;imports must appear before other declarations&quot;</span>)<br>&#125;<br>prev = p.tok<br><br><span class="hljs-keyword">switch</span> p.tok &#123;<br><span class="hljs-keyword">case</span> _Import:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.importDecl)<br><br><span class="hljs-keyword">case</span> _Const:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.constDecl)<br><br><span class="hljs-keyword">case</span> _Type:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)<br><br><span class="hljs-keyword">case</span> _Var:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.varDecl)<br><br><span class="hljs-keyword">case</span> _Func:<br>p.next()<br><span class="hljs-keyword">if</span> d := p.funcDeclOrNil(); d != <span class="hljs-literal">nil</span> &#123;<br>f.DeclList = <span class="hljs-built_in">append</span>(f.DeclList, d)<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>             <span class="hljs-comment">// 5. 处理异常和错误</span><br><span class="hljs-keyword">if</span> p.tok == _Lbrace &amp;&amp; <span class="hljs-built_in">len</span>(f.DeclList) &gt; <span class="hljs-number">0</span> &amp;&amp; isEmptyFuncDecl(f.DeclList[<span class="hljs-built_in">len</span>(f.DeclList)<span class="hljs-number">-1</span>]) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;unexpected semicolon or newline before &#123;&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.syntaxError(<span class="hljs-string">&quot;non-declaration statement outside function body&quot;</span>)<br>&#125;<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Reset p.pragma BEFORE advancing to the next token (consuming &#x27;;&#x27;)</span><br><span class="hljs-comment">// since comments before may set pragmas for the next function decl.</span><br>p.clearPragma()<br><br><span class="hljs-keyword">if</span> p.tok != _EOF &amp;&amp; !p.got(_Semi) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;after top level declaration&quot;</span>)<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 6. 完成解析，记录文件结束的位置</span><br>p.clearPragma()<br>f.EOF = p.pos()<br><br><span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>parser.fileOrNil()</code> 方法的处理过程大致如下：</p><ol type="1"><li><strong>初始化文件节点</strong>：<ul><li><code>f := new(File)</code>: 创建一个新的 <code>File</code>节点。</li><li><code>f.pos = p.pos()</code>: 设置节点的位置信息。</li></ul></li><li><strong>解析包声明（Package Clause）</strong>：<ul><li><code>f.GoVersion = p.goVersion</code>: 记录 Go 版本。</li><li><code>p.top = false</code>: 设置状态，表示不再处于文件顶层。</li><li><code>if !p.got(_Package) &#123;...&#125;</code>:检查是否存在包声明，如果没有，则报错并返回 <code>nil</code>。</li><li><code>f.Pragma = p.takePragma()</code>:获取与包声明相关的编译指令。</li><li><code>f.PkgName = p.name()</code>: 获取包名。</li><li><code>p.want(_Semi)</code>: 确认包声明后有分号。</li></ul></li><li><strong>处理包声明错误</strong>：<ul><li><code>if p.first != nil &#123;...&#125;</code>: 如果已有错误，停止解析并返回<code>nil</code>。</li></ul></li><li><strong>解析顶层声明</strong>：<ul><li>通过一个循环处理文件中的所有声明，包括导入（import）、常量（const）、类型（type）、变量（var）和函数（func）。</li><li>对每种类型的声明，调用相应的解析函数（如<code>p.importDecl</code>、<code>p.constDecl</code> 等）。</li><li>将解析得到的声明添加到 <code>f.DeclList</code> 中。</li></ul></li><li><strong>处理异常和错误</strong>：<ul><li>在解析过程中遇到的任何不符合语法的情况都会触发错误处理。</li><li>使用 <code>p.syntaxError</code> 报告语法错误。</li><li>使用 <code>p.advance</code>在遇到错误时跳过一些标记，以尝试恢复到一个已知的稳定状态。</li></ul></li><li><strong>完成解析</strong>：<ul><li>当遇到文件结束标记（EOF）时，完成解析。</li><li><code>f.EOF = p.pos()</code>: 记录文件结束的位置。</li><li>返回构建的 <code>File</code> 节点。</li></ul></li></ol><h3 id="op-字段">Op 字段</h3><p>AST 每个节点都包含了当前节点属性的 Op 字段，定义在<code>ir/node.go</code> 中，以 O 开头。与词法解析阶段中的 token相同的是，Op 字段也是一个整数。不同的是，每个 Op字段都包含了语义信息。例如，当一个节点的 Op 操作为 OAS时，该节点代表的语义为 Left := Right，而当节点的操作为 OAS2时，代码的语义为 x,y,z = a,b,c。</p><p>这里仅展示部分 Op 字段的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Op <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// Node ops.</span><br><span class="hljs-keyword">const</span> (<br>OXXX Op = <span class="hljs-literal">iota</span><br><br><span class="hljs-comment">// names</span><br>ONAME <span class="hljs-comment">// var or func name</span><br><span class="hljs-comment">// Unnamed arg or return value: f(int, string) (int, error) &#123; etc &#125;</span><br><span class="hljs-comment">// Also used for a qualified package identifier that hasn&#x27;t been resolved yet.</span><br>ONONAME<br>OTYPE    <span class="hljs-comment">// type name</span><br>OLITERAL <span class="hljs-comment">// literal</span><br>ONIL     <span class="hljs-comment">// nil</span><br><br><span class="hljs-comment">// expressions</span><br>OADD          <span class="hljs-comment">// X + Y</span><br>...<br><span class="hljs-comment">// X = Y or (if Def=true) X := Y</span><br><span class="hljs-comment">// If Def, then Init includes a DCL node for X.</span><br>OAS<br><span class="hljs-comment">// Lhs = Rhs (x, y, z = a, b, c) or (if Def=true) Lhs := Rhs</span><br><span class="hljs-comment">// If Def, then Init includes DCL nodes for Lhs</span><br>OAS2<br>...<br>    <br>    <span class="hljs-comment">// statements</span><br>    OLABEL    <span class="hljs-comment">// Label:</span><br>    ...<br>OEND<br>)<br></code></pre></td></tr></table></figure><p>以前面举例的赋值语句 <code>a := b + c(12)</code>为例，该赋值语句最终会编程如下图所示的抽象语法树，节点之间具有从上到下的层次结构和依赖关系。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003058976.png"alt="抽象语法树示例图" /><figcaption aria-hidden="true">抽象语法树示例图</figcaption></figure><h2 id="类型检查">类型检查</h2><p>完成 AST的初步构建后，就进入类型检查阶段遍历节点树并决定节点的类型。具体的代码在<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/types2/check.go">types2/check,go</a>。</p><h3 id="checker.checkfiles">checker.CheckFiles()</h3><p>其中最核心的方法就是 <code>checker.CheckFiles()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> checkFiles(files []*syntax.File) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 1. 不检查 unsafe 包</span><br><span class="hljs-keyword">if</span> check.pkg == Unsafe &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 2. 检查 go 版本</span><br>check.version, err = parseGoVersion(check.conf.GoVersion)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> check.version.after(version&#123;<span class="hljs-number">1</span>, goversion.Version&#125;) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;package requires newer Go version %v&quot;</span>, check.version)<br>&#125;<br><span class="hljs-keyword">if</span> check.conf.FakeImportC &amp;&amp; check.conf.go115UsesCgo &#123;<br><span class="hljs-keyword">return</span> errBadCgo<br>&#125;<br><br>    <span class="hljs-comment">// 3. 错误处理</span><br><span class="hljs-keyword">defer</span> check.handleBailout(&amp;err)<br><br>    <span class="hljs-comment">// 4. 详细检查每个地方</span><br><span class="hljs-built_in">print</span> := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> check.conf.Trace &#123;<br>fmt.Println()<br>fmt.Println(msg)<br>&#125;<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initFiles ==&quot;</span>)<br>check.initFiles(files)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== collectObjects ==&quot;</span>)<br>check.collectObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== packageObjects ==&quot;</span>)<br>check.packageObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== processDelayed ==&quot;</span>)<br>check.processDelayed(<span class="hljs-number">0</span>) <span class="hljs-comment">// incl. all functions</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== cleanup ==&quot;</span>)<br>check.cleanup()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initOrder ==&quot;</span>)<br>check.initOrder()<br><span class="hljs-keyword">if</span> !check.conf.DisableUnusedImportCheck &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== unusedImports ==&quot;</span>)<br>check.unusedImports()<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== recordUntyped ==&quot;</span>)<br>check.recordUntyped()<br><span class="hljs-keyword">if</span> check.firstErr == <span class="hljs-literal">nil</span> &#123;<br>check.monomorph()<br>&#125;<br>check.pkg.goVersion = check.conf.GoVersion<br>check.pkg.complete = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 5. 更新和清理</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.pkgPathMap = <span class="hljs-literal">nil</span><br>check.seenPkgMap = <span class="hljs-literal">nil</span><br>check.recvTParamMap = <span class="hljs-literal">nil</span><br>check.brokenAliases = <span class="hljs-literal">nil</span><br>check.unionTypeSets = <span class="hljs-literal">nil</span><br>check.ctxt = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.checkFiles()</code> 的过程大致如下：</p><ol type="1"><li><strong>检查特殊包</strong>：如果是 <code>Unsafe</code>包，则直接返回，因为它不能进行类型检查且不应被修改。</li><li><strong>解析Go版本</strong>：根据配置解析 Go版本，并进行兼容性检查。</li><li><strong>错误处理</strong>：设置一个延迟函数来处理任何可能出现的错误。</li><li><strong>类型检查的步骤</strong>：<ul><li><code>initFiles</code>: 初始化文件。</li><li><code>collectObjects</code>: 收集对象。</li><li><code>packageObjects</code>: 打包对象。</li><li><code>processDelayed</code>: 处理延迟的任务（包括所有函数）。</li><li><code>cleanup</code>: 清理。</li><li><code>initOrder</code>: 初始化顺序。</li><li><code>unusedImports</code>: 检查未使用的导入。</li><li><code>recordUntyped</code>: 记录未定类型。</li><li><code>monomorph</code>: 如果没有错误，进行单态化处理。</li></ul></li><li><strong>更新和清理</strong>：<ul><li>更新包的 Go 版本和完成状态。</li><li>清理不再需要的内部数据结构，释放内存。</li></ul></li><li><strong>返回</strong>：函数完成类型检查并返回。</li></ol><p>可以看出具体的检查步骤都封装在第 4点的各个函数中，其实检查的东西我们学习 Go语言时所需要掌握的那些语法，我们以 <code>initFiles</code>为例子来分析一下，对于其他检查函数，你有兴趣的话也可以了解一下，这里推荐将函数源代码拷贝发给<strong>ChatGPT-4</strong>，相信对你会有很大的帮助。</p><h3 id="checker.initfiles">checker.initFiles()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initFiles 初始化与文件相关的类型检查器</span><br><span class="hljs-comment">// 参数中的 files 必须都属于同一个 package</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> initFiles(files []*syntax.File) &#123;<br><span class="hljs-comment">// 1. 初始化</span><br>check.files = <span class="hljs-literal">nil</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.firstErr = <span class="hljs-literal">nil</span><br>check.methods = <span class="hljs-literal">nil</span><br>check.untyped = <span class="hljs-literal">nil</span><br>check.delayed = <span class="hljs-literal">nil</span><br>check.objPath = <span class="hljs-literal">nil</span><br>check.cleaners = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 2. 确定包名和有效文件</span><br>pkg := check.pkg<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br><span class="hljs-keyword">switch</span> name := file.PkgName.Value; pkg.name &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:<br><span class="hljs-keyword">if</span> name != <span class="hljs-string">&quot;_&quot;</span> &#123;<br>pkg.name = name<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>check.<span class="hljs-type">error</span>(file.PkgName, BlankPkgName, <span class="hljs-string">&quot;invalid package name _&quot;</span>)<br>&#125;<br><span class="hljs-keyword">fallthrough</span><br><br><span class="hljs-keyword">case</span> name:<br>check.files = <span class="hljs-built_in">append</span>(check.files, file)<br><br><span class="hljs-keyword">default</span>:<br>check.errorf(file, MismatchedPkgName, <span class="hljs-string">&quot;package %s; expected %s&quot;</span>, name, pkg.name)<br><span class="hljs-comment">// ignore this file</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 3. 对每个文件，解析其中指定的 Go 版本</span><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> check.files &#123;<br>v, _ := parseGoVersion(file.GoVersion)<br><span class="hljs-keyword">if</span> v.major &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> v.equal(check.version) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Go 1.21 introduced the feature of setting the go.mod</span><br><span class="hljs-comment">// go line to an early version of Go and allowing //go:build lines</span><br><span class="hljs-comment">// to “upgrade” the Go version in a given file.</span><br><span class="hljs-comment">// We can do that backwards compatibly.</span><br><span class="hljs-comment">// Go 1.21 also introduced the feature of allowing //go:build lines</span><br><span class="hljs-comment">// to “downgrade” the Go version in a given file.</span><br><span class="hljs-comment">// That can&#x27;t be done compatibly in general, since before the</span><br><span class="hljs-comment">// build lines were ignored and code got the module&#x27;s Go version.</span><br><span class="hljs-comment">// To work around this, downgrades are only allowed when the</span><br><span class="hljs-comment">// module&#x27;s Go version is Go 1.21 or later.</span><br><span class="hljs-comment">// If there is no check.version, then we don&#x27;t really know what Go version to apply.</span><br><span class="hljs-comment">// Legacy tools may do this, and they historically have accepted everything.</span><br><span class="hljs-comment">// Preserve that behavior by ignoring //go:build constraints entirely in that case.</span><br><span class="hljs-keyword">if</span> (v.before(check.version) &amp;&amp; check.version.before(version&#123;<span class="hljs-number">1</span>, <span class="hljs-number">21</span>&#125;)) || check.version.equal(version&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> check.posVers == <span class="hljs-literal">nil</span> &#123;<br>check.posVers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*syntax.PosBase]version)<br>&#125;<br>check.posVers[base(file.Pos())] = v<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.initFiles()</code> 方法的大致流程如下：</p><ol type="1"><li><strong>初始化状态</strong>：清空 <code>Checker</code>结构体中与文件相关的多个字段，如 <code>files</code>,<code>imports</code>, <code>dotImportMap</code>等，为新的检查过程做准备。</li><li><strong>确定包名和有效文件</strong>：<ul><li>遍历提供的文件，确定包名，并收集有效的文件。</li><li>如果文件的包名与 <code>Checker</code>中的包名不匹配，则报错并忽略该文件。</li></ul></li><li><strong>处理Go版本</strong>：<ul><li>对每个文件，解析其中指定的 Go 版本。</li><li>处理 Go 版本的兼容性和升级逻辑，尤其是在 Go 1.21 引入的一些特性，如<code>//go:build</code> 行的处理。</li></ul></li></ol><p>可以看到 Go 语言开发团队在这里写了一大段关于 Go1.21的注释，这段注释描述了 Go 1.21 版本引入的关于 Go版本设置的两个新特性,这里简单解释一下：</p><ol type="1"><li><strong>升级 Go 版本的特性</strong>：在 Go 1.21 版本中，可以在<code>go.mod</code> 文件里设置一个较旧的Go版本，同时允许在源文件中通过<code>//go:build</code> 行来指定一个更高的 Go版本。这样做可以向后兼容，即允许旧版本代码在新版本的 Go环境中运行。</li><li><strong>降级 Go 版本的限制</strong>：Go 1.21 也允许通过<code>//go:build</code> 行来降低源文件中的 Go版本。但这通常不是向后兼容的，因为在以前，<code>//go:build</code>行被忽略，代码总是使用模块定义的 Go 版本。为了避免兼容性问题，仅当模块的Go 版本为 1.21 或更高时，才允许这种降级。</li></ol><p><strong>未指定版本的情况</strong>：如果没有明确指定<code>check.version</code>，编译器就不确定应该使用哪个 Go版本。为了保持与旧工具的兼容，如果没有明确的版本约束，编译器将忽略<code>//go:build</code> 行的限制。</p><h2 id="死代码消除">死代码消除</h2><p>类型检查阶段完成后，编译器前端工作基本完成，后面就进入中端了。这个阶段Go 语言编译器将对 AST 进行分析和重构，从而完成一系列优化。</p><p>第一部分是死代码消除（dead codeelimination），过程识别并移除不会在运行时执行的代码。这包括未使用的变量、函数、常量等。通过删除这些无用代码片段，可以减小最终程序的大小并提高运行效率。</p><p>这部分的代码在：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/deadcode/deadcode.go">deadcode/deadcode.go</a>。打开代码文件，可以看到核心就是<code>Func()</code> 和 <code>stmt()</code> 这 2 个函数。</p><h3 id="func">Func()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Func</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 对函数体进行预处理</span><br>stmts(&amp;fn.Body)<br><br>    <span class="hljs-comment">// 2. 空函数体直接返回</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 3. 遍历函数体，对其中每个节点进行处理</span><br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> fn.Body &#123;<br>        <span class="hljs-comment">// 节点有任何初始化操作，则不可消除，提前返回。</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>            <span class="hljs-comment">// 如果 if 语句判断条件不是常量，或者 if else 中的 body 不为空，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || <span class="hljs-built_in">len</span>(n.Body) &gt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(n.Else) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>            <span class="hljs-comment">// 如果 for 循环条件不是常量或一直为真，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || ir.BoolVal(n.Cond) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 4. 标记隐藏闭包为死代码</span><br>ir.VisitList(fn.Body, markHiddenClosureDead)<br>    <span class="hljs-comment">// 5. 重置函数体，替换为一个空语句，进行清理和优化</span><br>fn.Body = []ir.Node&#123;ir.NewBlockStmt(base.Pos, <span class="hljs-literal">nil</span>)&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li><strong>语句处理（<code>stmts(&amp;fn.Body)</code>）</strong>：对函数体中的语句进行预处理或转换，以便于后续的分析和优化。</li><li><strong>空函数体直接返回</strong>：如果函数体为空，没有任何代码需要执行，因此函数直接返回。这是一种优化，避免对空函数体进行不必要的分析。</li><li><strong>遍历函数体</strong>:<ul><li><strong>节点初始化检查</strong>：如果任何节点有初始化操作，意味着可能存在副作用或必要的代码执行，因此函数提前返回。</li><li><code>If</code> 和 <code>For</code> 语句特殊处理<ul><li><code>ir.OIF</code>：如果 <code>If</code>语句的条件不是常量布尔值，或者 <code>If</code> 语句有非空的 body 或 else分支，则提前返回，因为这些分支可能包含重要的代码。</li><li><code>ir.OFOR</code>：对于 <code>For</code>循环，如果条件不是常量布尔值或者布尔值为真，意味着循环可能执行，因此提前返回。</li></ul></li></ul></li><li><strong>标记隐藏闭包为死代码（<code>markHiddenClosureDead</code>）</strong>：如果所有节点都不触发提前返回，意味着整个函数体可能没有有效的代码执行。此时，将隐藏的闭包标记为死代码，可能是为了进一步的优化处理，如移除这些代码。</li><li><strong>重置函数体</strong>：最后，将函数体替换为一个空的新块语句，这表明原始的函数体被认为是无效的或不会被执行，从而进行了代码的清理和优化。</li></ol><h3 id="stmt">stmt()</h3><p>这个函数的目的是通过分析和简化控制流结构，来识别和移除那些在程序执行中永远不会到达的代码部分。这样的优化可以减少编译后的代码量，并提高程序运行时的效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stmts</span><span class="hljs-params">(nn *ir.Nodes)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 标记最后一个标签，其对应的 Op 字段就是 OLABEL</span><br><span class="hljs-keyword">var</span> lastLabel = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &amp;&amp; n.Op() == ir.OLABEL &#123;<br>lastLabel = i<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 处理 if 和 switch 语句</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br>cut := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> n.Op() == ir.OIF &#123;<br>n := n.(*ir.IfStmt)<br>n.Cond = expr(n.Cond)<br>             <span class="hljs-comment">// if 语句根据条件是否为常量来保留和移除分支</span><br><span class="hljs-keyword">if</span> ir.IsConst(n.Cond, constant.Bool) &#123;<br><span class="hljs-keyword">var</span> body ir.Nodes<br><span class="hljs-keyword">if</span> ir.BoolVal(n.Cond) &#123;<br>ir.VisitList(n.Else, markHiddenClosureDead)<br>n.Else = ir.Nodes&#123;&#125;<br>body = n.Body<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ir.VisitList(n.Body, markHiddenClosureDead)<br>n.Body = ir.Nodes&#123;&#125;<br>body = n.Else<br>&#125;<br>                 <span class="hljs-comment">// 如果 then 或 else 分支以 panic 或 return 语句结束，那么可以安全地移除该节点之后的所有语句。</span><br>                 <span class="hljs-comment">// 这是因为 panic 或 return 会导致函数终止，后续的代码永远不会被执行。</span><br>                 <span class="hljs-comment">// 同时，注释提到要避免移除标签（labels），因为它们可能是 goto 语句的目标，</span><br>                 <span class="hljs-comment">// 而且为了避免 goto 相关的复杂性，没有使用 isterminating 标记。</span><br>                 <span class="hljs-comment">// might be the target of a goto. See issue 28616.</span><br><span class="hljs-keyword">if</span> body := body; <span class="hljs-built_in">len</span>(body) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">switch</span> body[(<span class="hljs-built_in">len</span>(body) - <span class="hljs-number">1</span>)].Op() &#123;<br><span class="hljs-keyword">case</span> ir.ORETURN, ir.OTAILCALL, ir.OPANIC:<br><span class="hljs-keyword">if</span> i &gt; lastLabel &#123;<br>cut = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 尝试简化 switch 语句，根据条件值决定哪个分支始终被执行</span><br><span class="hljs-keyword">if</span> n.Op() == ir.OSWITCH &#123;<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &amp;&amp; n.Tag.Op() == ir.OTYPESW &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// no special type-switch case yet.</span><br>&#125;<br><span class="hljs-keyword">var</span> x constant.Value <span class="hljs-comment">// value we&#x27;re switching on</span><br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(n.Tag) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>x = n.Tag.Val()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>x = constant.MakeBool(<span class="hljs-literal">true</span>) <span class="hljs-comment">// switch &#123; ... &#125;  =&gt;  switch true &#123; ... &#125;</span><br>&#125;<br><span class="hljs-keyword">var</span> def *ir.CaseClause<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cas.List) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// default case</span><br>def = cas<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cas.List &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(c) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// can&#x27;t statically tell if it matches or not - give up.</span><br>&#125;<br><span class="hljs-keyword">if</span> constant.Compare(x, token.EQL, c.Val()) &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> cas.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// This switch entry is the one that always triggers.</span><br><span class="hljs-keyword">for</span> _, cas2 := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">for</span> _, c2 := <span class="hljs-keyword">range</span> cas2.List &#123;<br>ir.Visit(c2, markHiddenClosureDead)<br>&#125;<br><span class="hljs-keyword">if</span> cas2 != cas &#123;<br>ir.VisitList(cas2.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Rewrite to switch &#123; case true: ... &#125;</span><br>n.Tag = <span class="hljs-literal">nil</span><br>cas.List[<span class="hljs-number">0</span>] = ir.NewBool(c.Pos(), <span class="hljs-literal">true</span>)<br>cas.List = cas.List[:<span class="hljs-number">1</span>]<br>n.Cases[<span class="hljs-number">0</span>] = cas<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> def != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> def.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> cas != def &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br>n.Cases[<span class="hljs-number">0</span>] = def<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle case bodies ending with panic/return as we do in the IF case above.</span><br><br><span class="hljs-comment">// entire switch is a nop - no case ever triggers</span><br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>n.Cases = n.Cases[:<span class="hljs-number">0</span>]<br>&#125;()<br>&#125;<br><br>        <span class="hljs-comment">// 3. 对节点的初始化语句递归调用 stmt 函数进行处理</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) != <span class="hljs-number">0</span> &#123;<br>stmts(n.(ir.InitNode).PtrInit())<br>&#125;<br>        <span class="hljs-comment">// 4. 遍历其他控制结构，递归处理它们的内部语句</span><br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OBLOCK:<br>n := n.(*ir.BlockStmt)<br>stmts(&amp;n.List)<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>stmts(&amp;n.Body)<br>stmts(&amp;n.Else)<br><span class="hljs-keyword">case</span> ir.ORANGE:<br>n := n.(*ir.RangeStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OSELECT:<br>n := n.(*ir.SelectStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br><span class="hljs-keyword">case</span> ir.OSWITCH:<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 5. 如果确定了是可以消除的代码，则对函数体进行阶段，且标记其中的闭包为死代码</span><br><span class="hljs-keyword">if</span> cut &#123;<br>ir.VisitList((*nn)[i+<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(*nn)], markHiddenClosureDead)<br>*nn = (*nn)[:i+<span class="hljs-number">1</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>标记最后一个标签</strong>：遍历所有节点，记录最后一个标签（<code>OLABEL</code>）的位置。这对于后面判断是否可以安全地移除代码非常重要。</li><li><strong>处理 <code>if</code> 和 <code>switch</code> 语句</strong>：<ul><li>对于 <code>if</code>语句，它根据条件是否为常量来决定保留哪个分支，移除另一个分支。</li><li>对于 <code>switch</code> 语句，它尝试简化<code>switch</code>，根据条件值决定哪个分支将始终被执行。</li></ul></li><li><strong>节点初始化</strong>：如果节点有初始化语句，对这些初始化语句递归调用<code>stmts</code> 函数。</li><li><strong>遍历其他控制结构</strong>：对于<code>for</code>、<code>if</code>、<code>range</code>、<code>select</code>和 <code>switch</code> 等控制结构，递归地处理它们的内部语句。</li><li><strong>消除死代码</strong>：如果判断一个节点之后的所有代码都是无效的，它会标记这些代码为死代码并截断函数体。</li></ol><h2 id="去虚拟化">去虚拟化</h2><p>去虚拟化（Devirtualization）是编译器优化的一种技术，用于提高面向对象程序的性能。在面向对象编程中，方法调用通常是通过虚拟函数表（vtable）动态解析的，这被称为虚拟调用。虚拟调用允许对象在运行时表现出多态行为，但这也带来了一定的性能开销。</p><p>去虚拟化的目的是在编译时静态确定方法调用的目标，从而避免运行时的动态查找。如果编译器能够确定一个特定的接口调用总是调用同一个方法，它可以将这个虚拟调用替换为直接调用，减少运行时开销。这种优化特别适用于那些调用目标不会因为程序执行的不同路径而改变的情况。</p><p>这部分的代码在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/devirtualize/devirtualize.go">devirtuailze/devirtualize.go</a>。</p><p>核心就 2 个函数：</p><ul><li><code>Static()</code> ：遍历函数中的所有节点，尤其注意跳过在<code>go</code> 或 <code>defer</code>语句中的调用，并对其他接口方法调用尝试进行静态去虚拟化优化。</li><li><code>staticCall()</code>：针对一个具体的接口方法调用，如果可能，将其替换为直接的具体类型方法调用，以优化性能。</li></ul><h3 id="static">Static()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Static</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>ir.CurFunc = fn<br>goDeferCall := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ir.CallExpr]<span class="hljs-type">bool</span>)<br>    <span class="hljs-comment">// 1. VisitList 对 fn.Body 中所有节点调用后面的 func</span><br>ir.VisitList(fn.Body, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n ir.Node)</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := n.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-comment">// 2. 跳过 go 和 defer 语句</span><br><span class="hljs-keyword">case</span> *ir.GoDeferStmt:<br><span class="hljs-keyword">if</span> call, ok := n.Call.(*ir.CallExpr); ok &#123;<br>goDeferCall[call] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 3. 调用 staticCall 尝试进行去虚拟化</span><br><span class="hljs-keyword">case</span> *ir.CallExpr:<br><span class="hljs-keyword">if</span> !goDeferCall[n] &#123;<br>staticCall(n)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>设定当前函数为 <code>fn</code>。</li><li>遍历函数体内的节点，特别注意 <code>go</code> 和 <code>defer</code>语句。如果调用发生在这些语句中，它会被跳过，因为去虚拟化可能改变程序的语义。</li><li>对于不在 <code>go</code> 或 <code>defer</code>语句中的接口方法调用，调用 <code>staticCall</code>函数尝试进行去虚拟化。</li></ol><h3 id="staticcall">staticCall()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">staticCall</span><span class="hljs-params">(call *ir.CallExpr)</span></span> &#123;<br>    <span class="hljs-comment">// 1. 检查调用是否为接口方法调用，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> call.Op() != ir.OCALLINTER &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 获取接收器和相关类型</span><br>sel := call.X.(*ir.SelectorExpr)<br>r := ir.StaticValue(sel.X)<br>    <br>     <span class="hljs-comment">// 3. 检查接收器是否是接口转换，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> r.Op() != ir.OCONVIFACE &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>recv := r.(*ir.ConvExpr)<br><br>   <span class="hljs-comment">// 4. 提取接收器类型</span><br>typ := recv.X.Type()<br><span class="hljs-keyword">if</span> typ.IsInterface() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 5. shape 类型直接返回，因为这一般涉及到泛型，需要通过字典进行间接调用</span><br><span class="hljs-keyword">if</span> typ.IsShape() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> typ.HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped receiver %v&quot;</span>, call, typ)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> sel.X.Type().HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped interface %v&quot;</span>, call, sel.X.Type())<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 6. 类型断言和方法选择，尝试确定调用的具体方法</span><br>dt := ir.NewTypeAssertExpr(sel.Pos(), sel.X, <span class="hljs-literal">nil</span>)<br>dt.SetType(typ)<br>x := typecheck.Callee(ir.NewSelectorExpr(sel.Pos(), ir.OXDOT, dt, sel.Sel))<br><span class="hljs-keyword">switch</span> x.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODOTMETH:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLMETH)<br>call.X = x<br><span class="hljs-keyword">case</span> ir.ODOTINTER:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;partially devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLINTER)<br>call.X = x<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;failed to devirtualize %v (%v)&quot;</span>, x, x.Op())<br>&#125;<br><span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment">// 7. 根据类型断言的结果，尝试将接口方法调用转换为直接方法调用或保留为接口方法调用。</span><br>types.CheckSize(x.Type())<br><span class="hljs-keyword">switch</span> ft := x.Type(); ft.NumResults() &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>call.SetType(ft.Results().Field(<span class="hljs-number">0</span>).Type)<br><span class="hljs-keyword">default</span>:<br>call.SetType(ft.Results())<br>&#125;<br><br><span class="hljs-comment">// 8. 对可能修改后的方法调用进行进一步的类型检查和调整。</span><br>typecheck.FixMethodCall(call)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>检查是否为接口方法调用</strong>：函数首先判断传入的调用是否是接口方法调用（<code>ir.OCALLINTER</code>），这是去虚拟化的前提条件。</li><li><strong>处理形状类型</strong>：代码中提到，如果接收器的类型是形状类型（用于泛型），则无法去虚拟化，因为这需要通过字典进行间接调用。</li><li><strong>处理形状类型的接收器</strong>：如果接收器的类型具有形状类型，则当前无法进行去虚拟化。注释中还提到了一些待实现（TODO）的优化点，例如处理非泛型的提升方法。</li><li><strong>处理形状类型的接口</strong>：如果调用的接口本身是一个形状类型，由于指针身份的不同，类型断言可能会失败，因此在这种情况下也无法去虚拟化。</li><li><strong>转换方法调用</strong>：根据调用的具体情况，将接口方法调用转换为直接的方法调用（<code>OCALLMETH</code>）或保留为接口方法调用（<code>OCALLINTER</code>）。</li><li><strong>更新调用类型</strong>：为了正确处理函数返回值，需要更新调用的类型，确保参数大小和栈偏移量正确。</li><li><strong>反糖化方法调用</strong>：如果创建了直接方法调用，需要对其进行后续的类型检查和调整。</li></ol><h2 id="函数内联">函数内联</h2><p>函数内联是将一个函数的代码直接插入到每个调用点，而不是进行常规的函数调用。这意味着函数的整个体被复制到每个调用该函数的地方。</p><p>优点：</p><ul><li><strong>减少开销</strong>：内联消除了函数调用的开销，如参数传递、栈操作等。</li><li><strong>提升性能</strong>：有助于其他优化，比如循环展开、常量传播，因为编译器可以看到函数体内的代码。</li></ul><p>选择哪些函数内联：</p><ul><li><strong>小函数</strong>：通常是小函数，因为它们的内联带来的性能提升相对于代码膨胀的代价来说是值得的。</li><li><strong>调用频率高的函数</strong>：这些函数如果内联，可以显著减少运行时的调用开销。</li></ul><p>在 Go 语言中，可以通过 <code>//go:noinline</code>来禁止函数内联。</p><p>这部分的主要实现在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal~/inl.go">inline.inl.go</a>，核心函数是：<code>CanInline()</code>和 <code>InlineImpossible()</code>。</p><h3 id="caninline">CanInline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Inlining budget parameters, gathered in one place</span><br><span class="hljs-keyword">const</span> (<br>    <span class="hljs-comment">// budget 是内联复杂度的衡量，</span><br>    <span class="hljs-comment">// 超过 80 表示编译器认为这个函数太复杂了，就不进行函数内联了</span><br>inlineMaxBudget       = <span class="hljs-number">80</span><br>)<br><br><span class="hljs-comment">// CanInline 用于判断 fn 是否可内联。</span><br><span class="hljs-comment">// 如果可以，会将 fn.Body 和 fn.Dcl 拷贝一份放到 fn.Inl，</span><br><span class="hljs-comment">// 其中 fn 和 fn.Body 需要确保已经经过类型检查了。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CanInline</span><span class="hljs-params">(fn *ir.Func, profile *pgo.Profile)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 函数名必须有效</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline no nname %+v&quot;</span>, fn)<br>&#125;<br><br>    <span class="hljs-comment">// 如果不能内联，输出原因</span><br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> || logopt.Enabled() &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: cannot inline %v: %s\n&quot;</span>, ir.Line(fn), fn.Nname, reason)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;cannotInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), reason)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br>    <span class="hljs-comment">// 检查是否符合不可能内联的情况，如果返回的 reason 不为空，则表示有不可以内联的原因</span><br>reason = InlineImpossible(fn)<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> fn.Typecheck() == <span class="hljs-number">0</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline on non-typechecked function %v&quot;</span>, fn)<br>&#125;<br><br>n := fn.Nname<br><span class="hljs-keyword">if</span> n.Func.InlinabilityChecked() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> n.Func.SetInlinabilityChecked(<span class="hljs-literal">true</span>)<br><br>cc := <span class="hljs-type">int32</span>(inlineExtraCallCost)<br><span class="hljs-keyword">if</span> base.Flag.LowerL == <span class="hljs-number">4</span> &#123;<br>cc = <span class="hljs-number">1</span> <span class="hljs-comment">// this appears to yield better performance than 0.</span><br>&#125;<br><br><span class="hljs-comment">// 设置内联预算，后面如果检查函数的复杂度超过预算了，就不内联了</span><br>budget := <span class="hljs-type">int32</span>(inlineMaxBudget)<br><span class="hljs-keyword">if</span> profile != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> n, ok := profile.WeightedCG.IRNodes[ir.LinkFuncName(fn)]; ok &#123;<br><span class="hljs-keyword">if</span> _, ok := candHotCalleeMap[n]; ok &#123;<br>budget = <span class="hljs-type">int32</span>(inlineHotMaxBudget)<br><span class="hljs-keyword">if</span> base.Debug.PGODebug &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;hot-node enabled increased budget=%v for func=%v\n&quot;</span>, budget, ir.PkgFuncName(fn))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 遍历函数体，计算复杂度，判断是否超过内联预算</span><br>visitor := hairyVisitor&#123;<br>curFunc:       fn,<br>budget:        budget,<br>maxBudget:     budget,<br>extraCallCost: cc,<br>profile:       profile,<br>&#125;<br><span class="hljs-keyword">if</span> visitor.tooHairy(fn) &#123;<br>reason = visitor.reason<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 前面检查都没问题，则标记为可以内联，并复制其函数体和声明到内联结构体中</span><br>n.Func.Inl = &amp;ir.Inline&#123;<br>Cost: budget - visitor.budget,<br>Dcl:  pruneUnusedAutos(n.Defn.(*ir.Func).Dcl, &amp;visitor),<br>Body: inlcopylist(fn.Body),<br><br>CanDelayResults: canDelayResults(fn),<br>&#125;<br><br>    <span class="hljs-comment">// 日志和调试</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v with cost %d as: %v &#123; %v &#125;\n&quot;</span>, ir.Line(fn), n, budget-visitor.budget, fn.Type(), ir.Nodes(n.Func.Inl.Body))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v\n&quot;</span>, ir.Line(fn), n)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;canInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), fmt.Sprintf(<span class="hljs-string">&quot;cost: %d&quot;</span>, budget-visitor.budget))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>基本检查</strong>：验证函数是否已经进行了类型检查，以及函数名是否有效。</li><li><strong>判断是否可以内联</strong>：调用<code>InlineImpossible</code>函数来检查是否有任何基本的限制条件阻止内联（例如函数太大、递归等）。</li><li><strong>内联预算设置</strong>：根据函数的特征和可能的性能剖析信息来设定内联预算。这个预算是内联决策的关键参数之一。</li><li><strong>详细分析</strong>：<code>hairyVisitor</code>结构用于遍历函数体，判断是否超出了内联预算。这涉及对函数体的复杂度和大小的评估。</li><li><strong>内联决策</strong>：如果函数通过了所有检查并且未超出预算，则标记为可以内联，并复制其函数体和声明（Dcl）到内联结构体中。</li><li><strong>日志和调试</strong>：根据编译器的日志级别，输出关于内联决策的详细信息，例如为什么一个函数不能被内联或者它的内联成本是多少。</li></ol><h3 id="inlineimpossible">InlineImpossible()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InlineImpossible</span><span class="hljs-params">(fn *ir.Func)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span> <span class="hljs-comment">// reason, if any, that the function can not be inlined.</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>reason = <span class="hljs-string">&quot;no name&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:noinline&quot;, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Noinline != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:noinline&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:norace&quot; and -race compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Flag.Race &amp;&amp; fn.Pragma&amp;ir.Norace != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:norace with -race compilation&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:nocheckptr&quot; and -d checkptr compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Debug.Checkptr != <span class="hljs-number">0</span> &amp;&amp; fn.Pragma&amp;ir.NoCheckPtr != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:nocheckptr&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:cgo_unsafe_args&quot;, don&#x27;t inline, since the function</span><br><span class="hljs-comment">// makes assumptions about its argument frame layout.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.CgoUnsafeArgs != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:cgo_unsafe_args&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrkeepalive&quot;, don&#x27;t inline, since the keep</span><br><span class="hljs-comment">// alive information is lost during inlining.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// TODO(prattmic): This is handled on calls during escape analysis,</span><br><span class="hljs-comment">// which is after inlining. Move prior to inlining so the keep-alive is</span><br><span class="hljs-comment">// maintained after inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrKeepAlive != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having a keep-alive uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrescapes&quot;, don&#x27;t inline, since the escape</span><br><span class="hljs-comment">// information is lost during inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrEscapes != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having an escaping uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// The nowritebarrierrec checker currently works at function</span><br><span class="hljs-comment">// granularity, so inlining yeswritebarrierrec functions can confuse it</span><br><span class="hljs-comment">// (#22342). As a workaround, disallow inlining them for now.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Yeswritebarrierrec != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:yeswritebarrierrec&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If a local function has no fn.Body (is defined outside of Go), cannot inline it.</span><br><span class="hljs-comment">// Imported functions don&#x27;t have fn.Body but might have inline body in fn.Inl.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &amp;&amp; !typecheck.HaveInlineBody(fn) &#123;<br>reason = <span class="hljs-string">&quot;no function body&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If fn is synthetic hash or eq function, cannot inline it.</span><br><span class="hljs-comment">// The function is not generated in Unified IR frontend at this moment.</span><br><span class="hljs-keyword">if</span> ir.IsEqOrHashFunc(fn) &#123;<br>reason = <span class="hljs-string">&quot;type eq/hash function&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>无函数名</strong>：如果函数没有名字，不能内联。</li><li><strong>有 <code>go:noinline</code>指令</strong>：显式标记为不内联。</li><li><strong>有 <code>go:norace</code> 指令并在 <code>-race</code>编译模式下</strong>：在竞态检测编译模式下不内联标记为<code>norace</code> 的函数。</li><li><strong>有 <code>go:nocheckptr</code> 指令并在<code>-d checkptr</code>编译模式下</strong>：在指针检查编译模式下不内联标记为<code>nocheckptr</code> 的函数。</li><li><strong>有 <code>go:cgo_unsafe_args</code> 指令</strong>：对于标记为<code>cgo_unsafe_args</code> 的函数，由于参数布局的假设，不内联。</li><li><strong>有 <code>go:uintptrkeepalive</code>指令</strong>：不内联标记为 <code>uintptrkeepalive</code> 的函数。</li><li><strong>有 <code>go:uintptrescapes</code>指令</strong>：不内联标记为 <code>uintptrescapes</code> 的函数。</li><li><strong>有 <code>go:yeswritebarrierrec</code>指令</strong>：为了防止写屏障记录检查器的混淆，不内联标记为<code>yeswritebarrierrec</code> 的函数。</li><li><strong>无函数体</strong>：本地定义但没有函数体的函数（外部定义的 Go函数）不可内联。</li><li><strong>是合成的 hash 或 eq函数</strong>：不能内联这些类型的函数。</li></ol><h3 id="举例-1">举例</h3><p>我们通过一段代码来看看编译器的函数内联情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(index <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> index<br>&#125;<br><span class="hljs-keyword">return</span> Fib(index<span class="hljs-number">-1</span>) + Fib(index<span class="hljs-number">-2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForSearch</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> s = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> s[i] == i &#123;<br>res = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>SayHello()<br>Fib(<span class="hljs-number">65</span>)<br>ForSearch()<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译时我们可以加入 <code>-m=2</code>标签，来打印函数的内联调试信息。在 <code>main.go</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:3:6: can inline SayHello with cost 7 as: func() string &#123; s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-built_in">return</span> s &#125;<br>main.go:8:6: cannot inline Fib: recursive<br>main.go:15:6: can inline ForSearch with cost 45 as: func() int &#123; s := []int&#123;...&#125;; res := 0; <span class="hljs-keyword">for</span> loop; <span class="hljs-built_in">return</span> res &#125;<br>main.go:26:6: cannot inline main: <span class="hljs-keyword">function</span> too complex: cost 116 exceeds budget 80<br>main.go:27:10: inlining call to SayHello<br>main.go:29:11: inlining call to ForSearch<br>main.go:16:15: []int&#123;...&#125; does not escape<br>main.go:29:11: []int&#123;...&#125; does not escape<br></code></pre></td></tr></table></figure><p>可以看到 <code>SayHello()</code> 和 <code>ForSearch</code>都被内联了，而 <code>Fib()</code> 因为有递归，所以不会被内联。</p><h2 id="逃逸分析">逃逸分析</h2><p>逃逸分析是 Go语言中非常重要的优化阶段，<strong>用于标识变量内存应该被分配在栈上还是堆上</strong>。</p><p>在传统的 C 或 C++开发中，开发者经常会犯的错误就是函数返回了一个栈上的对象指针，在函数执行完毕后，函数栈会被销毁，如果继续访问被销毁栈上的对象指针，那么就会出现问题。</p><p>Go语言能够通过编译时的逃逸分析识别这种问题，自动将这类变量放置到堆区，并借助Go运行时的垃圾回收机制自动释放内存。编译器会尽可能地将变量放置在栈上，因为栈中的对象会随着函数调用结束被自动销毁，这可以减轻运行时分配和垃圾回收的负担。</p><p>在 Go语言中，开发者模糊了栈区和堆区的区别，不管是字符串、数组字面量，还是通过new、make标识符创建的对象，都既可能被分配到栈上，也可能被分配到堆上。但是，整体上会遵循2 个原则：</p><ol type="1"><li>指向栈上对象的指针不能被存储到堆上；</li><li>指向栈上对象的指针不能超过该栈对象的生命周期。</li></ol><p>这部分的代码主要在 <ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/escape">escape</a>。</p><h3 id="分析过程">分析过程</h3><p>Go 语言通过对 AST 的静态数据流分析来实现逃逸分析（<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/graph.go">escape/graph.go</a>），在这个过程，它会构建带权重的有向图，其中权重可以表面当前变量引用和解引用的数量。</p><ul><li>引用（&amp;a） 减 1</li><li>解引用（*a）加 1</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> deref(where ir.Node, why <span class="hljs-type">string</span>) hole &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">1</span>).note(where, why) &#125; <span class="hljs-comment">// 解引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> addr(where ir.Node, why <span class="hljs-type">string</span>) hole  &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">-1</span>).note(where, why) &#125; <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>具体来说，Go逃逸分析会按照如下规则生成数据流图（带权重的有向图）：</p><ol type="1"><li>每个变量作为一个节点（location）；</li><li>每个赋值动作是一个有向边（edge），赋值给谁则指向谁；</li><li>解引用（deref），即 <code>*</code>操作会给边的权重 +1；</li><li>引用（addr），即 <code>&amp;</code> 操作会给边权重 -1。</li></ol><p>其中：<strong>节点权重 = 指向的节点权重 + 边权重</strong></p><p>逃逸分析的目标就是<strong>找到其中节点权重为 -1的变量</strong>，并结合上述提到的 2个原则，来判断要不要将变量分配到堆上。</p><h3 id="分析实例">分析实例</h3><p>我们举一个例子来进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) <br>*l = <span class="hljs-number">42</span><br>m := &amp;l<br>n := &amp;m<br>o = **n<br>&#125;<br></code></pre></td></tr></table></figure><p>再次回顾一下，<code>*</code> 是加 1，<code>&amp;</code>是减一。按照常规思路，我们从上往下分析：</p><p>先画出节点的赋值顺序，赋值给谁，边就指向谁：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203193913047.png"alt="第1步：梳理节点顺序" /><figcaption aria-hidden="true">第1步：梳理节点顺序</figcaption></figure><p>然后根据引用和解引用给边赋权重，因为 <code>new(int)</code>其实就是分配一个 <code>int(0)</code> 并取地址，相当于<code>&amp;</code>，所以指向 <code>l</code> 的边权重是<code>-1</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194101882.png"alt="第2步：给边赋值" /><figcaption aria-hidden="true">第2步：给边赋值</figcaption></figure><p>节点权重 = 边权重 + 指向节点权重，因为没有对 <code>o</code>变量进行任何的操作，所以 <code>o</code> 权重为0，从右往左推可以得到：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194432349.png"alt="第3步：计算节点权重" /><figcaption aria-hidden="true">第3步：计算节点权重</figcaption></figure><p>经过分析，我们就找到了节点权重为 <code>-1</code> 的节点<code>new(int)</code>，又由于它的节点变量地址最终会被传递到变量<code>o</code> 上，结合之前的 2 个原则，<code>o</code>是一个全局变量，声明周期是超过函数栈的，所以 <code>new(int)</code>会被分配到堆上。</p><p>可以执行下面语句输出逃逸结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:5:6: can inline main<br>/escape/main.go:6:10: new(int) escapes to hea<br></code></pre></td></tr></table></figure><p>也可以执行下面语句输出数据流图构建过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags=<span class="hljs-string">&quot;-m -m -l&quot;</span> main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>./main.go:6:10: new(int) escapes to heap:<br>./main.go:6:10:   flow: l = &amp;&#123;storage <span class="hljs-keyword">for</span> new(int)&#125;:<br>./main.go:6:10:     from new(int) (spill) at ./main.go:6:10<br>./main.go:6:10:     from l := new(int) (assign) at ./main.go:6:4<br>./main.go:6:10:   flow: m = &amp;l:<br>./main.go:6:10:     from &amp;l (address-of) at ./main.go:8:7<br>./main.go:6:10:     from m := &amp;l (assign) at ./main.go:8:4<br>./main.go:6:10:   flow: n = &amp;m:<br>./main.go:6:10:     from &amp;m (address-of) at ./main.go:9:7<br>./main.go:6:10:     from n := &amp;m (assign) at ./main.go:9:4<br>./main.go:6:10:   flow: &#123;heap&#125; = **n:<br>./main.go:6:10:     from *n (indirection) at ./main.go:10:7<br>./main.go:6:10:     from *(*n) (indirection) at ./main.go:10:6<br>./main.go:6:10:     from o = *(*n) (assign) at ./main.go:10:4<br>./main.go:6:10: new(int) escapes to heap<br></code></pre></td></tr></table></figure><p>如果我们试一下，把 <code>o</code> 放在 <code>main()</code>里面呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*l = <span class="hljs-number">42</span><br>m := &amp;l <br>n := &amp;m <br>o = **n <br>o = o   <span class="hljs-comment">// 让编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:3:6: can inline main<br>/escape/main.go:5:10: new(int) does not escape<br></code></pre></td></tr></table></figure><p>如我们所想，虽然 <code>new(int)</code> 的权重为<code>-1</code>，但是它的声明周期始终没有超过<code>main()</code>，所以没必要逃逸到堆上。</p><h2 id="变量捕获">变量捕获</h2><p>变量捕获主要是针对闭包（closure）场景而言的，由于闭包函数中可能引用闭包外的变量，因此变量捕获需要明确在闭包中通过值引用或者地址引用的方式来捕获变量。</p><p>这一过程在前面提到的逃逸分析过程中进行，具体实现在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/escape.go">escape/escape.go</a>的 <code>flowClosure()</code> 函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *batch)</span></span> flowClosure(k hole, clo *ir.ClosureExpr) &#123;<br>    <span class="hljs-comment">// 遍历闭包中的所有变量</span><br>    <span class="hljs-keyword">for</span> _, cv := <span class="hljs-keyword">range</span> clo.Func.ClosureVars &#123;<br>        n := cv.Canonical()<br>        loc := b.oldLoc(cv)<br>        <span class="hljs-comment">// 如果变量未被捕获，则触发错误</span><br>        <span class="hljs-keyword">if</span> !loc.captured &#123;<br>            base.FatalfAt(cv.Pos(), <span class="hljs-string">&quot;closure variable never captured: %v&quot;</span>, cv)<br>        &#125;<br><br>        <span class="hljs-comment">// 根据变量的特性决定是通过值还是引用捕获</span><br>        <span class="hljs-comment">// 如果变量未被重新赋值或取址，并且小于等于 128 字节，则通过值捕获</span><br>        n.SetByval(!loc.addrtaken &amp;&amp; !loc.reassigned &amp;&amp; n.Type().Size() &lt;= <span class="hljs-number">128</span>)<br>        <span class="hljs-keyword">if</span> !n.Byval() &#123;<br>            n.SetAddrtaken(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">// 特殊情况处理：字典变量不通过值捕获</span><br>            <span class="hljs-keyword">if</span> n.Sym().Name == typecheck.LocalDictName &#123;<br>                base.FatalfAt(n.Pos(), <span class="hljs-string">&quot;dictionary variable not captured by value&quot;</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 记录闭包捕获变量的方式（值或引用）</span><br>        <span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>            how := <span class="hljs-string">&quot;ref&quot;</span><br>            <span class="hljs-keyword">if</span> n.Byval() &#123;<br>                how = <span class="hljs-string">&quot;value&quot;</span><br>            &#125;<br>            base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%v capturing by %s: %v (addr=%v assign=%v width=%d)&quot;</span>, n.Curfn, how, n, loc.addrtaken, loc.reassigned, n.Type().Size())<br>        &#125;<br><br>        <span class="hljs-comment">// 建立闭包变量的数据流</span><br>        k := k<br>        <span class="hljs-keyword">if</span> !cv.Byval() &#123;<br>            k = k.addr(cv, <span class="hljs-string">&quot;reference&quot;</span>)<br>        &#125;<br>        b.flow(k.note(cv, <span class="hljs-string">&quot;captured by a closure&quot;</span>), loc)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句看看变量的捕获方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go  | grep <span class="hljs-string">&quot;capturing&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:4:2: main capturing by ref: a (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">true</span> width=8)<br>main.go:5:2: main capturing by value: b (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">false</span> width=8)<br></code></pre></td></tr></table></figure><p>可以看到 <code>a</code> 是通过 <code>ref 地址引用</code>的方式进行引用的，而 <code>b</code> 是通过 <code>value 值传递</code>的方式进行引用的。</p><p>简单分析一下：上述例子中，闭包引用了 <code>a</code> 和 <code>b</code>这 2 个闭包外声明的变量，而变量 <code>a</code>在闭包之前又做了一些其他的操作，而 b 没有，所以对于<code>a</code>，因为闭包外有操作，所以闭包内的操作可能是有特殊意义的，需要反馈到闭包外，就需要用<code>ref 地址引用</code>了，而 <code>b</code>在闭包外并不关心，所以闭包内的操作不会影响到闭包外，故直接使用<code>value 值传递</code> 即可。</p><h2 id="闭包重写">闭包重写</h2><p>逃逸分析后，现在我们进入 <code>walk</code>阶段了。这里首先会进行闭包重写。其核心逻辑在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/walk/closure.go">walk/closure.go</a>中。</p><p>闭包重写分为 2 种情况：</p><ul><li>闭包定义后被立即调用</li><li>闭包定义后不立即调用</li></ul><h3 id="闭包定义后被立即调用">闭包定义后被立即调用</h3><p>在闭包定义后被立即调用的情况下，闭包只会被调用一次，这时可以将闭包转换为普通函数的调用形式。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换为普通函数的调用形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> func1(&amp;a, b)<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-comment">// 注意这里 a 的类型的 *int，因为在变量捕获阶段，判断了 a 应该用地址引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(a *<span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> &#123;<br>add(*a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器具体的处理逻辑在 <code>directClosureCall()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// directClosureCall rewrites a direct call of a function literal into</span><br><span class="hljs-comment">// a normal function call with closure variables passed as arguments.</span><br><span class="hljs-comment">// This avoids allocation of a closure object.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For illustration, the following call:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//byref++</span><br><span class="hljs-comment">//&#125;(42)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// becomes:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(byval int, &amp;byref *int, a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//(*&amp;byref)++</span><br><span class="hljs-comment">//&#125;(byval, &amp;byref, 42)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directClosureCall</span><span class="hljs-params">(n *ir.CallExpr)</span></span> &#123;<br>clo := n.X.(*ir.ClosureExpr)<br>clofn := clo.Func<br><br>    <span class="hljs-comment">// 如果闭包足够简单，不进行处理，留给 walkClosure 处理。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// leave for walkClosure to handle</span><br>&#125;<br><br><span class="hljs-comment">// 将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</span><br><span class="hljs-keyword">var</span> params []*types.Field<br><span class="hljs-keyword">var</span> decls []*ir.Name<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> clofn.ClosureVars &#123;<br><span class="hljs-keyword">if</span> !v.Byval() &#123;<br><span class="hljs-comment">// 对于引用捕获的变量，创建相应的指针参数。</span><br>addr := ir.NewNameAt(clofn.Pos(), typecheck.Lookup(<span class="hljs-string">&quot;&amp;&quot;</span>+v.Sym().Name))<br>addr.Curfn = clofn<br>addr.SetType(types.NewPtr(v.Type()))<br>v.Heapaddr = addr<br>v = addr<br>&#125;<br><br>v.Class = ir.PPARAM<br>decls = <span class="hljs-built_in">append</span>(decls, v)<br><br>fld := types.NewField(src.NoXPos, v.Sym(), v.Type())<br>fld.Nname = v<br>params = <span class="hljs-built_in">append</span>(params, fld)<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</span><br>f := clofn.Nname<br>typ := f.Type()<br>typ = types.NewSignature(<span class="hljs-literal">nil</span>, <span class="hljs-built_in">append</span>(params, typ.Params().FieldSlice()...), typ.Results().FieldSlice())<br>f.SetType(typ)<br>clofn.Dcl = <span class="hljs-built_in">append</span>(decls, clofn.Dcl...)<br><br><span class="hljs-comment">// 将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</span><br>n.X = f<br>n.Args.Prepend(closureArgs(clo)...)<br><br><span class="hljs-comment">// 调整调用表达式的类型，以反映参数和返回值类型的变化。</span><br><span class="hljs-keyword">if</span> typ.NumResults() == <span class="hljs-number">1</span> &#123;<br>n.SetType(typ.Results().Field(<span class="hljs-number">0</span>).Type)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>n.SetType(typ.Results())<br>&#125;<br><br><span class="hljs-comment">// 虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</span><br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是 Go 编译器中的 <code>directClosureCall</code>函数，用于将直接调用的函数字面量重写为正常的函数调用，同时将闭包变量作为参数传递。这避免了闭包对象的分配。</p><p>主要步骤如下：</p><ol type="1"><li><strong>检查闭包是否简单</strong>：如果闭包足够简单，不进行处理，留给<code>walkClosure</code> 处理。</li><li><strong>处理闭包变量</strong>：将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</li><li><strong>更新函数类型和声明</strong>：创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</li><li><strong>重写调用</strong>：将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</li><li><strong>更新调用表达式类型</strong>：调整调用表达式的类型，以反映参数和返回值类型的变化。</li><li><strong>添加到待编译列表</strong>：虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</li></ol><p>这个函数的目的是优化闭包的调用，通过避免闭包对象的分配来提高性能。</p><h3 id="闭包定义后不立即调用">闭包定义后不立即调用</h3><p>如果闭包定义后不被立即调用，而是后续调用，那么同一个闭包可能会被调用多次，这个时候就必须创建闭包对象了。</p><p>编译器具体的处理逻辑在 <code>walkClosure()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkClosure</span><span class="hljs-params">(clo *ir.ClosureExpr, init *ir.Nodes)</span></span> ir.Node &#123;<br>clofn := clo.Func<br><br><span class="hljs-comment">// 如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">if</span> base.Debug.Closure &gt; <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(clo.Pos(), <span class="hljs-string">&quot;closure converted to global&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> clofn.Nname<br>&#125;<br><br><span class="hljs-comment">// 对于复杂闭包，设置需要上下文标记，并进行运行时检查。</span><br>ir.ClosureDebugRuntimeCheck(clo)<br>clofn.SetNeedctxt(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 确保闭包函数不会被重复添加到编译队列。</span><br><span class="hljs-keyword">if</span> !clofn.Walked() &#123;<br>clofn.SetWalked(<span class="hljs-literal">true</span>)<br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br><br><span class="hljs-comment">// 构造一个复合字面量表达式来表示闭包实例。</span><br>typ := typecheck.ClosureType(clo)<br><br>    <span class="hljs-comment">// 将闭包函数和捕获的变量作为字段添加到闭包结构中。</span><br>clos := ir.NewCompLitExpr(base.Pos, ir.OCOMPLIT, typ, <span class="hljs-literal">nil</span>)<br>clos.SetEsc(clo.Esc())<br>clos.List = <span class="hljs-built_in">append</span>([]ir.Node&#123;ir.NewUnaryExpr(base.Pos, ir.OCFUNC, clofn.Nname)&#125;, closureArgs(clo)...)<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> clos.List &#123;<br>clos.List[i] = ir.NewStructKeyExpr(base.Pos, typ.Field(i), value)<br>&#125;<br><br>    <span class="hljs-comment">// 创建闭包结构的地址，并进行类型转换以符合闭包类型。</span><br>addr := typecheck.NodAddr(clos)<br>addr.SetEsc(clo.Esc())<br>cfn := typecheck.ConvNop(addr, clo.Type())<br><br><span class="hljs-comment">// 如果存在预分配的闭包对象，进行相关处理。</span><br><span class="hljs-keyword">if</span> x := clo.Prealloc; x != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !types.Identical(typ, x.Type()) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;closure type does not match order&#x27;s assigned type&quot;</span>)<br>&#125;<br>addr.Prealloc = x<br>clo.Prealloc = <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 对最终构建的闭包表达式进行进一步处理。</span><br><span class="hljs-keyword">return</span> walkExpr(cfn, init)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>检查是否为简单闭包</strong>：如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</li><li><strong>处理非简单闭包</strong>：对于复杂闭包，设置需要上下文标记，并进行运行时检查。</li><li><strong>防止重复处理</strong>：确保闭包函数不会被重复添加到编译队列。</li><li><strong>创建闭包结构</strong>：构造一个复合字面量表达式来表示闭包实例。</li><li><strong>填充闭包参数</strong>：将闭包函数和捕获的变量作为字段添加到闭包结构中。</li><li><strong>地址和类型转换</strong>：创建闭包结构的地址，并进行类型转换以符合闭包类型。</li><li><strong>处理预分配的闭包</strong>：如果存在预分配的闭包对象，进行相关处理。</li><li><strong>表达式处理</strong>：对最终构建的闭包表达式进行进一步处理。</li></ol><h2 id="遍历函数">遍历函数</h2><p>闭包重写后，会进入 walk 阶段，如官方 文档所说：这是对 IR表示的最后一次遍历，它有两个目的：</p><ol type="1"><li>将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；</li><li>将高级 Go 构造转换为更原始的构造。</li></ol><p>举个例子，<code>walkRange()</code> 函数针对不同类型的<code>range</code>语句（数组、切片、映射、通道和字符串）进行处理，将其转换为更基本的循环结构，并应用必要的变换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkRange</span><span class="hljs-params">(nrange *ir.RangeStmt)</span></span> ir.Node &#123;<br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 遍历 range 语句的不同情况</span><br>    <span class="hljs-keyword">switch</span> t.Kind() &#123;<br>    <span class="hljs-keyword">default</span>:<br>        base.Fatalf(<span class="hljs-string">&quot;walkRange&quot;</span>)<br><br>    <span class="hljs-comment">// 处理数组、切片、指针（指向数组）的情况</span><br>    <span class="hljs-keyword">case</span> types.TARRAY, types.TSLICE, types.TPTR:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理映射的情况</span><br>    <span class="hljs-keyword">case</span> types.TMAP:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理通道的情况</span><br>    <span class="hljs-keyword">case</span> types.TCHAN:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理字符串的情况</span><br>    <span class="hljs-keyword">case</span> types.TSTRING:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 构建并返回新的 for 语句</span><br>    nfor.PtrInit().Append(init...)<br>    typecheck.Stmts(nfor.Cond.Init())<br>    nfor.Cond = typecheck.Expr(nfor.Cond)<br>    nfor.Cond = typecheck.DefaultLit(nfor.Cond, <span class="hljs-literal">nil</span>)<br>    nfor.Post = typecheck.Stmt(nfor.Post)<br>    typecheck.Stmts(body)<br>    nfor.Body.Append(body...)<br>    nfor.Body.Append(nrange.Body...)<br><br>    <span class="hljs-keyword">var</span> n ir.Node = nfor<br>    n = walkStmt(n)<br><br>    base.Pos = lno<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码在 <ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/walk">walk</a>，对其他优化感兴趣的读者可以阅读这部分的代码。</p><h2 id="ssa-生成">SSA 生成</h2><p>遍历函数（Walk）阶段后，编译器会将 AST转换为下一个重要的中间表示形态，称为 SSA，其全称为 Static SingleAssignment，静态单赋值。SSA 被大多数现代的编译器（包括 GCC 和LLVM）使用，用于编译过程中的优化和代码生成。其核心特点和用途如下：</p><ol type="1"><li><strong>变量唯一赋值</strong>：在 SSA形式中，每个变量只被赋值一次，使得变量的使用和修改更加清晰。</li><li><strong>方便的数据流分析</strong>：SSA使得数据流分析更加直接和高效，因为每个变量的赋值点只有一个。</li><li><strong>优化算法的基础</strong>：许多编译器优化技术，如死代码消除、常量传播、强度削减等，在SSA 形式下更易实现。</li><li><strong>Phi 函数</strong>：SSA 引入了 Phi函数来处理变量在不同控制流路径上的不同赋值。</li><li><strong>代码生成</strong>：SSA形式简化了目标代码生成的过程，因为它提供了更清晰的操作和变量使用视图。</li></ol><p>官方对 SSA 生成阶段进行了详细的描述：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/README.md">Introductionto the Go compiler's SSA backend</a></p><p>Go 提供了强有力的工具查看 SSA初始及其后续优化阶段生成的代码片段，可以通过编译时指定<code>GOSSAFUNC=&#123;pkg.func&#125;</code> 实现。</p><p>以下面代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> d <span class="hljs-type">uint8</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>a = <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>a = <span class="hljs-number">3</span><br>&#125;<br>d = a<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以自行简单分析一下，这段代码前面 <code>a</code>的所有操作其实都是无意义的，整段代码其实就在说 <code>d = 3</code>这件事。</p><p>在 linux 或者 mac 上执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GOSSAFUNC=main.main <span class="hljs-keyword">go</span> build main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>在 Windows 上执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:GOSSAFUNC</span>=<span class="hljs-string">&quot;main&quot;</span><br>go build .\main.go<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dumped SSA to .\ssa.html<br></code></pre></td></tr></table></figure><p>通过浏览器打开生成的 <code>ssa.html</code> 文件，我们可以看到 SSA的初始阶段、优化阶段和最终阶段的代码片段。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ssa.png"alt="ssa.html 文件示例" /><figcaption aria-hidden="true">ssa.html 文件示例</figcaption></figure><p>我们直接看最终的结果，来看看我们前面的分析正确与否：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203211001137.png"alt="ssa 最终结果" /><figcaption aria-hidden="true">ssa 最终结果</figcaption></figure><p>可以看到这一行：<code>00003 (**+11**) MOVB $3, main.d(SB)</code>，那其实就是直接<code>d = 3</code>。</p><h2 id="机器码生成">机器码生成</h2><p>在 SSA阶段，编译器先执行与特定指令集无关的优化，再执行与特定指令集有关的优化，并最终生成与特定指令集有关的指令和寄存器分配方式。如<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/genericOps.go">ssa/_gen/genericOps.go</a>中包含了与特定指令集无关的 Op 操作，在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/S390XOps.go">ssa/_gen/AMD64Ops.go</a>中包含了和 AMD64 指令集相关的 Op 操作。</p><p>机器码生成阶段是编译器的机器依赖阶段，主要过程如下：</p><ol type="1"><li><strong>Lowering 过程</strong>：这个过程将通用的 SSA形式转换为特定于目标机器的变体。这包括将通用操作符替换为针对特定硬件优化的操作。</li><li><strong>代码优化</strong>：在机器特定的形式上执行最终优化，进一步提高代码效率。</li><li><strong>生成机器指令</strong>：将 Go 函数转换为<code>obj.Prog</code> 指令序列。</li><li><strong>汇编和输出</strong>：这些指令由<code>cmd/internal/obj</code>模块的汇编器处理，转换为机器代码，并输出最终的目标文件。</li></ol><p>Go 为我们了解 Go语言程序的编译和链接过程提供了一个非常好用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n<br></code></pre></td></tr></table></figure><p>其中 <code>-n</code> 表示<strong>只输出编译过程中将要执行的 shell命令，但不执行</strong>。</p><p>以下面程序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cast&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := cast.ToInt(<span class="hljs-string">&quot;1&quot;</span>)<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序引入了标准库 <code>fmt</code> 以及第三方库<code>github.com/spf13/cast</code>。</p><p>在工程目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n -o main<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/<br><span class="hljs-built_in">cat</span> &gt;<span class="hljs-variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="hljs-string">&#x27;EOF&#x27;</span> <span class="hljs-comment"># internal</span><br>packagefile go-compilation=/Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>packagefile <span class="hljs-built_in">fmt</span>=/Users/wangjiahan/Library/Caches/go-build/10/10ab74ff0df27a2f4bdbe7651290f13ad466f3df63e11241e07ccd21c169b206-d<br>packagefile github.com/spf13/cast=/Users/wangjiahan/Library/Caches/go-build/77/77eed0b7028cfc4c90d78d6670325d982325399573dff9d7f82ffbf76e4559e8-d<br>...<br>packagefile net/url=/Users/wangjiahan/Library/Caches/go-build/72/72d0ef9b8f99a52bf1de760bb2f630998d6bb66a3d2a3fa66bd66f4efddfbc71-d<br>modinfo <span class="hljs-string">&quot;0w\xaf\f\x92t\b\x02A\xe1\xc1\a\xe6\xd6\x18\xe6path\tgo-compilation\nmod\tgo-compilation\t(devel)\t\ndep\tgithub.com/spf13/cast\tv1.6.0\th1:GEiTHELF+vaR5dhz3VqZfFSzZjYbgeKDpBxQVS4GYJ0=\nbuild\t-buildmode=exe\nbuild\t-compiler=gc\nbuild\tCGO_ENABLED=1\nbuild\tCGO_CFLAGS=\nbuild\tCGO_CPPFLAGS=\nbuild\tCGO_CXXFLAGS=\nbuild\tCGO_LDFLAGS=\nbuild\tGOARCH=arm64\nbuild\tGOOS=darwin\n\xf92C1\x86\x18 r\x00\x82B\x10A\x16\xd8\xf2&quot;</span><br>EOF<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/exe/<br><span class="hljs-built_in">cd</span> .<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=FDJiS-4glijTlqBbjVbe/UWsngURatTblImv3DE6-/OjO-hZGekrr-XpHFs_zA/FDJiS-4glijTlqBbjVbe -extld=cc /Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w <span class="hljs-variable">$WORK</span>/b001/exe/a.out <span class="hljs-comment"># internal</span><br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$WORK</span>/b001/exe/a.out main<br></code></pre></td></tr></table></figure><p>这里建议你先尝试自行分析一下这个编译过程，再继续往下阅读。</p><p>经过分析，上述过程可以分为以下 8 个步骤：</p><ol type="1"><li><strong>创建工作目录</strong>：<code>mkdir -p $WORK/b001/</code>创建一个临时工作目录，用于存放编译过程中的临时文件。</li><li><strong>生成导入配置文件</strong>：<code>cat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF'</code>命令开始创建一个名为 <code>importcfg.link</code>的文件，这个文件包含了编译过程中需要的包文件路径。</li><li><strong>写入包文件路径</strong>：接下来的多行内容是对<code>importcfg.link</code>文件的填充，指定了各个依赖包的存储位置。</li><li><strong>结束文件写入</strong>：<code>EOF</code> 标志着<code>importcfg.link</code> 文件内容的结束。</li><li><strong>创建可执行文件目录</strong>：<code>mkdir -p $WORK/b001/exe/</code>创建一个目录，用于存放最终的可执行文件。</li><li><strong>编译链接</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/a.out ...</code>这一步是编译链接的核心，它使用Go的链接工具，根据之前生成的<code>importcfg.link</code> 文件，将代码编译成可执行文件。</li><li><strong>更新构建ID</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w $WORK/b001/exe/a.out</code>这一步更新了可执行文件的构建ID。</li><li><strong>移动可执行文件</strong>：<code>mv $WORK/b001/exe/a.out main</code>将编译好的可执行文件移动到当前目录，并重命名为 <code>main</code>。</li></ol><p>如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img6sR2uDuHwbkSNk3FuUxHmY-20231129143014805.png"alt="Go语言编译和链接过程" /><figcaption aria-hidden="true">Go语言编译和链接过程</figcaption></figure><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile">Go1.21官方文档</a></li><li><a href="https://book.douban.com/subject/35556889/">《Go语言底层原理剖析》</a></li><li><ahref="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">《Go语言设计与实现》</a></li><li><ahref="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">Go:Overview of the Compiler</a></li><li><ahref="https://en.wikipedia.org/wiki/Abstract_syntax_tree">维基百科 -AST</a></li><li><ahref="https://en.wikipedia.org/wiki/Static_single-assignment_form">维基百科- SSA</a></li><li><a href="https://zhuanlan.zhihu.com/p/592602585">Go机制：逃逸分析学习笔记</a></li><li>ChatGPT-4</li></ul><hr /><p>以上便是 Go 语言在 1.21.0这个版本下编译过程的整个过程，笔者会在阅读完《用 Go语言自制解释器》和《用 Go语言自制编译器》这两本书后，若有对编译原理有更深入的体会和感悟，再回过来对本文的内容进行勘误和进一步提炼。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 顺序消息实现</title>
    <link href="/2023/11/23/kafka-ordered-msg/"/>
    <url>/2023/11/23/kafka-ordered-msg/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><p>本文所有的讨论均在如下版本进行，其他版本可能会有所不同。</p><ul><li>Kafka: 3.6.0</li><li>Pulsar: 2.9.0</li><li>RabbitMQ 3.7.8</li><li>RocketMQ 5.0</li><li>Go1.21</li><li>github.com/segmentio/kafka-go v0.4.45</li></ul><h2 id="结论先行">结论先行</h2><p>Kafka只能保证单一分区内的顺序消息，无法保证多分区间的顺序消息。具体来说，要在Kafka 完全实现顺序消息，至少需要保证以下几个条件：</p><ol type="1"><li>同一生产者生产消息；</li><li>同步发送消息到 Kafka broker；</li><li>所有消息发布到同一个分区；</li><li>同一消费者同步按照顺序消费消息。</li></ol><p>而要满足第 3 点，常用的有 2 种思路：</p><ol type="1"><li>固定消息的 key，生产端采用 <code>key hash</code> 的方式写入broker；</li><li>自定义分区策略，要保证顺序的消息都写入到指定的分区。</li></ol><h2 id="消息队列中的顺序消息如何实现">消息队列中的顺序消息如何实现</h2><h3 id="顺序消息定义">顺序消息定义</h3><p>生产端发送出来的消息的顺序和消费端接收到消息的顺序是一样的。</p><h3 id="消息存储结构">消息存储结构</h3><p>一般来说，消息队列都是基于<strong>顺序存储结构</strong>来存储数据的，不需要B 树、B+树等复杂数据结构，利用文件的顺序读写，性能也很高。所以理想情况下，生产者按顺序发送消息，broker会按顺序存储消息，消费者再按顺序消费消息，那么天然就实现了我们要的<strong>顺序消息</strong>了，如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231124235214392.png"alt="消息队列顺序存储结构" /><figcaption aria-hidden="true">消息队列顺序存储结构</figcaption></figure><h3 id="基本条件">基本条件</h3><p>但是一般情况下，消息队列为了支持更高的并发和吞吐，大多数都有分区（partition）和消费者组（consumergroup）机制，而为了高可用，一般也会有副本（replica）机制，所以情况就复杂得多了，如下面几个例子，就会导致消息失序：</p><ol type="1"><li>多个生产者同时发送消息，那么到达 broker 的时间也是不确定的，所以broker 就无法保证落盘的顺序性了；</li><li>单个生产者，但是采用异步发送，因为异步线程是并发执行的，由 CPU进行调度，且有可能会因为发送失败而重试，所以也无法保证消息可以按照顺序到达broker，同理，消费者异步处理消息，也无法保证顺序性；</li><li>一个 topic有多个分区，那么即使是同一个生产者，由于分区策略，消息可能会被分发到多个分区中，消费者也就无法保证顺序性了。</li></ol><p>所以到这里，我们可以总结出实现顺序消息，至少需要满足以下 3 点：</p><ol type="1"><li>单一生产者同步发送；</li><li>单一分区；</li><li>单一消费者同步消费；</li></ol><p>第 1、3 点比较简单，Kafka 通过分区和 offset的方式保证了消息的顺序。每个分区都是一个有序的、不可变的消息序列，每个消息在分区中都有一个唯一的序数标识，称为<code>offset</code>。生产者在发送消息到分区时，Kafka会自动为消息分配一个 offset。消费者在读取消息时，会按照 offset的顺序来读取，从而保证了消息的顺序。</p><p>下面我们主要来谈一谈第 2 点。</p><h2 id="kafka-顺序消息的实现">Kafka 顺序消息的实现</h2><h3 id="写入消息的过程">写入消息的过程</h3><ol type="1"><li><strong>配置生产者</strong>：首先，你需要配置 Kafka生产者。这包括指定 Kafka集群的地址和端口，以及其他相关配置项，如消息序列化器、分区策略等。</li><li><strong>创建生产者实例</strong>：在应用程序中，你需要创建一个 Kafka生产者的实例。这个实例将用于与 Kafka 集群进行通信。</li><li><strong>序列化消息</strong>：在将消息发送到 Kafka集群之前，你需要将消息进行序列化。Kafka使用字节数组来表示消息的内容，因此你需要将消息对象序列化为字节数组。这通常涉及将消息对象转换为JSON、Avro、Protobuf 等格式。</li><li><strong>选择分区</strong>：Kafka的主题（topic）被分为多个分区（partition），每个分区都是有序且持久化的消息日志。当你发送消息时，你可以选择将消息发送到特定的分区，或者让Kafka 根据分区策略自动选择分区。</li><li><strong>发送消息</strong>：一旦消息被序列化并选择了目标分区，你可以使用Kafka 生产者的 <code>send()</code> 方法将消息发送到 Kafka集群。发送消息时，生产者会将消息发送到对应分区的 leader 副本。</li><li><strong>异步发送</strong>：Kafka生产者通常使用异步方式发送消息，这样可以提高吞吐量。生产者将消息添加到一个发送缓冲区（sendbuffer）中，并在后台线程中批量发送消息到 Kafka 集群。</li><li><strong>消息持久化</strong>：一旦消息被发送到 Kafka 集群的 leader副本，它将被持久化并复制到其他副本，以确保数据的高可靠性和冗余性。只有当消息被成功写入到指定数量的副本后，生产者才会收到确认（acknowledgement）。</li><li><strong>错误处理和重试</strong>：如果发送消息时发生错误，生产者可以根据配置进行错误处理和重试。你可以设置重试次数、重试间隔等参数来控制重试行为。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125013322459.png"alt="Kafka 生产者组件 -《Kafka权威指南第2版》" /><figcaption aria-hidden="true">Kafka 生产者组件-《Kafka权威指南第2版》</figcaption></figure><h3 id="实现单一分区">实现单一分区</h3><p>再 Kafka 中，我们要实现将消息写入到同一个分区，有 3 种思路：</p><ul><li>配置 <code>num.partitions=1</code> 或者创建 topic 的时候指定只有 1个分区，但这会显著降低 Kafka 的吞吐量。</li><li><strong>固定消息的 key</strong>，然后采用 <strong>key hash</strong>的分区策略，这样就可以让所有消息都被分到同一个分区中。</li><li>实现并指定<strong>自定义分区策略</strong>，可以根据业务需求，将需要顺序消费的消息都分到固定一个分区中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如下例子，所有使用&quot;same-key&quot;作为key的消息都会被发送到同一个Partition</span><br>ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;topic&quot;</span>, <span class="hljs-string">&quot;same-key&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>);<br>producer.send(record);<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题">重平衡带来的问题</h3><p>如果采用上述的第 2 种思路：<strong>固定消息 key，依靠 key hash分区策略，实现单一分区</strong>。在我们只有 1个消费者的情况下是没有问题的，但是如果我们使用的是消费者组，那么，在发生<strong>重平衡</strong>操作的时候，就可能会有问题了。</p><p>Kafka 的重平衡（Rebalance）是指 Kafka 消费者组（ConsumerGroup）中的消费者实例对分区的重新分配。这个过程主要发生在以下几种情况：</p><ol type="1"><li>消费者组中新的消费者加入。</li><li>消费者组中的消费者离开或者挂掉。</li><li>订阅的 Topic 的分区数发生变化。</li><li>消费者调用了 <code>#unsubscribe()</code> 或者<code>#subscribe()</code> 方法。</li></ol><p>重平衡的过程主要包括以下几个步骤：</p><ol type="1"><li><strong>Revoke</strong>：首先，Kafka会撤销消费者组中所有消费者当前持有的分区。</li><li><strong>Assignment</strong>：然后，Kafka会重新计算分区的分配情况，然后将分区分配给消费者。</li><li><strong>Resume</strong>：最后，消费者会开始消费新分配到的分区。</li></ol><p>重平衡的目的是为了保证消费者组中的消费者能够公平地消费 Topic的分区。通过重平衡，Kafka可以在消费者的数量发生变化时，动态地调整消费者对分区的分配，从而实现负载均衡。</p><p>然而，当发生重平衡时，分区可能会被重新分配给不同的消费者，这可能会影响消息的消费顺序。</p><p>举个例子：</p><ol type="1"><li>假设消费者 A 正在消费分区 P 的消息，它已经消费了消息 1，消息2，正在处理消息 3。</li><li>此时，发生了重平衡，分区 P 被重新分配给了消费者 B。</li><li>消费者 B 开始消费分区P，它会从上一次提交的偏移量（offset）开始消费。假设消费者 A 在处理消息 3时发生了故障，没有提交偏移量，那么消费者 B 会从消息 3 开始消费。</li><li>这样，消息 3 可能会被消费两次，而且如果消费者 B 处理消息 3的速度快于消费者A，那么消息 3 可能会在消息 2之后被处理，这就打破了消息的顺序性。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125003222491.png"alt="重平衡导致消息失序" /><figcaption aria-hidden="true">重平衡导致消息失序</figcaption></figure><p>再举个例子：</p><ol type="1"><li>topic-A 本来只有 3 个分区，按照 key hash，key 为<code>same-key</code> 的消息应该都发到 第 2 个分区；</li><li>但是后来 topic-A 变成了 4 个分区，按照 key hash，key 为<code>same-key</code> 的消息可能就被发到第 3 个分区了；</li><li>这就无法做到单一分区，可能会导致消息失序。</li></ol><p>当然这个例子不是由重平衡直接引起的，但是这种情况也是有可能导致消息失序的。</p><h3 id="缓解重平衡的问题">缓解重平衡的问题</h3><ul><li><strong>避免动态改变分区数</strong>：在需要严格保持消息顺序的场景下，应避免动态地改变分区数。这意味着在设计Kafka 主题时，应提前规划好所需的分区数，以避免日后需要进行更改。</li><li><strong>使用单个分区</strong>：对于严格顺序要求的场景，可以考虑使用单分区主题。虽然这会限制吞吐量和并发性，但可以保证消息的全局顺序。</li><li><strong>使用其他策略保持顺序</strong>：在某些情况下，可以通过在应用层实现逻辑来保持顺序，比如在消息中包含顺序号或时间戳，并在消费时根据这些信息重建正确的顺序。</li><li><strong>使用静态成员功能</strong>：它允许消费者在断开和重新连接时保持其消费者组内的身份，这可以减少因短暂的网络问题或消费者重启导致的不必要的重平衡。</li></ul><p>上面这些措施，只能减少重平衡带来的问题，并无法根除，如果非要实现严格意义上的顺序消息，要么在消息中加入时间戳等标记，在业务层保证顺序消费，要么就只能采用<code>单一生产者同步发送 + 单一分区 +单一消费者同步消费</code>这种模式了。</p><h3 id="静态成员功能">静态成员功能</h3><p>Kafka 2.3.0 版本引入了一项新功能：静态成员（StaticMembership）。这个功能主要是为了减少由于消费者重平衡（rebalance）引起的开销和延迟。在传统的Kafka消费者组中，当新的消费者加入或离开消费者组时，会触发重平衡。这个过程可能会导致消息的处理延迟，并且在高吞吐量的场景下可能会对性能造成影响。静态成员功能旨在缓解这些问题。以下是它的一些关键点：</p><p>静态成员的工作原理：</p><ol type="1"><li><p><strong>静态成员标识</strong>：消费者在加入消费者组时可以提供一个静态成员标识（StaticMember ID）。这允许 Kafka Broker识别特定的消费者实例，而不是仅仅依赖于消费者组内的动态分配。</p></li><li><p><strong>重平衡优化</strong>：当使用静态成员功能时，如果一个已知的消费者由于某种原因（如网络问题）短暂断开后重新连接，Kafka不会立即触发重平衡。相反，Kafka会等待一个预设的超时期限（session.timeout.ms），在此期间如果消费者重新连接，它将保留原来的分区分配。</p></li><li><p><strong>减少重平衡次数</strong>：这大大减少了由于消费者崩溃和恢复、网络问题或维护操作引起的不必要的重平衡次数。</p></li></ol><p>使用静态成员的优点：</p><ol type="1"><li><p><strong>提高稳定性</strong>：减少重平衡可以提高消费者组的整体稳定性，尤其是在大型消费者组和高吞吐量的情况下。</p></li><li><p><strong>减少延迟</strong>：由于减少了重平衡的次数，可以减少因重平衡导致的消息处理延迟。</p></li><li><p><strong>持久的消费者分区分配</strong>：这使得消费者在分区分配上更加持久，有助于更好地管理和优化消息的消费。</p></li></ol><p>如何使用：</p><ul><li>要使用静态成员功能，需要在 Kafka 消费者的配置中设置<code>group.instance.id</code>。这个 ID应该是唯一的，并且在消费者重启或重新连接时保持不变。同时，还需要配置<code>session.timeout.ms</code>，以决定在触发重平衡之前消费者可以离线多长时间。</li></ul><p>注意事项：</p><ul><li>虽然静态成员功能可以减少重平衡的发生，但它不会完全消除重平衡。在消费者组成员的长期变化（如新消费者的加入或永久离开）时，仍然会发生重平衡。</li><li>需要合理设置<code>session.timeout.ms</code>，以避免消费者由于短暂的网络问题或其他原因的断开而过早触发重平衡。</li></ul><p>静态成员功能在处理大规模 Kafka应用时尤其有用，它提供了一种机制来优化消费者组的性能和稳定性。</p><h3 id="幂等性">幂等性</h3><p>Kafka 0.11版本后提供了幂等性生产者，这意味着即使生产者因为某些错误重试发送相同的消息，这些消息也只会被记录一次。这是通过给每一批发送到Kafka 的消息分配一个序列号实现的，broker使用这个序列号来删除重复发送的消息。使用幂等性生产者，可以减少重复消息的风险，这意味着即使在网络重试等情况下，消息的顺序也能得到更好的保证。因为重复消息不会被多次记录，所以不会破坏已有消息的顺序。</p><h2id="其他常见消息队列顺序消息的实现">其他常见消息队列顺序消息的实现</h2><h3 id="pulsar">Pulsar</h3><p>Pulsar 和 Kafka 一样，都是通过生产端按 Key Hash的方案将数据写入到同一个分区。</p><h3 id="rabbitmq">RabbitMQ</h3><p>RabbitMQ 在生产时没有生产分区分配的过程。它是通过<code>Exchange</code> 和 <code>Route Key</code>机制来实现顺序消息的。<code>Exchange</code> 会根据设置好的<code>Route Key</code> 将数据路由到不同的 <code>Queue</code>中存储。此时 <code>Route Key</code> 的作用和 Kafka 的消息的<code>Key</code> 是一样的。</p><h3 id="rocketmq">RocketMQ</h3><p>RocektMQ支持<code>消息组（MessageGroup）</code>的概念。在生产端指定消息组，则同一个消息组的消息就会被发送到同一个分区中。此时这个消息组起到的作用和Kakfa 的消息的 Key 是一样的。</p><h2 id="实战-kafka-实现顺序消息">实战 Kafka 实现顺序消息</h2><blockquote><p>代码仓库：https://github.com/hedon954/kafka-go-examples/tree/master/orderedmsg</p></blockquote><p>下面我们来写一写实战用例，更加直观地感受一下 Kafka顺序消息的实现细节。</p><p>首先我们在集群上创建一个 topic <code>ordered-msg-topic</code>，分区为<code>3</code> 个，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>搭建 Kafka 集群可以看这两篇：<ahref="https://hedon.top/2023/11/22/kakfa-cluster-deploy/">Kafka集群搭建(Zookeeper)</a>、<ahref="https://hedon.top/2023/11/22/kafka-kraft-deploy/">Kafka集群搭建(KRaft)</a>。</p><h3 id="单生产者单消费者">单生产者单消费者</h3><p>正常情况下，使用单一生产者同步发送和单一消费者同步发送，只要我们保证key 是固定的，则所有消息都会写到同一个分区，是可以实现顺序消息的。</p><p>代码目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">├─config<br>│      config.go<span class="hljs-comment"># 常量定义</span><br>├─consumer<br>│      consumer.go<span class="hljs-comment"># 消费者</span><br>└─producer<br>        producer.go<span class="hljs-comment"># 生产者</span><br></code></pre></td></tr></table></figure><p>首先我们先定义一些常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>Topic      = <span class="hljs-string">&quot;ordered-msg-topic&quot;</span><br>Brokers    = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;kafka1.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka2.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka3.com:9092&quot;</span>&#125;<br>Addr       = kafka.TCP(Brokers...)<br>GroupId    = <span class="hljs-string">&quot;ordered-msg-group&quot;</span><br>MessageKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;message-key&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>我们先实现生产者端，主要是不断往 <code>ordered-msg-topic</code>中写入数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewProducer</span><span class="hljs-params">()</span></span> *kafka.Writer &#123;<br><span class="hljs-keyword">return</span> &amp;kafka.Writer&#123;<br>Addr:     config.Addr,<br>Topic:    config.Topic,<br>Balancer: &amp;kafka.Hash&#123;&#125;, <span class="hljs-comment">// 哈希分区</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMessages</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []kafka.Message &#123;<br>res := <span class="hljs-built_in">make</span>([]kafka.Message, count)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>res[i] = kafka.Message&#123;<br>Key:   config.MessageKey,<br>Value: []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;msg-%d&quot;</span>, i+<span class="hljs-number">1</span>)),<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>producer := NewProducer()<br>messages := NewMessages(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> err := producer.WriteMessages(context.Background(), messages...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>_ = producer.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来实现消费者，目前我们就启动 1 个消费者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span> &#123;<br>Id <span class="hljs-type">string</span><br>*kafka.Reader<br>&#125;<br><br><span class="hljs-comment">// NewConsumer 创建一个消费者，它属于 config.GroupId 这个消费者组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsumer</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> *Consumer &#123;<br>c := &amp;Consumer&#123;<br>Id: id,<br>Reader: kafka.NewReader(kafka.ReaderConfig&#123;<br>Brokers: config.Brokers,<br>GroupID: config.GroupId,<br>Topic:   config.Topic,<br>Dialer: &amp;kafka.Dialer&#123;<br>ClientID: id,<br>&#125;,<br>&#125;),<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// Read 读取消息，intervalMs 用来控制消费者的消费速度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Read(intervalMs <span class="hljs-type">int</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s start read\n&quot;</span>, c.Id)<br><span class="hljs-keyword">for</span> &#123;<br>msg, err := c.ReadMessage(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg err: %v\n&quot;</span>, c.Id, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 模拟消费速度</span><br>time.Sleep(time.Millisecond * time.Duration(intervalMs))<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg: %s, time: %s\n&quot;</span>, c.Id, <span class="hljs-type">string</span>(msg.Value), time.Now().Format(<span class="hljs-string">&quot;03-04-05&quot;</span>))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>启动生产者生产消息，然后启动消费者，观察控制台，不难看出这种情况下就是顺序消费：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">consumer-1 read msg: msg-10, time: 04:29:10<br>consumer-1 read msg: msg-11, time: 04:29:11<br>consumer-1 read msg: msg-12, time: 04:29:12<br>consumer-1 read msg: msg-13, time: 04:29:13<br>consumer-1 read msg: msg-14, time: 04:29:14<br>consumer-1 read msg: msg-15, time: 04:29:15<br>consumer-1 read msg: msg-16, time: 04:29:16<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题-1">重平衡带来的问题</h3><p>我们先重建 topic，清楚掉之前的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic ordered-msg-topic<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>下面我们来采用消费者组的形式消费消息，在这期间，我们不断往消费者组中新增消费者，使其发生重平衡，我们来观察下消息的消费情况。</p><p>修改消费者端的 main()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 先启动 c1</span><br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;()<br><br><span class="hljs-comment">// 5 秒后启动 c2</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c2 := NewConsumer(<span class="hljs-string">&quot;consumer-2&quot;</span>)<br>c2.Read(<span class="hljs-number">300</span>)<br>&#125;()<br><br><span class="hljs-comment">// 再 10 秒后启动 c3 和 c4</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c3 := NewConsumer(<span class="hljs-string">&quot;consumer-3&quot;</span>)<br>c3.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c4 := NewConsumer(<span class="hljs-string">&quot;consumer-4&quot;</span>)<br>c4.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先启动生产者重新生产数据，然后再启动消费者消费数据，观察控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">consumer-1 start <span class="hljs-built_in">read</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-1, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-2, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-3, time: 04:44:29<span class="hljs-comment"># consumer-1 按顺序消费</span><br>consumer-2 start <span class="hljs-built_in">read</span>  <span class="hljs-comment"># consumer-2 进来</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-4, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-5, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-6, time: 04:44:31      <span class="hljs-comment"># 这里相差了 6s，就是在进行重平衡</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37      <span class="hljs-comment"># 重平衡后发现原来的分区给 consumer-2 消费了</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37    <span class="hljs-comment"># 这里发生了重复消费</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-8, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-9, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-10, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-11, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-12, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-13, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-14, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-15, time: 04:44:39      <span class="hljs-comment"># consumer-2 按顺序消息</span><br>consumer-4 start <span class="hljs-built_in">read</span>   <span class="hljs-comment"># consumer-3 和 consumer-4 进来</span><br>consumer-3 start <span class="hljs-built_in">read</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-16, time: 04:44:40   <br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里发生重平衡</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-18, time: 04:44:46      <span class="hljs-comment"># 重平衡后由 consumer-4 负责该分区</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里由于 2 的速度比 4 慢很多，所以就乱序了，还重复消费</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-19, time: 04:44:46<br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-20, time: 04:44:46<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>当我们采用消费者组的时候，由于重平衡机制的存在，单纯从 Kafka的角度来说是无法完全实现顺序消息的，只能通过静态成员功能、避免分区数量变化和减少消费者组成员数量变化等方式来尽可能减少重平衡的发生，进而尽可能维持消息的顺序性。</p><h2 id="参考">参考</h2><ul><li><a href="https://time.geekbang.com/column/intro/100552001">极客时间- 深入拆解消息队列 47 讲（许文强）</a></li><li><a href="https://www.qidian.com/book/1035938080/">《Kafka权威指南（第 2 版）》</a></li><li><ahref="https://pulsar.staged.apache.org/docs/zh-CN/next/concepts-messaging/#%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81">Pulsar官方文档-分区topic-顺序保证</a></li><li><ahref="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">RocketMQ官方文档-功能特性-顺序消息</a></li><li><ahref="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">RabbitMQ官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署（KRaft）</title>
    <link href="/2023/11/22/kafka-kraft-deploy/"/>
    <url>/2023/11/22/kafka-kraft-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Kafka 3.6.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Kafka Broker 端口</th><th style="text-align: center;">Kafka Controller 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>   address 192.168.50.131<br>   netmask 255.255.255.0<br>   gateway 192.168.50.2<br>   dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><p>Ubuntu 系统使用 <code>systemd-resolved</code> 服务来管理DNS，你可以在 <code>/etc/systemd/resolved.conf</code> 文件中进行 DNS配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/systemd/resolved.conf<br></code></pre></td></tr></table></figure><p>取消或添加 <code>DNS</code> 的注释，并修改为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">[Resolve]<br>DNS=8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure><p>重启启动 <code>systemd-resolved</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart systemd-resolved<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/3.6.0/kafka_2.13-3.6.0.tgz<br>tar -zxvf kafka_2.13-3.6.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-3.6.0 /opt/kafka-3.6.0<br></code></pre></td></tr></table></figure></li><li><p>使用 Kafka 提供的脚本生成一个 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=<span class="hljs-string">&quot;<span class="hljs-subst">$(/opt/kafka-3.6.0/bin/kafka-storage.sh random-uuid)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>输出 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$KAFKA_CLUSTER_ID</span><br>XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure><p>在其他节点上将 <code>KAFKA_CLUSTER_ID</code> 设置为上面的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure></li><li><p>备份配置文件，注意这里的配置文件是<code>config/kraft/server.properties</code>，在 <code>config</code>目录下的 <code>kraft</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /opt/kafka-3.6.0/config/kraft/server.properties /opt/kafka-3.6.0/config/kraft/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>主要修改内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 节点 ID，分别为 1，2，3</span><br><span class="hljs-attr">node.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-3.6.0/kafka-combined-logs</span><br><span class="hljs-comment"># 可以成为控制器的节点和它们的端口</span><br><span class="hljs-attr">controller.quorum.voters</span>=<span class="hljs-string">1@kafka1.com:9093,2@kafka2.com:9093,3@kafka3.com:9093</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。</span><br><span class="hljs-comment"># 这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。</span><br><span class="hljs-comment"># 例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，</span><br><span class="hljs-comment"># 那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-comment"># 这里我们需要在 3 个节点分别设置对应的地址</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>格式化日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-storage.sh format -t <span class="hljs-variable">$KAFKA_CLUSTER_ID</span> -c /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Formatting /opt/kafka-3.6.0/kraft-combined-logs with metadata.version 3.6-IV2.<br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-server-start.sh -daemon /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>TopicId: svJClTUpSFa9Z6FWDvkARgPartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 2Replicas: 2Isr: 2<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 3Replicas: 3Isr: 3<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，往 <code>test</code> 里面写入数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>输入数据后按回车即发送一条数据，可以随时按 <code>Ctrl + C</code>退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~/Downloads$ /opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br>&gt;msg1<br>&gt;msg2<br>&gt;msg 3<br>&gt;^<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，启动消费者消费 <code>topic</code>中的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ /opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br>msg1<br>msg2<br>msg 3<br>^CProcessed a total of 3 messages<br></code></pre></td></tr></table></figure></li></ol><p>至此，Kafka 的 KRaft 版本集群就部署完毕了！</p><div class="note note-info">            <h2 id="补充说明---kraft-配置文件">补充说明 - KRaft 配置文件</h2><p>下面是 Kafka KRaft 版本配置文件每个配置项的解释：</p><table><thead><tr class="header"><th>配置项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>process.roles</td><td>Kafka 服务器的角色，设置此项将 Kafka 置于 KRaft 模式。可能的值包括"broker" 和 "controller"。</td></tr><tr class="even"><td>node.id</td><td>与此实例关联的节点 ID。</td></tr><tr class="odd"><td>controller.quorum.voters</td><td>控制器选举的投票节点，格式为 <code>node-id@host:port</code>。</td></tr><tr class="even"><td>listeners</td><td>服务器监听的地址，格式为<code>listener_name://host_name:port</code>。</td></tr><tr class="odd"><td>inter.broker.listener.name</td><td>用于 broker 之间通信的监听器名称。</td></tr><tr class="even"><td>advertised.listeners</td><td>服务器向客户端宣告的监听器名称、主机名和端口。</td></tr><tr class="odd"><td>controller.listener.names</td><td>控制器使用的监听器名称列表。</td></tr><tr class="even"><td>listener.security.protocol.map</td><td>监听器名称到安全协议的映射。默认情况下，它们是相同的。</td></tr><tr class="odd"><td>num.network.threads</td><td>服务器用于从网络接收请求和向网络发送响应的线程数。</td></tr><tr class="even"><td>num.io.threads</td><td>服务器用于处理请求（可能包括磁盘 I/O）的线程数。</td></tr><tr class="odd"><td>socket.send.buffer.bytes</td><td>服务器用于发送数据的缓冲区大小。</td></tr><tr class="even"><td>socket.receive.buffer.bytes</td><td>服务器用于接收数据的缓冲区大小。</td></tr><tr class="odd"><td>socket.request.max.bytes</td><td>服务器接受的请求的最大大小（用于防止内存溢出）。</td></tr><tr class="even"><td>log.dirs</td><td>用于存储日志文件的目录列表。</td></tr><tr class="odd"><td>num.partitions</td><td>每个主题的默认日志分区数。</td></tr><tr class="even"><td>num.recovery.threads.per.data.dir</td><td>每个数据目录在启动时用于日志恢复和关闭时用于刷新的线程数。</td></tr><tr class="odd"><td>offsets.topic.replication.factor</td><td>内部主题 "__consumer_offsets" 和 "__transaction_state"的复制因子。</td></tr><tr class="even"><td>transaction.state.log.replication.factor</td><td>事务状态日志的复制因子。</td></tr><tr class="odd"><td>transaction.state.log.min.isr</td><td>事务状态日志的最小同步副本数。</td></tr><tr class="even"><td>log.flush.interval.messages</td><td>强制将数据刷新到磁盘之前接受的消息数。</td></tr><tr class="odd"><td>log.flush.interval.ms</td><td>消息在日志中停留的最大时间，超过这个时间就会强制刷新到磁盘。</td></tr><tr class="even"><td>log.retention.hours</td><td>由于年龄而使日志文件有资格被删除的最小年龄。</td></tr><tr class="odd"><td>log.retention.bytes</td><td>基于大小的日志保留策略。</td></tr><tr class="even"><td>log.segment.bytes</td><td>日志段文件的最大大小。</td></tr><tr class="odd"><td>log.retention.check.interval.ms</td><td>检查日志段是否可以根据保留策略被删除的间隔。</td></tr></tbody></table><p>请注意，这只是 Kafka 配置的一部分，Kafka 配置的完整列表可以在 <ahref="https://kafka.apache.org/36/documentation.html#configuration">Kafka的官方文档</a>中找到。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署</title>
    <link href="/2023/11/22/kakfa-cluster-deploy/"/>
    <url>/2023/11/22/kakfa-cluster-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Zookeeper 3.5.9</li><li>Kafka 2.7.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Zookeeper 端口</th><th style="text-align: center;">Kafka 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>address 192.168.50.131<br>netmask 255.255.255.0<br>gateway 192.168.50.2<br>dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>追加下面内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">nameserver 8.8.8.8<br>nameserver 8.8.4.4<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-zookeeper">安装 zookeeper</h2><p>在 Ubuntu 上，您可以通过以下步骤安装 Apache Zookeeper 3.5.9：</p><ol type="1"><li>下载 Apache Zookeeper 3.5.9 的二进制文件。使用以下命令下载并解压缩Zookeeper：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz<br>tar -xzf apache-zookeeper-3.5.9-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> apache-zookeeper-3.5.9-bin /opt/zookeeper-3.5.9<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在 <code>/opt/zookeeper-3.5.9</code> 目录中创建一个名为<code>data</code> 的文件夹，用于存储 Zookeeper 的数据：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/zookeeper-3.5.9/data<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>在 <code>/opt/zookeeper-3.5.9/data</code> 下创建 myid文件并设置内容为 <code>1</code>，其他两台机器则为 <code>2</code> 和<code>3</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 | sudo <span class="hljs-built_in">tee</span> /opt/zookeeper-3.5.9/data/myid<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>复制 Zookeeper 配置文件样本，并将其命名为<code>zoo.cfg</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/zookeeper-3.5.9/conf/zoo_sample.cfg /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>使用文本编辑器（例如 vim）编辑 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>修改 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># The number of milliseconds of each tick</span><br>tickTime=2000<br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br>initLimit=10<br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br>syncLimit=5<br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># 设置数据存储目录</span><br>dataDir=/opt/zookeeper-3.5.9/data<br><span class="hljs-comment"># the port at which the clients will connect</span><br>clientPort=2181<br><span class="hljs-comment"># 设置集群信息</span><br>server.1=kafka1.com:2888:3888<br>server.2=kafka2.com:2888:3888<br>server.3=kafka3.com:2888:3888<br></code></pre></td></tr></table></figure><blockquote><p>在 Zookeeper 的配置文件中，<code>server.x=hostname:port1:port2</code>这种格式的配置项是用来设置 Zookeeper集群（集群模式下）的。其中，<code>x</code> 是服务器的ID，<code>hostname</code> 是服务器的主机名或 IP 地址，<code>port1</code>和 <code>port2</code> 是用于集群间通信的端口。</p><p>具体来说：</p><ul><li><p><code>port1（2888）</code>：这是服务器之间用于相互通信的端口。Zookeeper服务器使用这个端口进行 leader 选举以及同步 follower 和 leader之间的状态。</p></li><li><p><code>port2（3888）</code>：这个端口用于服务器之间的 leader选举。在 Zookeeper 集群启动或者在 leader 服务器崩溃后，follower服务器会通过这个端口进行新一轮的 leader 选举。</p></li></ul><p>这两个端口可以根据你的网络配置进行修改，但必须在所有的 Zookeeper服务器上保持一致。</p></blockquote><ol start="10" type="1"><li>三个节点都启动 Zookeeper 服务器：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh start<br></code></pre></td></tr></table></figure><p>可以连接到 Zookeeper 的端口上（默认是<code>2181</code>），通过发送四字命令 <code>srvr</code> 来验证 Zookeeper是否安装正确（部署集群的话需要把所有 Zookeeper 启动）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/zookeeper-3.5.9$ telnet localhost 2181<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>srvr<br>Zookeeper version: 3.5.9-83df9301aa5c2a5d284a9940177808c01bc35cef, built on 01/06/2021 19:49 GMT<br>Latency min/avg/max: 0/0/0<br>Received: 1<br>Sent: 0<br>Connections: 1<br>Outstanding: 0<br>Zxid: 0x0<br>Mode: standalone<br>Node count: 5<br>Connection closed by foreign host.<br></code></pre></td></tr></table></figure><ol start="11" type="1"><li>要停止 Zookeeper 服务器，可以使用以下命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh stop<br></code></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/2.7.0/kafka_2.13-2.7.0.tgz<br>tar -zxvf kafka_2.13-2.7.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-2.7.0 /opt/kafka-2.7.0<br></code></pre></td></tr></table></figure></li><li><p>创建日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/kafka-2.7.0/kafka-logs<br></code></pre></td></tr></table></figure></li><li><p>备份 Kafka 默认配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/kafka-2.7.0/config/server.properties /opt/kafka-2.7.0/config/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改 Kafka 配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure><p>主要是修改下面几个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 集群中每个 broker 的 id 必须唯一，这里分别为 1，2，3</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-2.7.0/kafka-logs</span><br><span class="hljs-comment"># 配置 Zookeeper</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">kafka1.com:2181,kafka2.com:2181,kafka3.com:2181</span><br><span class="hljs-comment"># 定义 Kafka Broker 在哪些网络地址上监听连接，下面配置表示在所有的 IP 地址上监听 9092 端口</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://:9092</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-server-start.sh -daemon /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>PartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 1Replicas: 1Isr: 1<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 2Replicas: 2Isr: 2<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft-Extended 论文翻译</title>
    <link href="/2023/11/18/raft/"/>
    <url>/2023/11/18/raft/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</p></blockquote><h2 id="辨析">辨析</h2><p><strong>consensus</strong> vs <strong>consistency</strong></p><p>一致性（consistency）往往指分布式系统中多个副本对外呈现的数据的状态。如顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p>共识（consensus）则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。</p><p>因此，一致性描述的是<strong>结果</strong>，共识则是一种<strong>手段</strong>。</p><p>有的人会说一致性和共识实际上是一个问题的一体两面，某种程度上来说，共识方法确实可以看作是实现强一致性的一种方法。事实上在工业界有许多以共识算法作为核心组件的多副本状态机（ReplicatedStateMachine）实现，本质上利用了共识算法保证了所有副本的操作日志具有完全相同的顺序，从而实现了副本的一致性。但是，即使是在这样的场景下，讨论一个共识算法的一致性也是不合适的，因<strong>为整个分布式系统最终的一致性并不单单取决于共识算法，共识算法只是解决了其中一个问题。</strong></p><blockquote><p>参考：https://zhuanlan.zhihu.com/p/68743917</p></blockquote><h2 id="摘要">0. 摘要</h2><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟multi-Paxos 作用相同，效率也相当。但是它的组织结构跟 Paxos不同，也是因为 Raft更简单的架构使得它更容易被理解，并且更容易在实际工程中得以实现。</p><p>为了让 Raft 更容易被理解，Raft将共识算法的关键性因素切分成几个部分，比如：</p><ul><li>leader election（领导者选举）</li><li>log replication（日志复制）</li><li>safety（安全性）</li></ul><p>并且 Raft实施了一种更强的共识性以便减少必须要考虑的状态（states）的数量。</p><p>用户研究表明，对于学生来说，Raft 相比于 Paxos 是更容易学习的。</p><p>Raft还包括一个用于解决<strong>变更集群成员问题</strong>的新机制，它使用重写多数来保证安全性。</p><h2 id="介绍">1. 介绍</h2><p>共识算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，共识算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，Paxos[15,16] 主导了关于共识算法的讨论：大多数共识性的实现都是基于 Paxos或受其影响，Paxos 已经成为教授学生关于共识知识的主要工具。</p><p>比较遗憾的是，尽管很多人一直在努力尝试使 Paxos 更易懂，Paxos还是太难理解了。此外，Paxos的架构需要复杂的改变来支持实际系统。这导致的结果就是系统开发者和学生在学生和使用Paxos 过程中都很挣扎。</p><p>在我们自己与 Paxos斗争之后，我们开始着手寻找一个新的共识算法，希望可以为系统开发和教学提供更好的基础。我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以设计一个比Paxos 更适合用于实际工程实现并且更易懂的共识算法吗？</p><p>在该算法的设计中，重要的不仅是如何让算法起作用，还要清晰地知道该算法为什么会起作用。</p><p>这项工作的结果是一个称为 Raft 的共识性算法。在设计 Raft时，我们使用了特定的技术来提高它的可理解性，包括：</p><ul><li>分解（Raft 分离出三个关键点：leader election、logreplication、safety）</li><li>减少状态空间（相比于 Paxos，Raft降低了不确定性的程度和服务器之间的不一致）</li></ul><p>一项针对 2 所大学共 43 名学生的用户研究表明，Raft 比 Paxos更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答 Raft的相关问题。</p><p>Raft 在许多方面类似于现有的公式算法（尤其是 Oki、Liskov 的Viewstamped Replication [29,22]），但它有几个新特性：</p><ul><li><strong>Strong leader（强领导性）</strong>：相比于其他算法，Raft使用了更强的领导形式。比如，日志条目只能从 leader 流向follower（集群中除 leader 外其他的服务器）。这在使 Raft更易懂的同时简化了日志复制的管理流程。</li><li><strong>Leader election（领导选举）</strong>：Raft使用随机计时器来进行领导选举。任何共识算法都需要心跳机制（heartbeats），Raft只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li><li><strong>Membership changes（成员变更）</strong>：Raft在更改集群中服务器集的机制中使用了一个 <strong>联合共识（jointconsensus）</strong> 的方法。在联合共识（jointconsensus）下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ul><p>我们认为 Raft 跟 Paxos以及其他共识算法相比是更优的，这不仅体现在教学方面，还体现在工程实现方面。</p><ul><li>它比其他算法更简单且更易于理解</li><li>它被描述得十分详细足以满足实际系统的需要</li><li>它有多个开源实现，并被多家公司使用</li><li>它的安全性已被正式规定和验证</li><li>它的效率与其他算法相当</li></ul><p>本文剩余部分：</p><table><thead><tr class="header"><th>所在节</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>第 2 节</td><td>复制状态机问题（replicated state machine problem）</td></tr><tr class="even"><td>第 3 节</td><td>Paxos 的优缺点</td></tr><tr class="odd"><td>第 4 节</td><td>实现 Raft 易理解性的措施</td></tr><tr class="even"><td>第 5-8 节</td><td>Raft 共识性算法详细阐述</td></tr><tr class="odd"><td>第 9 节</td><td>评估 Raft</td></tr><tr class="even"><td>第 10 节</td><td>其他相关工作</td></tr></tbody></table><h2 id="复制状态机">2. 复制状态机</h2><p>共识算法一般都是在复制状态机 [37]的背景下实现的。在这种方法下，一组服务器在的状态机计算相同状态的相同副本，即使某些服务器崩溃，它们也可以继续运行。</p><p>复制状态机是用来解决分布式系统中的各种容错问题。比如说，具有单个leader 的大规模的系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33]，他们通常都使用单独的复制状态机来管理 leader election 和保存 leader崩溃后重新选举所需的配置信息。像 Chubby [2] 和 ZooKeeper [11]都是复制状态机。</p><p>复制状态机通常都是使用日志复制（logreplication）来实现。如图1：每个服务器都保存着一份拥有一系列命令的日志，然后服务器上的状态机会按顺序执行日志中的命令。每一份日志中命令相同并且顺序也相同，因此每个状态机可以处理相同的命令序列。所以状态机是可确定的，每个状态机都执行相同的状态和相同的输出序列。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsmihlh9ptj322u0nsgpj.jpg"alt="image-20210719200404010" /><figcaption aria-hidden="true">image-20210719200404010</figcaption></figure><p>共识算法的主要工作就是保证复制日志（replicatedlog）的一致性。每台服务器上的共识模块接收来自客户端的命令，并将这些命令添加到其日志当中。它（指共识模块）与其他服务器上的共识模块进行通信，以确保每台服务器上最终以相同的顺序包含相同的命令，即使部分服务器崩溃了，这个条件也可以满足。一旦命令被正确复制，每台服务器上的状态机就会按日志顺序处理它们，并将输出返回给客户端。这样就形成了高可用的复制状态机。</p><p>适用于实际系统的共识算法通常都包含以下几点特征：</p><ul><li><p>它们确保在所有非拜占庭错误下的安全性，也就是从不返回一个错误的结果。（即使是网络延迟、分区、数据包丢失、数据包重复和数据包乱序）</p><blockquote><p><strong><ahref="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭错误</a>：</strong></p><p>出现故障（crash 或fail-stop，即不响应）但不会伪造信息的情况称为“非拜占庭错误”。</p><p>伪造信息恶意响应的情况称为“拜占庭错误”，对应节点称为拜占庭节点。</p></blockquote></li><li><p>只要任何大多数（过半）服务器是可运行的，并且可以互相通信和与客户端通信，那么共识算法就可用。假设服务器崩溃了，一小段时间后，它们很可能会根据已经稳定存储的状态来进行恢复，并重新加入集群。</p></li><li><p>它们在保证日志一致性上不依赖于时序：错误的时钟和极端消息延迟在最坏的情况下会产生影响可用性的一系列问题。</p></li><li><p>在通常情况下，只要集群中大部分（过半）服务器已经响应了单轮远程过程调用（RPC），命令就可以被视为完成。少数（一半以下）慢服务器不会影响整个系统的性能。</p></li></ul><h2 id="paxos-存在的问题">3. Paxos 存在的问题</h2><p>在过去的十年间，Leslie Lamport 的 Paxos 协议 [15]几乎成为共识性（consensus）的同义词。它是课堂上被教授最多的共识协议，大多数共识性的实现也是以它为起点。Paxos首先定义了能在单个决策问题（例如单个复制日志条目）上达成共识的协议。我们将这个子集称为<em>signle-degree Paxos</em>。然后 Paxos组合该协议的多个实例去实现一系列决策，比如日志（<em>mutil-Paxos</em>）。Paxos保证了安全性和活性，它也支持改变集群中的成员，它的安全性也已经被论证了，并且大多数情况下都是高效的。</p><p>美中不足的是，Paxos 有两个严重的缺点：</p><ol type="1"><li><p><strong>Paxos 非常难理解</strong></p><p>众所周知，Paxos非常晦涩难懂，除非下了很大的功夫，很少有人能够成功理解它。因此，尽管目前已经有几个尝试希望将Paxos [16,20,21] 解释得通俗易懂一些，而且这些解释都集中在<code>single-decree Paxos</code>，但是它们还是很难懂。</p><p>在对 NSDI 2012 参会者的非正式调查中，我们发现很少人会喜欢Paxos，即使是经验丰富的研究人员。我们自己也一直在跟 Paxos作斗争，我们也无法完全理解整个 Paxos协议，直到阅读了几个更简单的描述和自己设计了替代 Paxos 的协议，我们才对Paxos 有了比较深刻的理解。但这个过程，花了将近一年。</p><p>我们推测 Paxos 这么晦涩难懂，主要是因为作者选择了<code>Single-decree Paxos</code>来作为基础。<code>Single-decree Paxso</code>非常搞人：它分为两个阶段，但是并没有对这两个阶段进行简单直观的说明，而且这两个阶段也不能分开了单独理解，所以使用者将就很难理解为什么该算法能起作用。<code>Multi-Paxos</code>的合成规则又增加了许多复杂性。我们相信，对多个决定（日志，并非单个日志条目）达成共识的总体问题可以用其他更直接和更明显的方式进行分解。</p></li><li><p><strong>Paxos 没有为实际实现提供一个良好的基础</strong></p><p>其中一个原因是没有广泛认同的针对 <code>Multi-Paxos</code>的算法。Lamport 的描述主要是针对 <code>signle-decree Paxos</code>的，他描述了针对 <code>multi-Paxos</code>的可能方法，但缺少了很多细节。</p><p>目前已经有人在尝试具体化和优化 Paxos，比如 [26]，[39] 和[13]，但是这些尝试都互不相同并且它们跟 Lamport 描述的也不尽相同。虽然像Chubby [4] 这样的系统已经实现了类Paxos（Paxos-like）算法，但是他们并没有透露出很多的实现细节。</p></li></ol><p>此外，Paxos 的架构对于构建实际系统来说其实是一个糟糕的设计，这是<code>single-decree Paxos</code>分解的另一个结果。举个例子，这对于独立选择地日志条目的集合，然后再将它们合并到顺序日志当中没有任何好处，这只会增加复杂性。围绕日志来设计系统是更加简单和高效的方法，其中新条目按受约束的顺序依次附加。另外一个问题是Paxos在其核心使用了<strong>对称对等方法</strong>（尽管它最终表明了这会被用作一种性能优化的弱领导模式）。这在只有一个决策的情况下是有意义的，但是尽管如此，还是很少有实际系统采用了这种方法。如果有一系列的决策需要制定，更简单和更快速的方法应该是首先选择一个leader，然后由 leader 去协调这些决策。</p><p>因此，按照 Paxos 来实现的实际系统往往跟 Paxos相差很大。几乎所有的实现都是从 Paxos开始，然后在实现的过程中发现了一系列的难题，在解决难题的过程中，开发出了跟Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos本身的晦涩难懂又使得问题变得更加严重。Paxos公式可能是证明其正确性的一个很好的公式，但真正的实现与 Paxos又相差很大，这证明了它其实没有什么价值。下面来自 Chubby作者的评论非常典型：</p><blockquote><p>在 Paxos 算法描述和现实实现系统之间有着巨大的鸿沟... （如果一直按照Paxos 算法走下去），最终的系统往往会建立在一个还未被证明的协议之上。</p></blockquote><p>综合上述问题，我们觉得 Paxos在教学端和系统构建端都没有提供一个良好的基础。考虑到共识性在大规模软件系统中的重要性，我们决定去尝试一下看看能不能设计一个替代Paxos 并且具有更好特性的共识算法。Raft 就是这次实验的结果。</p><h2 id="为可理解性而设计">4. 为可理解性而设计</h2><p>在设计 Raft 算法过程中我们有几个目标：</p><ul><li>它必须为系统构建提供一个完整且实际的基础，这样才能大大减少开发者的工作</li><li>它必须在任何情况下都是安全的并且在典型的应用条件下是可用的，并且在正常情况下是高效的</li></ul><p>但是我们最重要的目标，也是我们遇到的最大的挑战：</p><ul><li>它必须具有易理解性，它必须保证能够被大多数人轻松地理解。而且它必须能够让人形成直观的认识，这样系统构建者才能在实现过程中对它进行不可避免的拓展。</li></ul><p>在设计 Raft算法的过程中，很多情况下我们需要在多个备选方案下做出抉择。在这种情况下，我们往往会基于可理解性来进行抉择：</p><ul><li>解释各个备选方案的难度有多大？例如，它的状态空间有多复杂？它是否具有难以理解的含义？</li><li>对于一个读者来说，完成理解这个方案和方案中的各种含义是否简单？</li></ul><p>我们意识到这一的分析具有高度的主观性。所以我们采取了两种通用的措施来解决这个问题。</p><ol type="1"><li>第一个措施就是众所周知的问题分解：只要有可能，我们就将问题划分成几个相对独立地解决、解释和理解的子问题。例如，Raft算法被我们划分成 leader 选举、日志复制、安全性和成员变更几个部分。</li><li>第二个措施是通过减少状态的数量来简化状态空间，尽可能地使系统变得更加连贯和尽可能地消除不确定性。很明显的一个例子就是，所有的日志都是不允许有空挡的，并且Raft限制了日志之间可能不一样的方式。尽管在大多数情况下我们都极力去消除不确定性，但是在某些情况下不确定性却可以提高可理解性。一个重要的例子就是随机化方法，它们虽然引入了不确定性，但是它们往往能够通过以类似的方式处理所有可能的选择来减少状态空间（随便选，没关系）。所有我们使用了随机化来简化Raft 中的 leader election 算法。</li></ol><h2 id="raft-共识算法">5. Raft 共识算法</h2><p>Raft 是一种用来管理第 2 节中提到的复制日志（replicatedlog）的算法。图 2 是该算法的浓缩，可以作为参考。图 3列举了该算法的一些关键特性。这两张图中的内容将会在后面的各个章节中逐一介绍。</p><p>Raft 在实现共识算法的过程中，首先选举一个 distinguishedleader，然后由该 leader 全权负责复制日志的一致性。Leader从客户端接收日志条目，然后将这些日志条目复制给其他服务器，并且在保证安全性的情况下通知其他服务器将日志条目应用到他们的状态机中。拥有一个leader 大大简化了对复制日志的管理流程。例如，leader可以在不跟其他服务器商议的情况下决定新的日志条目应该存放在日志的什么位置，并且数据都是从leader 流向其他服务器。当然了，一个 leader可能会崩溃，也可能与其他服务器断开连接，那么这个时候，Raft就会选举出一个新的 leader 出来。</p><p>通过选举一个 leader 的方式，Raft将共识问题分解成三个独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p><ul><li><p><strong>Leader election（领导选举）</strong></p><p>一个 leader 倒下之后，一定会有一个新的 leader 站起来。</p></li><li><p><strong>Log replication（日志复制）</strong></p><p>leader必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</p></li><li><p><strong>Safety（安全性）</strong></p><p>Raft 中安全性的关键是图 3中状态机的安全性：只要有任何服务器节点将一个特定的日志条目应用到它的状态机中，那么其他服务器节点就不能在同一个日志索引位置上存储另外一条不同的指令。第5.4 节将会描述 Raft 如何保证这种特性，而且该解决方案在 5.2节描述的选举机制上还增加了额外的限制。</p></li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsar1v5rklj32300pc4bj.jpg"alt="image-20210709155333989" /><figcaption aria-hidden="true">image-20210709155333989</figcaption></figure><p>在展示了 Raft共识算法后，本章节将讨论可用性的一些问题以及时序在系统中的所用。</p><h3 id="raft-基础">5.1 Raft 基础</h3><p>一个 Raft 集群中包含若干个服务器节点，<font color="green"><strong>5个一个比较典型的数字，5 个服务器的集群可以容忍 2个节点的失效</strong></font>。在任何一个时刻，集群中的每一个节点都只可能是以下是三种身份之一：</p><ul><li>leader：它会处理所有来自客户端的请求（如果一个客户端和 follower通信，follower 会将请求重定向到 leader 上）</li><li>follower：它们被动的：它们不会发送任何请求，只是简单的响应来自leader 和 candidate 的请求</li><li>candidate：这是用来选举一个新的 leader的时候出现的一种临时状态，这将在第 5.2 节中详细描述</li></ul><p>在正常情况下，集群中只有一个 leader，然后剩下的节点都是 follower。图4展示了这些状态和它们之间的转换关系，这些转换关系将会在接下来进行讨论。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsap8d6ijjj322s0l47g5.jpg"alt="image-20210709145034498" /><figcaption aria-hidden="true">image-20210709145034498</figcaption></figure><p>如图 5 所示，Raft将时间划分成任意长度的任期（term）。每一段任期从一次选举开始，在这个时候会有一个或者多个candidate 尝试去成为 leader。如果某一个 candidate赢得了选举，那么它就会在任期剩下的时间里承担一个 leader的角色。在某些情况下，一次选举无法选出 leader，这个时候这个任期会以没有leader而结束。同时一个新的任期（包含一次新的选举）会很快重新开始。这是因为Raft 会保证在任意一个任期内，至多有一个 leader。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsapcmhhi4j31ym0ig78s.jpg"alt="image-20210709145441879" /><figcaption aria-hidden="true">image-20210709145441879</figcaption></figure><p>集群中不同的服务器观察到的任期转换的次数也许是不同的，在某些情况下，一个节点可能没有观察到leader 选举过程甚至是整个任期过程。</p><p>任期在 Raft 中还扮演着一个逻辑时钟（logicalclock）的角色，这使得服务器可以发现一些过期的信息，比如过时的leader。</p><p>每一个节点都存储着一个当前任期号（current termnumber），该任期号会随着时间<strong>单调递增</strong>。节点之间通信的时候会交换当前任期号，如果一个节点的当前任期号比其他节点小，那么它就将自己的任期号更新为较大的那个值。如果一个candidate 或者 leader 发现自己的任期号过期了，它就会立刻回到 follower状态。如果一个节点接收了一个带着过期的任期号的请求，那么它会拒绝这次请求。</p><p>Raft 算法中服务器节点之间采用 RPC进行通信，一般的共识算法都只需要两种类型的 RPC。</p><ul><li><strong>RequestVote RPCs（请求投票）</strong>：由 candidate在选举过程中发出（5.2 节中描述）</li><li><strong>AppendEntries RPCs（追加条目）</strong>：由 leader发出，用来做日志复制和提供心跳机制（5.3 节中描述）。</li></ul><p>在第 7 节中为了在节点之间传输快照（snapshot）增加了第三种RPC。当节点没有及时的收到 RPC的响应时，会进行重试，而且节点之间都是以并行（parallel）的方式发送 RPC请求，以此来获得最佳的性能。</p><h3 id="leader-election">5.2 Leader election</h3><p>Raft 采用一种心跳机制来触发 leader选举。当服务器启动的时候，他们都会称为 follower。一个服务器节点只要从candidate 或者 leader 那接收到有效的 RPC 就一直保持 follower的状态。Leader 会周期性地向所有的 follower 发起心跳来维持自己的 leader地位，所谓心跳，就是不包含日志条目的 AppendEntries RPC。如果一个follower 在一段时间内没有收到任何信息（这段时间我们称为<strong>选举超时election timeout</strong>），那么它就会假定目前集群中没有一个可用的leader，然后开启一次选举来选择一个新的 leader。</p><p>开始进行选举的时候，一个 follower 会自增当前任期号然后切换为candidate 状态。然后它会给自己投票，同时以并行的方式发送一个 RequestVoteRPCs 给集群中的其他服务器节点（企图得到它们的投票）。一个 candidate会一直保持当前状态直到以下的三件事之一发生（这些情况都会在下面的章节里分别讨论）：</p><ul><li>它赢得选举，成为了 leader</li><li>其他节点赢得了选择，那么它会变成 follower</li><li>一段时间之后没有任何节点在选举中胜出</li></ul><p>当一个 candidate获取集群中过半服务器节点针对同一任期的投票时，它就赢得了这次选举并成为新的leader。对于同一个任期，每一个服务器节点会按照<strong>先来先服务原则（first-come-first-served）</strong> 只投给一个candidate（在5.4节会在投票上增加额外的限制）。这种要求获得过半投票才能成为 leader的规则确保了最多只有一个 candidate 赢得此次选举（图 3中的选举安全性）。只要有一个 candidate 赢得选举，它就会成为leader。然后它就会向集群中其他节点发送心跳消息来确定自己的地位并阻止新的选举。</p><p>一个 candidate在等待其他节点给它投票的时候，它也有可能接收到另外一个自称为 leader的节点给它发过来的 AppendEntries RPC。</p><ul><li>如果这个 leader 的任期号（这个任期号会在这次 RPC中携带着）不小于这个 candidate 的当前任期号，那么这个 candidate就会觉得这个 leader 是合法的，然后将自己转变为 follower 状态。</li><li>如果这个 leader 的任期号小于这个 candidate 的当前任期号，那么这个candidate 就会拒绝这次 RPC，然后继续保持 candidate 状态。</li></ul><p>第三种可能的结果是 candidate既没有赢得选举也没有输。可以设想一下这么一个情况。所有的 follower同时变成 candidate，然后它们都将票投给自己，那这样就没有 candidate能得到超过半数的投票了，投票无果。当这种情况发生的时候，每个 candidate都会进行一次超时响应（timeout），然后通过自增任期号来开启一轮新的选举，并启动另一轮的 RequestVoteRPCs。然而，如果没有额外的措施，这种无结果的投票可能会无限重复下去。</p><p>为了解决上述问题，Raft 采用 <strong>随机选举超时时间（randomizedelection timeouts）</strong>来确保很少发生无果的投票，并且就算发生了也能很快地解决。<strong>为了防止选票一开始就被瓜分，选举超时时间是从一个固定的区间（比如，150-300ms）中随机选择。这样可以把服务器分散开来以确保在大多数情况下会只有一个服务器率先结束超时，那么这个时候，它就可以赢得选举并在其他服务器结束超时之前发送心跳</strong>（译者注：乘虚而入，不讲武德）。</p><p>同样的机制也可以被用来解决选票被瓜分（split votes）的情况。每个candidate在开始一轮选举之前会重置一个随机选举超时时间，然后一直等待直到结束超时状态。这样减少了在一次投票无果后再一次投票无果的可能性。9.3节展示了该方案能够快速地选出一个 leader。</p><p>选举的例子可以很好地展现可理解性是如何指导我们在多种备选设计方案中做出抉择的。在一开始，我们本打算使用一种等级系统（ranksystem）：每一个 candidate 被赋予一个一次的等级（rank），如果一个candidate 发现另外一个 candidate 有着更高的登记，那么它就会返回 follower状态，这样可以使高等级的 candidate更加容易地赢得下一轮选举。但是我们发现这种方法在可用性方面会有一些小问题：<strong>如果等级较高的服务器崩溃了，那么等级较低的服务器可能需要进入超时状态，然后重新成为一个candidate。如果这种操作出现得太快，那么它可能会重启进程去开启一轮新的选举。</strong>经过我们对该算法做出了多次的调整，我们最终还是认为随机重试的方法更加通俗易懂。</p><h3 id="log-replication">5.3 Log replication</h3><p>Leader一旦被选举出来，它就要开始为客户端的请求提供服务了。每一个客户端请求都包含一条将被复制状态机执行的命令。leader会以一个新条目的方式将该命令追加到自己的日志中，并且以同步的方式向集群中的其他节点发起AppendEntiresRPCs，让它们复制该条目。当条目被安全地复制（何为安全复制，后面会介绍）之后，leader会将该条目应用到自己的状态机中，状态机执行该指令，然后把执行的结果返回给客户端。如果follower 崩溃了或者运行缓慢，或者网络丢包，leader 会不断地重试AppendEntiries RPCs（即使已经对客户端作出了响应）直到所有的 follower都成功存储了所有的日志条目。</p><p>日志以图 6 展示的方式组织着。每条日志条目都存储着一条状态机指令和leader收到该指定时的任期号。日志条目中的任期号可以用来检测多个日志副本之间是否不一致，以此来保证图3中的某些性质。每个日志条目还有一个整数索引值来表明它在日志中的位置。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsasp7ss8gj32220ssjy9.jpg"alt="image-20210709165036190" /><figcaption aria-hidden="true">image-20210709165036190</figcaption></figure><p>那么问题就来了，<strong>leader什么时候会觉得把日志条目应用到状态机是安全的呢？</strong>这种日志条目被称为已提交的日志条目。Raft保证这种已提交的日志条目都是持久化的并且最终都会被所有可用的状态机执行。<strong>一旦创建该日志条目的 leader 将它复制到过半的节点上时（比如图 6中的条目 7），该日志条目就会被提交。</strong> 同时，leader日志中该日志条目之前的所有日志条目也都会被提交，包括由之前的其他 leader创建的日志条目。5.4 节会讨论在 leader变更之后应用该规则的一些细节，并证明这种提交的规则是安全的。leader会追踪它所知道的要提交的最高索引，并将该索引包含在未来的 AppendEntriesRPC 中（包括心跳），以便其他的节点可以发现这个索引。一旦一个 follower知道了一个日志条目被提交了。它就会将该日志条目按日志顺序应用到自己的状态机中。</p><p>我们设计 Raft日志机制来使得不同节点上的日志之间可以保持高水平的一致性。这么做不仅简化了系统的行为也使得系统更加可预测，同时该机制也是保证安全性的重要组成部分。Raft会一直维护着以下的特性，这些特性也同时构成了图 3 中的日志匹配特性（LogMatching Property）：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期值，那么它们就存储着相同的命令</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么他们之前的所有日志条目也都相同</li></ul><p>第一条特性源于这样一个事实，在给定的一个任期值和给定的一个日志索引中，一个leader最多创建一个日志条目，而且日志条目永远不会改变它们在日志中的位置。</p><p>第二条特性是由 AppendEntries RPC执行的一个简单的一致性检查所保证的。当 leader 发送一个 AppendEntries RPC的时候，leader会将前一个日志条目的索引位置和任期号包含在里面（紧邻最新的日志条目）。如果一个follower在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性（LogMatchingProperty）的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，当AppendEntries RPC 返回成功时，leader 就知道 follower的日志一定和自己相同（从第一个日志条目到最新条目）。</p><p>正常操作期间，leader 和 follower 的日志都是保持一致的，所以AppendEntries 的一致性检查从来不会失败。但是，如果 leader崩溃了，那么就有可能会造成日志处于不一致的状态，比如说老的 leader可能还没有完全复制它日志中的所有条目它就崩溃了。这些不一致的情况会在一系列的leader 和 follower 崩溃的情况下加剧。图 7 解释了什么情况下 follower的日志可能和新的 leader 的日志不同。follower 可能会确实一些在新 leader中有的日志条目，也有可能拥有一些新的 leader没有的日志条目，或者同时存在。缺失或多出日志条目的情况有可能会涉及到多个任期。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse5vxj5sfj31se0u017c.jpg"alt="image-20210712144330139" /><figcaption aria-hidden="true">image-20210712144330139</figcaption></figure><p>在 Raft 算法中，leader 通过强制 follower 复制 leader日志来解决日志不一致的问题。也就是说，follower 中跟 leader冲突的日志条目会被 leader 的日志条目所覆盖。5.4节会证明通过增加一个限制，这种方式就可以保证安全性。</p><p>为了使 follower 的日志跟自己（leader）一致，leader必须找到两者达成一致的最大的日志条目索引，删除 follower日志中从那个索引之后的所有日志条目，并且将自己那个索引之后的所有日志条目发送给follower。所有的这些操作都发生在 AppendEntries RPCs的一致性检查的回复中。leader 维护着一个针对每一个 follower 的<strong>nextIndex</strong>，这个 nextIndex 代表的就是 leader 要发送给follower 的下一个日志条目的索引。<strong>当选出一个新的 leader 时，该leader 将所有的 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图7 中的 11）</strong>。如果一个 follower 的日志跟 leader的是不一致的，那么下一次的 AppendEntries RPC的一致性检查就会失败。<strong>AppendEntries RPC 在被 follower拒绝之后，leader 对 nextIndex 进行减 1，然后重试 AppendEntries RPC。最终nextIndex 会在某个位置满足 leader 和 follower在该位置及之前的日志是一致的，此时，AppendEntries RPC 就会成功，将follower 跟 leader 冲突的日志条目全部删除然后追加 leader中的日志条目（需要的话）</strong>。一旦 AppendEntries RPC 成功，follower的日志就和 leader 的一致了，并且在该任期接下来的时间里都保持一致。</p><blockquote><p>如果需要的话，下面的协议可以用来优化被拒绝的 AppendEntries RPCs的个数。</p><p>比如说，当拒绝一个 AppendEntries RPC 的时候，follower可以包含冲突条目的任期号和自己存储的那个任期的第一个index。借助这些信息，leader 可以跳过那个任期内所有的日志条目来减少indexIndex。这样就变成了每个有冲突日志条目的任期只需要一个 AppendEntriesRPC，而不是每一个日志条目都需要一次 AppendEntires RPC。</p><p>在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p></blockquote><p>通过上述机制，leader在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。leader只需进行正常的操作，然后日志就能在回复 AppendEntries RPC一致性检查的时候自动趋于一致。leader从来不会重写或者删除自己的日志条目（图3 中的 Leader Append-Only属性）。</p><p>上述这种日志复制机制展现了第 2 节中描述的 Raft算法的共识特性：只要过半的节点能正常运行，Raft就能接受、复制并处理新的日志条目。在通常情况下，一个新的条目可以在一轮RPC 中被复制给集群中过半的节点，并且单个运行缓慢的 follower并不会影响整个集群的性能。</p><blockquote><p>译者注：<strong>总结</strong></p><p>Leader 收到 Client 的写请求，向所有 Follower发起一个日志同步请求，得到集群内过半节点（包括 Leader自己）的响应，就推进 commitIndex，然后 apply 日志到状态机，再推进applyIndex，返回 Client 成功。</p><p>状态机同步分为两轮 RPC 广播：</p><ul><li>第一轮：同步日志 AppendEntries，得到过半节点回复，Leader状态机推进，返回 Client 成功。</li><li>第二轮：在下一次的 AppendEntries 中附带上一次的commitIndex，Follower 收到后，apply 日志条目到各自的状态机。</li></ul></blockquote><h3 id="safety">5.4 Safety</h3><p>前面的章节描述了 Raft 如何做 Leader Election 和 LogReplication。然而，到目前为止所讨论的机制并不能充分地保证每一个状态机会按相同的顺序执行相同的指令。比如说，一个follower 可能会进入不可用状态，在此期间，leader可能提交了若干的日志条目，然后这个 follower 可能被选举为新的 leader并且用新的日志条目去覆盖这些日志条目。这样就会造成不同的状态机执行不同的指令的情况。</p><p>本节通过对 Leader Election 增加一个限制来完善 Raft算法。这个限制保证了对于给定的任意任期号，该任期号对应的 leader都包含了之前各个任期所有被提交的日志条目（图3 中的 Leader Completeness性质）。有了这个限制，我们也可以使日志提交规则更加清晰。最后，我们会展示对于Leader Completeness性质的简要证明并且说该性质是如何保证状态机执行正确的行为的。</p><h4 id="选举限制">5.4.1 选举限制</h4><p>在任何基于 leader 的共识算法中，leader最终都必须存储所有已经提交的日志条目。在某些共识算法中，例如 ViewstampedReplication[22]，即使一个节点它一开始并没有包含所有已经提交的日志条目，它也有可能被选举为leader。这些算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的leader，这个机制要么发生在选举阶段，要么在选举完成之后很快进行。比较遗憾的是，这种方法会增加许多额外的机制，使得算法复杂性大大增加。Raft使用了一种更加简单的方法，它可以保证新 leader在当选时就包含了之前所有任期中已经提交的日志条目，根本就不需要再传送这些日志条目给新的leader。这就意味着<strong>日志条目的传送只有一个方向，那就是从 leader 到follower，leader 从来不会覆盖本地日志中已有的日志。</strong></p><p>Raft 采用投票的方式来保证一个 candidate只有拥有之前所有任期中已经提交的日志条目之后，才有可能赢得选举。一个candidate 如果想要被选为leader，那它就必须跟集群中超过半数的节点进行通信，这就意味这些节点中至少一个包含了所有已经提交的日志条目。如果candidate的日志至少跟过半的服务器节点一样新，那么它就一定包含了所有以及提交的日志条目，一旦有投票者自己的日志比candidate 的还新，那么这个投票者就会拒绝该投票，该 candidate也就不会赢得选举。</p><blockquote><p>所谓 “<strong>新</strong>” ：</p><p>Raft通过比较两份日志中的最后一条日志条目的索引和任期号来定义谁的日志更新。</p><ul><li>如果两份日志最后条目的任期号不同，那么任期号大的日志更新</li><li>如果两份日志最后条目的任期号相同，那么谁的日志更长，谁就更新</li></ul></blockquote><h4 id="提交之前任期内的日志条目">5.4.2 提交之前任期内的日志条目</h4><blockquote><p>译者注：注意！这一节「提交之前任期内的日志条目」这种操作 Raft的不允许的！本小节只是用来举一种错误情况！</p></blockquote><p>如 5.3节中提到的那样，一旦当前任期内的某个日志条目以及存储到过半的服务器节点上，leader就知道该日志可以被提交了。如果这个 leader在提交某个日志条目之前崩溃了，以后的 leader会尝试完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到了过半的服务器节点上了，新任期内的leader 也无法立即断定该日志条目已经被提交了。图 8展示了一种情况：一个已经被存储到过半节点的老日志条目，仍然有可能会被未来的leader 覆盖掉。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse88t4iicj31wc0u0ts1.jpg"alt="image-20210712160506841" /><figcaption aria-hidden="true">image-20210712160506841</figcaption></figure><blockquote><p>译者注：<strong>对图 8 的理解的补充</strong>。</p><p><font color="orange">参考：</font></p><ul><li><a href="https://zhuanlan.zhihu.com/p/369989974">知乎</a></li></ul><p><font color="orange">核心：</font></p><ul><li><strong>图 8 用来说明为什么 leader不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</strong></li></ul><p><font color="orange">分析：</font></p><ol type="1"><li>先按错误的情况，也就是 leader 提交之前任期的日志，那么上述的流程：<ol type="1"><li><ol type="a"><li>S1 是任期 2 的 leader，日志已经复制给了 S2，此时还没过半；</li></ol></li><li><ol start="2" type="a"><li>S1 崩溃，S5 获得了 S3、S4、S5 的投票成为leader，然后写了一个日志条目（index=2，term=3）；</li></ol></li><li><ol start="3" type="a"><li>S5 刚写完日志，还没来得及复制，就崩溃了，此时 S1 和 S2都可能当选，加入 S1 当选（currentTerm=4），此刻还没有新的请求进来，S1将日志条目（index=2，term=2）复制给了 S3，多数派达成，S1提交了这个日志条目（index=2，term=2），<strong>注意，该日志不是当前任期内的日志，我们在讨论错误的情况！</strong>然后请求进来，S1 写日志条目（index=3，term=4），然后 S1 崩溃。</li></ol></li><li>情况一：(d) S5 重启，因为 S5 最后的日志条目的任期号比 S2、S3大，所以 S5 可以赢得选举（currentTerm=5），S5将日志条目（index=2，item=3）复制给其他所有节点并提交， <strong>此时index=2 的日志条目被提交了两次！一次term=2，一次term=3，这是不被允许的，因为已经提交的日志条目是不能被覆盖的！</strong>✖️</li><li>情况二：(e) S1在崩溃之前将自己的日志条目（index=3，term=4）复制到了过半节点上，这种情况下，S5不可能选举成功。这是 S1 不发生故障，这是正确复制的情况。✔️</li></ol></li></ol><p>所以 <strong>「leader 可以提交之前任期的日志」</strong>这种操作是不允许的，我们需要加上约束： <strong>「leader只能提交自己任期的日志」</strong> 。</p><ol start="2" type="1"><li><p>加了约束之后，前面的 (a) 和 (b) 没有改变，从 (c) 开始：</p><ol type="1"><li><ol start="3" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。如果 S1将日志条目（index=3，term=4）也复制给了过半的节点，S1是可以提交该日志条目的，那么这个时候，前面的日志条目（index=2，term=2）也会被间接提交，这就是(e) 所展示的情况。</li></ol></li><li><ol start="4" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。但是这个时候，S1只是日志条目（index=3，term=4）写入自己的日志，还没来得及复制就崩溃了。然后S5重启并赢得了选举（currentTerm=5），然后将日志条目（index=2，term=3）复制给其他所有节点，现在index=2 的日志条目是没有提交过的，S5 能提交该日志吗？</li></ol><strong>不能！因为 leader不能提交之前任期的日志！只有等新的请求进来，超过半数节点复制了 1-3-5之后，term=3 的日志才能跟着 term=5 的日志一起被提交。</strong></li></ol></li></ol><p><font color="orange">延伸：</font></p><p>加了上述约束后，就不会出现同一个 index上的日志条目被重复提交的情况了，但是这又多出了另外一个问题了：<strong>如果一直没有新的请求进来，那么日志条目（index=2，term=3）岂不是就一直不能提交？那不就阻塞了吗？</strong></p><p>这里如果是 kv 数据库，问题就很明显了。假设 (c) 或 (d)中的日志条目（index=2）里的 Command 是 <code>Set("k", "1")</code>，S5当选 leader 后，客户端来查询 <code>Get("k")</code>，leader查到日志有记录但又不能回复 1给客户端（因为按照约束这条日志未提交），线性一致性要求不能返回陈旧的数据，leader迫切地需要知道这条日志到底能不能提交。</p><p>所以 Raft 论文提高了引入 <strong>no-op日志</strong>来解决这个问题，这个在 etcd 中有实现。</p><p><font color="orange">no-op 日志：</font></p><p>no-op 日志即只有 index 和 term 信息，command信息为空。也是要写到磁盘存储的。</p><p>具体流程是<strong>在 leader 刚选举成功的时候，立即追加一条 no-op日志，并立即复制到其它节点，no-op 日志一经提交，leader前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了no-op 日志之后，Leader 就能快速响应客户端查询了。</strong></p><p>本质上，no-op 日志使 leader隐式地快速提交之前任期未提交的日志，确认当前<code>commitIndex</code>，这样系统才会快速对外正常工作。</p></blockquote><p>为了解决图 8 中描述的问题，Raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader当期内的日志条目才通过计算副本数目的方式来提交。一旦当前任期内的某个日志条目以这种方式被提交（如图8 中的 e），那么由于日志匹配特性（LogMatching），之前的所有日志条目也会被间接地提交。在某些情况下，leader可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经被存储到每一个节点上了）。但是Raft 为了简化问题，采取了上述描述的更加保守的方法。</p><p>Raft 会在提交规则上增加额外的复杂性是因为当 leader复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的共识算法中，如果一个新的leader 要重新复制之前任期里的日志时，它必须使用当前新的任期号。Raft的做法使得更加容易推导出日志条目，因为它们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft中的新 leader只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p><h4 id="安全性论证">5.4.3 安全性论证</h4><p>给出了完整的 Raft 算法后，我们现在可以更严格地来论证 leader完整性特性（Leader Completeness Property）（这一讨论基于 9.2节的安全性证明）。我们先假设 Leader Completeness Property是不满足的，然后再推出矛盾来。</p><p><strong>假设：</strong></p><p>假设任期 T 的 leader<sub>T</sub>在任期内提交了一个日志条目，但是该日志条目没有存在未来某些任期的 leader中，假设 U 是大于 T 的没有存储该日志条目的最小任期号，处在任期 U 的leader 称为 leader<sub>U</sub>。</p><p><strong>论证：</strong></p><ol type="1"><li><p>因为 leader从来不删除或重写自己的日志条目，所以如果一个已提交的日志要做到不存在未来的leader<sub>U</sub> 中的话，那么它只可能在 leader<sub>U</sub>选举的过程中被丢失。</p></li><li><p>leader<sub>T</sub>将该日志复制给了集群中过半的节点，leader<sub>U</sub>从集群中过半的节点得到了投票。因此，至少有一个节点（这里称它为voter）同时接收了来自 leader<sub>T</sub> 的日志条目并且给leader<sub>U</sub> 投票了。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsfipd3u1tj322c0j2wju.jpg"alt="image-20210713185232381" /><figcaption aria-hidden="true">image-20210713185232381</figcaption></figure></li><li><p>voter 必然在给 leader<sub>U</sub>投票之前就已经接收了这个已经提交的日志条目了。否则，它就会拒绝来自leader<sub>T</sub> 的 AppendEntries RPC 请求，因为如果它在给leader<sub>U</sub> 投票之后再接收条目的话，那么它的当前任期号会比 T大。</p><blockquote><p>译者注：因为要举行 Leader election的话需要开一轮新的任期，这个时候前一轮任期已经结束了。我们这里假设了 T&lt; U，上述所说的已提交日志条目是在任期 T 中的，如果 voter先投票的话，那么就说明它已经进入了任期 U 了，而 U &gt; T，voter是不可能接受 leader<sub>T</sub> 的 AppendEntries 请求的。</p></blockquote></li><li><p>而且，voter 在给 leader<sub>U</sub>投票的时候，它依旧保有该日志条目，因为任何 U、T 之间的 leader都包含该日志条目（因为我们前面假设了 U 是大于 T的没有存储该日志条目的最小任期号），而且 leader 从来不会删除条目，并且follower 只有再跟 leader 冲突的时候才会删除条目。</p></li><li><p>该投票者把自己的选票投给 leader<sub>U</sub>的时候，leader<sub>U</sub> 的日志至少跟 voter一样新（可以更新），这就导致了以下的两个矛盾之一了。</p></li><li><p><strong>第一个矛盾：</strong></p><p><strong>如果 voter 和 leader<sub>U</sub>最后一个日志条目的任期号相同的话，那么 leader<sub>U</sub> 的日志至少和voter 的一样长，所以 leader<sub>U</sub> 的日志一定包含 voter日志中的所有日志条目。 这是一个矛盾，因为 voter包含了该已提交的日志条目，所以 leader<sub>U</sub>必定也包含该日志条目，而前面我们假设了 leader<sub>U</sub>是不包含的，这就产生了矛盾。</strong></p></li><li><p><strong>第二个矛盾：</strong></p><p><strong>如果不是上面描述的情况的话，那么 leader<sub>U</sub>最后一个日志条目的任期号必然需要比 voter 的更大。此外，它还比 T要大，因为 voter 拥有在任期号为 T 提交的日志条目，所以 voter最后一个日志条目的任期号至少为 T。创建了 leader<sub>U</sub>的最后一个日志条目的之前的 leader一定已经包含了该已被提交的日志条目（因为我们上面假设了leader<sub>U</sub> 是第一个没有该日志条目的leader）。所以，根据日志匹配特性，leader<sub>U</sub>一定也包含了该已被提交的日志条目，这样也产生了矛盾</strong>。</p></li><li><p>上述讨论就证明了假设是不成立的。因此，所有比 T 大的任期的 leader一定包含了任期 T 中提交的所有日志条目。</p></li><li><p>日志匹配特性保证了未来的 leader也会包含被间接提交的日志条目，如图 8 (d) 中的索引 2。</p></li></ol><p>通过 leader 的完整性特性，我们就可以证明图 3中的状态机安全特性了，即如果某个节点已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的节点就不会在相同的索引处应用一个不同的日志条目。在一个节点应用一个日志条目到自己的状态机中时，它的日志和leader的日志从开始到该日志条目都是相同的，并且该日志条目必须被提交。现在考虑一个最小的任期号，在该任期中任意节点应用了一个给定的最小索引上面的日志条目，那么Log 的完整性特性就会保证该任期之后的所有 leader将存储相同的日志条目，因此在后面的任期中应用该索引上的日志条目的节点会应用相同的值。所以，状态机安全特性是可以得到保证的。</p><p>最后，因为 Raft要求服务器节点按照日志索引顺序应用日志条目，再加上状态机安全特性，这样就意味着我们可以保证所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中了。</p><h3 id="follower-和-candidate-崩溃">5.5 follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。follower 和 candidate崩溃后的处理方式要比 leader崩溃简单得多，而且它们的处理方式是相同的。如果一个 follower 或者candidate 崩溃的话，后面发送给它们的 RequestVote 和 AppendEntries RPCs都会失败。Raft通过无限重试来处理这种失败。如果崩溃的节点重启了，那么这些 RPC就会被成功地完成。如果一个节点在完成了一个RPC，但是还没来得及响应就崩溃了的话，那么在它重启之后它会再次收到同样的请求。Raft的 RPCs 都是幂等的，所以重复发送相同的 RPCs不会对系统造成危害。实际情况下，一个 follower 如果接收了一个AppendEntries请求，但是这个请求里面的这些日志条目在它日志中已经有了，它就会直接忽略这个新的请求中的这些日志条目。</p><blockquote><p>译者注：<strong>幂等</strong></p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现。</p></blockquote><h3 id="时序和可用性">5.6 时序和可用性</h3><p>Raft 中有一个要求就是 Raft的安全性不能依赖于时序（timing）：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。然而，可用性（即系统能够及时响应客户端的请求）不可避免的要依赖于时序。比如说，如果信息交换的时间比一般服务器崩溃所持续的时间还要长的话，那么candidate 可能等不到赢得选举了，而缺少了一个稳定的 leader，Raft将无法工作。</p><p>Raft 中时序最关键的地方就是 Leaderelection。只要整个系统满足下面的时间要求，Raft就可以选举并维持一个稳定的 leader：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是一个节点并行地发送 RPCs给集群中其他所有的节点并得到响应的平均时间。选举超时时间就是在 5.2节中介绍的选举超时时间。平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须选举超时时间小一个量级，这样leader 才能够有效发送心跳信息来组织 follower进入选举状态。再加上随机化选举超时时间的方法，这个不等式也使得无果选票（splitvote）变得几乎不可能。而选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才可以稳定地运行。有了这个限制后，当leader崩溃后，整个系统会有一段大约选举超时时间的时长不可用，我们希望该情况在整个系统运行时间里只占一小部分。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们可以自定义的。Raft的 RPCs 需要接收方将信息持久化地保存到稳定存储中，所以广播时间大约是0.5ms ~ 20ms 之间，取决于存储的技术。因此，选举超时时间可能需要在 10ms ~500ms之间。而大多数的服务器的平均故障间隔时间都在几个月甚至更长，所以很容易满足时间的要求。</p><h2 id="集群成员变更">6. 集群成员变更</h2><p>到目前为止，我们都假设集群的配置（参与共识算法的服务器节点集合）是固定不变的。但是在实际情况中，我们有时候是需要去改变集群配置的，比如说在服务器崩溃的时候去更换服务器或者是更改副本的数量。尽管可以通过下线整个集群，更新所有配置，然后重启整个集群的方式来实现这个需求，但是这会导致集群在更改过程中是不可用的。另外，如果这个过程中存在一些操作需要人工干预，那么就会有操作失误的风险。为了避免这些问题，我们决定将配置变更自动化并将其纳入到Raft 的共识算法中来。</p><p>为了使配置变更机制足够安全，在配置变更过程中不能存在任何一个时刻使得同一任期中选出两个leader。遗憾的是，任何服务器直接从旧的配置转换为新的配置的方案都是不安全的。一次性自动地转换所有服务器的配置的不可能的，所以在转换期间整个集群可能划分为两个独立的大多数（如图10 所示）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgq3skl4gj322c0nwaes.jpg"alt="image-20210714195412552" /><figcaption aria-hidden="true">image-20210714195412552</figcaption></figure><blockquote><p>译者注：图 10 补充</p><p>上图中，在中间位置 Server1 可以通过自身和 Server2 的选票成为leader（满足旧配置下收到大多数选票的原则）；Server3 可以通过自身和Server4、Server5 的选票成为 leader（满足新配置线，即集群有 5个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个leader，这和 Raft 协议是违背的。</p></blockquote><p>为了保证安全性，配置变更必须采取一种两段式方法。目前有很多种两段式的实现。例如，有些系统（如[22]）在第一阶段停掉旧的配置，所以在这个阶段不能处理用户的请求，然后在第二阶段启用新的配置。在Raft 中，集群先切换到一个过渡的配置，我们称之为 <strong>联合共识（jointconsensus）</strong>。一旦联合共识配置已经被提交了，系统就可以切换到新的配置上了。<strong>联合共识配置是新旧配置的并集</strong>：</p><ul><li>日志条目被复制给集群中处于新、老配置的所有节点</li><li>新、旧配置的节点都可能成为 leader</li><li>达成一致（针对选举和提交）需要分别得到在两种配置上过半的支持</li></ul><p>联合共识允许每一个节点在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合共识还允许在集群配置变更期间响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信。图 11展示了配置变更的过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgpnv9f98j32060p6agz.jpg"alt="image-20210714193852320" /><figcaption aria-hidden="true">image-20210714193852320</figcaption></figure><p>当 leader接收到一个更新配置的请求的时候，它就创建一个联合共识日志条目C<sub>old,new</sub>，并以前面描述的方式复制该条目。<strong>一旦某个节点将该配置日志条目增加到自己的日志中。那么这个节点就会用该配置来做出未来的所有决策（一个节点总是使用日志中最新的配置，无论该日志是否已经被提交）。</strong>这就意味着 leader 会使用 C<sub>old,new</sub> 的规则来判断C<sub>old,new</sub> 日志条目是什么时候被提交的。如果 leader 崩溃了，新的leader 有可能处于 C<sub>old</sub> 配置，也可能处于 C<sub>old,new</sub>配置，这取决于赢得选举的 candidate 是否已经接收到了 C<sub>old,new</sub>配置。在任何情况下，处于 C<sub>new</sub>状态的节点在此期间都是不能单独做出决定的。</p><p>当 C<sub>old,new</sub> 被提交了，那么 C<sub>old</sub> 和C<sub>new</sub> 都不能在没有得到对方认可的情况下做出决定，并且 Leade完整特性（Leader Completeness Property）保证了只有拥有C<sub>old,new</sub> 日志的 candidate 有可能被选为 leader。所以现在leader 就可以安全地创建一个描述 C<sub>new</sub>的日志条目并将其复制给集群中的其他节点了。一样的，新的配置被节点收到后就会立刻生效。当新的配置在C<sub>new</sub>的规则下被提交了之后，旧配置就变得无关紧要了，处于旧配置的节点也可以关闭了。如图11 所示，没有任何一个时刻 C<sub>old</sub> 和 C<sub>new</sub>是可以单独做决定的，这保证了安全性。</p><p>关于配置变更有三个问题需要解决：</p><ul><li><p>第一个问题：新的节点可能在一开始并没有存储任何的日志条目。当这些节点以这种状态加入到集群中的时候，它们需要一段时间来更新自己的日志，以便赶上其他节点，在这个时间段里面它们是不可能提交一个新的日志条目的。<strong>为了避免因此造成的系统短时间的不可用，Raft在配置变更前引入了一个额外的阶段。在该阶段中，新的节点以没有投票权身份加入到集群中来（leader会把日志复制给它们，但是考虑过半的时候不需要考虑它们）。</strong>一旦新节点的日志已经赶上了集群中的其他节点，那么配置变更就可以按照之前描述的方式进行了。</p></li><li><p>第二个问题：leader 有可能不是新配置中的一员（译者注：也就是说这个leader 后面是需要被下线的）。在这种情况下，leader 一旦提交了C<sub>new</sub> 日志条目，它就会退位为follower（译者注：C<sub>old,new</sub>状态下依旧可用）。这就意味着有这样一段时间（leader 提交 C<sub>new</sub>期间）：leader管理着一个不包括自己的集群，它会复制日志给其他节点，但是算副本数量的时候不会算上自己。leader转换发生在 C<sub>new</sub>被提交的时候，因为这是新配置可以独立运行的最早时刻（在这个时刻之后，一定是从C<sub>new</sub> 中选出新的 leader）。在这个时间点之前，有可能只能从C<sub>old</sub> 中选出 leader。</p></li><li><p>第三个问题：那么被移除的节点（不处于 C<sub>new</sub>状态的节点）有可能会扰乱集群。这些节点将不会收到心跳信息，所以当选举超时时，它们就会进行新的选举过程。它们会发送带有新任期号的RequestVote RPCs，这样会导致当前的 leader 回到 follower状态，然后选出一个新的leader。但是这些被移除的节点还是会收不到心跳，然后再次超时，再次循环这个过程，导致系统的可用性很差。</p><p>为了避免这个问题，当节点认为当前有 leader 存在时，节点会忽略RequestVote RPCs。具体来说，当一个节点在最小选举超时时间内收到一个RequestVoteRPC，它不会更新它的任期或授予它的投票。这不会影响正常的选举，每个节点在开启一轮选举之前，它会至少等待一次最小选举超时时间。相反，这有利于避免被移除的节点的扰乱：如果一个leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p></li></ul><blockquote><p>译者注：<strong>对配置变更的归纳</strong></p><ol type="1"><li><p>配置变更过程</p><ol type="1"><li><p>leader 在本地生成一个新的日志条目，其内容是 C<sub>old</sub> ∪C<sub>new</sub>，代表当前时刻新旧成员配置共存，写入本地日志，称为C<sub>old,new</sub>。后面 leader就以该日志作为自己的配置了。同时将该日志条目复制集群中是所有节点中。在此之后新的日志同步需要保证得到C<sub>old</sub> 和 C<sub>new</sub> 两个多数派的确认。</p><p>follower 收到 C<sub>old.new</sub>的日志后更新本地日志，并且此时就以该配置作为自己的成员配置。</p><p>如果 C<sub>old</sub> 和 C<sub>new</sub> 中的两个多数派确认了C<sub>old.new</sub> 这个日志条目，leader 就提交它。</p></li><li><p>接下来 leader 生成一条新的日志条目，其内容是新成员配置C<sub>new</sub>，同样将该日志条目写入本地日志，同时复制给集群中其他节点。</p><p>follower 收到新成员配置 C<sub>new</sub>后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在C<sub>new</sub> 这个成员配置中会自动退出。</p><p>leader 收到 C<sub>new</sub>的多数派确认后，表示成员变更成功，后续的日志只要得到 C<sub>new</sub>多数派确认即可。</p></li></ol><p>完成上述两阶段后，leader就可以给客户端回复配置变更执行成功。</p></li><li><p>如果当前的 leader 不在 C<sub>new</sub> 的配置中会怎么样？</p><p>因为当前 leader 不在 C<sub>new</sub> 配置中，所以当 C<sub>new</sub>日志条目被提交的时候，leader 其实是要被下线的（比如说集群节点数从 5缩容为 3，且刚好下线的节点中包含当前 leader）。那这样的话，在C<sub>old,new</sub> 状态下，leader 还是可用的，但是一旦 C<sub>new</sub>日志条目被提交了，leader 就需要下线了，这个时候不用当心，因为C<sub>new</sub> 已经被复制过半了，重新选 leader 也一定是选有C<sub>new</sub> 的。</p></li><li><p>如果在配置分发过程中 leader 崩溃了怎么办？</p><p>分两种情况：</p><ol type="1"><li><p>C<sub>new</sub> 已经分发过半</p><p>集群开始重新选举，此时在 C<sub>new</sub>的规则下，不存在新配置中的节点不会赢得选举（因为他们要在C<sub>old,new</sub>的情况下决定，但是拿不到 C<sub>new</sub> 的选票），只有拿到C<sub>new</sub> 的节点可能成为 leader 并继续下发 C<sub>new</sub>配置，流程恢复。</p></li><li><p>C<sub>new</sub> 没有分发过半</p><p>这种情况下，C<sub>old,new</sub> 和 C<sub>new</sub> 的节点都可以成为leader，但是无所谓，因为无论谁成为leader，都能根据当前的配置继续完成后续流程（如果是 C<sub>new</sub>那么相当与完成了最终的配置，不在 C<sub>new</sub>的节点会因为没有心跳数据而失效）。</p></li></ol></li><li><p>旧配置节点下线造成的问题</p><p>Raft 的处理方式：当节点确信有 leader 存在时，不会进行投票（在 leader超时之前收到新的投票请求时不会提升任期号和做出投票）。且开始选举之前等待一个选举超时时间，这样在新leader 正常工作的情况下，不会受到旧节点的影响。</p><p>旧配置节点在发起选举前需要等待一段时间，那么这段时间新 leader可以发送心跳，这样就减少了影响。 对正常流程的影响不大。（leader失效后要等一段时间，没有及时触发，然而本身这里就有一个判断失效的时间，好像影响不大；比如原先超时时间是10s，那么如果设置成 5s，原策略下 10s 超时就是 10s 后开始选举，新策略下5s 超时就是超时后再等 5s 再开始选举，影响就是超时时间变短）</p></li><li><p>无数据的新节点加入集群中的问题</p><p>新加入的节点需要时间复制数据，在这个过程完成之前，Raft采用以下机制来保证可用性： 新加入节点没有投票权（ leader复制日志给他们，但计算已复制日志条目的副本数的时候不考虑它们），直到这些节点的日志追上其他节点。</p></li><li><p>如果在配置变更过程中接收到用户请求的话，是用旧配置响应还是用新配置响应？</p><p><strong>按照笔者的理解，这个方面，对 Raft协议的具体实现可以根据自身需求来自定义实现，Raft的联合共识是为了避免同一时刻出现了 2 个leader，避免了对客户端的一个请求同时有两个不同的响应出现。而在具体实现中，在某个阶段，究竟是采取新配置响应还是旧配置响应，可以再斟酌。</strong></p><p>比如说可以这样：</p><ol type="1"><li>C<sub>old</sub> 阶段：使用旧配置，需要过半旧配置节点确认</li><li>C<sub>new</sub> 已提交阶段：使用新配置，需要过半新配置节点确认</li><li>C<sub>old,new</sub>阶段：配置信息中有节点数量（这样才可能判断是否过半），这个时候新旧配置都需要过半节点确认，而响应新配置执行的结果还是响应旧配置执行的结果，就看old 多还是 new 多，谁多用谁。</li></ol></li><li><p>如果 leader 要下线，客户端发来的新的请求如何处理？</p><ol type="1"><li>如果是在 leader 复制 C<sub>new</sub> 之后，提交 C<sub>new</sub>之前的话，leader工作在新的集群配置下，所以会将日志复制到新集群的节点下，当收到新集群（不包含leader 本身）超过半数节点确认后，就可以提交日志。</li><li>在其他阶段，leader 就是正常可用的。</li></ol></li><li><p>所谓 C<sub>new</sub> 和 C<sub>old,new</sub>日志条目，里面没有数据，只有指令，里面的指令就是让节点执行对应的配置项。</p></li></ol></blockquote><h2 id="日志压缩">7. 日志压缩</h2><p>在正常情况下，Raft的日志会随着客户端请求的增加而不断增长。但在实际系统中，日志不可能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来重新执行日志中的日志条目。如果没有一定的机制来清除日志中积累的过期的信息，那么最终一定会影响系统的可用性。</p><p><strong>快照技术（snapshotting）</strong>是日志压缩最简单的方法。在快照技术中，某个时间点下的前整个系统的状态都会以快照的形式持久化起来，然后该时间点之前的日志会被全部丢弃。快照技术呗使用在Chubby 和 ZooKeeper 当中，接下来的章节会介绍 Raft 中的快照技术。</p><p><strong>增量压缩方法（Incremental approach tocompaction）</strong>，例如<strong>日志清洗（log cleaning）</strong>[36]和<strong>日志结构合并树（log-structured merge trees）</strong>[30,5]，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，选择一个积累了大量被删除或被覆盖的对象的数据区域，然后重写该区域内还活着的对象，之后释放该区域。和快照技术相比，这需要大量额外的机制，并且增加了更多的复杂性，快照技术通过操作整个数据集来简化问题。虽然日志清理需要对Raft 进行修改，但是状态机可以使用与快照技术相同的接口来实现LSM（日志结构合并） 树。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshvublij8j321s0lsadj.jpg"alt="image-20210715195808192" /><figcaption aria-hidden="true">image-20210715195808192</figcaption></figure><p>图 12 展示了 Raft快照技术的基本思想。每一个节点独立地生成快照，快照中只包含自己日志中已经被提交的条目，这个过程主要的工作是状态机将自己的状态写入快照中。Raft在快照中还保留了少量的元数据：</p><ul><li>last includedindex：指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目）</li><li>last included term：指的是该条目所处的任期号</li></ul><p>保留这些元数据是为了支持快照后第一个条目的 AppendEntries一致性检查，因为该条目需要一个之前的日志索引和任期号。为了支持集群成员变更（第6 节中讨论的），快照中还包含日志中到 last included index为止的最新的配置。一旦节点完成了快照的写入，它可能就会删除 last includedindex 及之前的所有日志条目，以及之前的快照。</p><p>尽管通常情况下，节点都是独立生成快照的，但是 leader不可避免偶尔需要发送快照给一些落后的 follower。这通常发生在 leader已经丢弃了需要发给 follower的下一条日志条目的时候。幸运的是，这种情况在正常操作中是不会出现的：一个与leader 保持同步的 follower 通常都会拥有该日志条目。不过如果一个 follower运行比较缓慢，或者是它刚加入集群，那么它就可能会没有该日志条目。这个时候leader 会通过网络将该快照发送给该 follower，以使得该 follower可以更新到最新的状态。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshxf2bjwej31gg0u0k01.jpg"alt="image-20210715205247442" /><figcaption aria-hidden="true">image-20210715205247442</figcaption></figure><p>这个时候 leader 使用了一种新的 RPC 来发送快照给那些太落后的followers，如图 13 所示，这种 RPC 叫做<strong>InstallSnapshot</strong>。当一个 follower 通过这种 RPC收到快照的时候，它必须决定如何处理当前已经存在的日志条目。通常情况下，这份快照会包含接受者日志者没有的信息。所以这种情况下follower会丢弃它的整个日志，它的日志会全部被快照取代，并且可能有与快照冲突的未提交的条目。相反，如果一个follower收到一个描述其日志前缀的快照（可能是由于重传或错误），则被快照覆盖的日志条目将被删除，但是快照之后的条目仍然有效，且必须要保留。</p><p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower可能在不知道 leader的情况下创建快照。但是我们认为这种违背是合乎情理的。leader的存在，是为了防止在达成共识的时候产生冲突，但是在创建快照的时候，共识已经达成了，因此没有决策会出现冲突。这种情况下，数据还是跟之前一样，只能从leader 流向 follower，只不过现在允许 follower可以重新组织它们的数组而已。</p><p>我们曾经考虑过一种可替代的方案，那就是只有 leader可以创建快照，然后由 leader 将这份快照发送给其他所有的follower。但是，这种方案有两个缺点：</p><ol type="1"><li>发送快照给每个 follower会浪费网络带宽和延缓了快照处理过程。实际上每一个 follower已经拥有了创建自己快照所需要的全部信息了，所以很显然，follower根据本地的状态创建快照要比通过网络来接收别人发过来的要更加实惠。</li><li>这会造成 leader 的实现更加复杂。比如说，leader 发送快照给 follower的同时要能够做到并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求，这就复杂得多了。</li></ol><p>还有两个问题会影响快照的性能：</p><ol type="1"><li><p>每一个节点必须判断何时去生成快照。如果一个节点生成快照的频率太高，那么就会浪费大量的磁盘带宽和其他资源；如果一个节点生成快照的频率太低，那么就要承担耗尽存储容量的风险，同时也增加了重启时重新执行日志的时间。</p><p>一个简单的策略就是当日志大小达到一个固定的阈值的时候就生成一份快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽开销将较小。</p></li><li><p>第二个影响性能的就是写快照需要花费一定的时间，而我们又不希望它会影响到正常的操作。</p><p>解决方案就是使用 <strong>写时复制的技术（copy-on-write）</strong>，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛型函数结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如Linux 上的fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p></li></ol><h2 id="客户端交互">8. 客户端交互</h2><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft是如何支持线性化语义的[10]。这些问题对于所有的基于共识算法的系统都是存在的，Raft的解决方案也跟其他的系统差不多。</p><p>Raft 的客户端们将所有的请求发送给leader。当客户端第一次启动的时候，它会随机挑选一个节点来进行通信。如果客户端首选的不是leader，那么被客户端选中的节点就会拒绝客户端的请求并且提供关于它最近收到的leader 的信息（AppendEntries RPC 包含了 leader 的网络地址）。如果 leader崩溃了，客户端请求就会超时，这个时候客户端需要随机选择一个节点来重试发送请求。</p><p>我们对 Raft的期许是希望它可以实现线性化语义（即每次操作看起来似乎都是在调用和响应之间的某个点上即时执行一次）。但是，按照上面描述的，Raft可能会对同一条指令执行多次。例如，如果 leader在提交了某个日志条目后，在还没来得及响应客户端的时候就崩溃了，那么客户端会和新的leader重试该指令，这就造成了同一指令被执行了两次。解决方案是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的响应。如果状态机接收到了一条已经执行过的指令了，就立即作出响应，并且不会重复执行该指令。</p><p>只读操作（Read-Only）可以直接处理而不记录日志。但是，如果不采取任何措施的话，这可能会有返回过期数据（staledata）的风险。<strong>因为 leader 响应客户端请求的时候它可能已经被新的leader 代替了，但是它还不知道自己已经不是最新的 leader 了。</strong></p><blockquote><p>译者补充：<strong>为什么一个 leader 好好的会有另外一个 leader出现？</strong></p><p>参考：https://segmentfault.com/a/1190000039264427</p><p>实际上，老的 leader 可能不会马上消失，例如：网络分区将 leader与集群的其余部分分隔，其余部分选举出了一个新的 leader。然后老的 leader崩溃后重新连接，可能会不知道新的 leader 已经被选出来了。</p></blockquote><p>线性化的操作肯定不会返回过期的数据。Raft需要使用两个额外的预防措施来在不适用日志的时候保证这一点。</p><ol type="1"><li><p>leader 必须拥有那些已提交的日志条目的最新信息。Leader完整性特性（Leader Completeness Property）保证了 leader一定拥有所有已被提交的日志条目，但是在它任期刚开始的时候，它可能还不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。</p><p><strong>Raft 通过让 leader在任期开始的时候提交一个空的日志条目到日志中来解决该问题</strong>。（译者注：这就是前面5.4.2 节提到的 no-op 日志）</p></li><li><p>leader在处理只读请求的时候必须检查自己是否已经被替代了（因为如果一个新 leader被选出来了，那么这个旧 leader 的数据可能就过时了）。</p><p>Raft 通过让 leader在响应只读请求之前，先和集群中过半的节点交换一次心跳信息来解决该问题。</p><p>另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式[9]，但是这种方式的安全性需要依赖于时序（假设时间误差是有界的）。</p></li></ol><h2 id="算法实现与评估">9. 算法实现与评估</h2><p>我们已经实现了 Raft 作为复制状态机的一部分，该状态机存储了 RAMCloud[33] 的配置信息，并帮助 RAMCloud 协调器进行故障转移。这个 Raft实现大概包含了 2000+ 行 C++代码，但是这里面没有包含测试、注释和空行。这些代码是开源的[23]。同时也有大约 25个其他独立的第三方、针对不同的开发场景、基于这篇论文草稿的开源实现。同时，很多公司已经部署了基于Raft 算法的系统了。</p><p>本节剩下的篇幅将从三个方面来评估 Raft 算法：</p><ul><li>可理解性</li><li>正确性</li><li>性能</li></ul><h3 id="可理解性">9.1 可理解性</h3><p>为了衡量 Raft 相对于 Paxos的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一项实验研究。我们为Raft 和 Paxos 分别录制了一个视频教程，并且准备了相应的小测验。其中 Raft课程覆盖了本篇论文除了日志压缩之外的全部内容，而 Paxos课程涵盖了创建一个与 Raft 等价的复制状态机的全部资料，包括 signle-decreePaxos、multi-decree Paxos、重新配置和一切实际系统需要的性能优化（比如leader选举）。这个小测验主要是测试一些对算法的理解和解释一些边缘情况。每个学生都是看完第一个视频，然后做对应的测验，然后再看第二个视频，再做第二份测验。为了解释个人表现与从第一部分研究中获得的经验差异的原因，大约有一半的学生先进行Paxos 的部分，然后另一半学生先进行 Raft的部分。我们通过计算参与人员的每一份测验的得分来看参与者是否更加容易理解Raft 算法。</p><p>我们尽可能的使得在比较 Raft 和 Paxos过程中是公平的。这个实验从两个方面偏向了 Paxos：</p><ol type="1"><li>43 个参与者中有 15 个人在之前有一些 Paxos 的经验</li><li>Paxos 视频教程的时长要长 14%</li></ol><p>如表格 1总结的那样，我们采取了一些措施来减轻这种潜在的偏向。我们所有的材料都可供审查[28, 31]。</p><table style="width:100%;"><thead><tr class="header"><th>关注点</th><th>缓和偏向采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr class="odd"><td>相同的讲课质量</td><td>两份教程采用同一个讲师。Paxos的教程是在现有的一些大学使用的材料基础上改进的。Paxos 的教程要长14%。</td><td>视频</td></tr><tr class="even"><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr class="odd"><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评分细则</td></tr></tbody></table><center>表格1：考虑到潜在的实验偏向，我们对于每种情况的解决方法，以及相应的材料。</center><p>平均上看，参与者在 Raft 测验上的得分要比在 Paxos 测验上的得分高处 4.9分（在 60 分中，Raft 的平均得分是 25.7 分，Paxos 的平均得分是 20.8分）。图 14 展示了每个参与者的得分。配对 t 检验（paired t-test）表明，在95% 的置信度下，Raft 分数的真实分布的平均值至少要比 Paxos 的大 2.5分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsixtffkroj32220my76y.jpg"alt="image-20210716175208106" /><figcaption aria-hidden="true">image-20210716175208106</figcaption></figure><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，这个模型基于以下三点：</p><ol type="1"><li>他们使用的是哪个测验</li><li>之前对于 Paxos 的经验</li><li>学习算法的顺序</li></ol><p>该模型预测，对小测验的选择会产生 12.5 分的有利于 Raft的差别，这很明显高于观察到的 4.9分的分差。这是因为实际上许多的学生之前有学习过 Paxos，这对 Paxos的有很大帮助的，但是对 Raft的帮助就较小了。但是奇怪的是，模型预测对于先进行 Paxos小测验的人而言，Raft 的得分低了 6.3分。虽然我们不知道这是为什么，但是这似乎在统计上是有意义的。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsiz66oe4yj323m0jgdj0.jpg"alt="image-20210716183850084" /><figcaption aria-hidden="true">image-20210716183850084</figcaption></figure><p>我们同时也在测验之后对参与者进行了调查，调查的内容是他们认为哪个算法更容易去实现或解释。这些调查结果展示在图15。调查结果是碾压性的，结果表明 Raft 算法更加容易实现和解释（41 人中的33个）。然而，这种自我报告的感觉可能没有参与者的测试分数来得可靠，而且参与者可能由于我们假设Raft 更容易理解而存在偏向。</p><p>在参考文献 [33] 中有一个关于 Raft 用户学习的更加详细的讨论。</p><h3 id="正确性">9.2 正确性</h3><p>在第 5节中，我们已经对共识机制制定了正式的规范并且对其安全性做了证明。这份正式的规范使用TLA+ 规范语言 [17] 使图 2 中对算法的总结的信息非常清晰。它差不多有 400行并且作为了我们要证明的核心。同时这份规范对于任何想实现 Raft的人都是十分有用的。我们用 TLA 证明系统 [7] 机械地证明了日志完整性（LogCompletenessProperty）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范中的类型安全）。而且，我们已经编写了状态机安全特性的非正式证明[31]，它是完整的（它仅依赖于规范）和相对精确的（大约 3500 字长）。</p><h3 id="性能">9.3 性能</h3><p>Raft 的性能跟其他像 Paxos的共识算法很接近。在性能方面，最重要的关注点就是，当一个 leader被选举出来后，它要在什么时候复制新的日志条目。Raft通过很少量的消息包（一轮从 leader到集群中过半节点的的消息传递）就解决了这个问题。同时，进一步提升 Raft的性能也是有可能的。比如说，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他共识算法已经提出过很多性能优化方案，其中很多都可以应用到Raft 上，但是我们暂时把这些工作放到未来的工作中。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 的 leader election算法的性能并且回答两个问题：</p><ol type="1"><li>leader 选举过程收敛是否足够快？</li><li>在 leader 崩溃之后，最小的系统崩溃时间是多久？</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsj0yuh34ej61km0u043r02.jpg"alt="image-20210716194110554" /><figcaption aria-hidden="true">image-20210716194110554</figcaption></figure><p>为了衡量 leader election 的性能，我们反复使一个拥有 5 个节点的集群的leader 宕机，并计算它检测崩溃和重新选一个新的 leader 所需的时间（见图16）。为了构建一个最坏的情景，我们使各个节点中的日志长度都是不同的，这样某些candidate 是无法成为 leader 的。而已，为了尽可能出现无结果的投票（splitvote）情况，我们的测试脚本在终止 leader 的进程之前从 leader那触发了一个同步的发送了一次心跳广播（类似于 leader在崩溃前复制一个日志条目给其他节点）。leader在其心跳间隔内均匀随机地崩溃，这个心跳间隔也是所有测试中最小选举超时时长的一半。因此，<strong>最小宕机时间大约就是最小选举超时时间的一半</strong>。</p><p>图 16中上面的图表明，只需要在选举超时时间上使用很小的随机化就可以大大避免出现没有结果的投票的情况。在没有随机化的情况下（译者注：见图16中上面的图右边的橙色虚线），由于出现了很多没有结果的投票的情况，leaderelection 往往都需要花费超过 10s 的时间。仅仅加入 5ms的随机化时间，就大大改善了选举过程，现在平均的宕机时间只有287ms。继续增大随机性可以大大改善最坏的情况：通过增加 50ms的随机化时间，最坏的完成情况（即完成 1000 次实验）只需要 513 ms。</p><p>图 16中下面的图表明，通过减少选举超时时间可以禁烧系统的宕机时间。在选举超时时间为12~24ms 的情况下，只需要平均 35ms 就可以选举出新的leader（最长的一次花费了152ms）。然而，进一步降低选举超时时间可能就会违反 Raft不等式的要求。</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>因为这会使得在其他节点开启一轮新的选举之前，当前的 leader要完成发送一次心跳广播变得很难。这会造成不必要的 leader更换，从而降低了系统的可用性。我们推荐使用一个更为保守的选举超时时间，比如150~300ms。这样的时间不大可能导致不必要的 leader更换，同时还能提供不错的可用性。</p><h2 id="相关工作">10. 相关工作</h2><p>现在已经有很多关于共识算法相关的产物了，其中很多都属于以下类别之一：</p><ul><li>Lamport 对于 Paxos 的最初的描述 [15]，以及尝试将 Paxos解释地更清晰的描述 [16, 20, 21 ]。</li><li>关于 Paxos的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础[26, 39, 13]。</li><li>实现共识算法的系统，例如 Chubby [2, 4]，ZooKeeper [11, 12] 和Spanner [6]。对于 Chubby 和 Spanner的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>对于 Paxos 的性能优化 [18, 19, 3, 25, 1, 27]。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos差不多的替代算法。原始的算法描述 [29]和分布式传输协议耦合在了一起，但是核心的共识算法在最近更新的版本 [22]里被分离了出来。VR 使用了一种基于 leader 的方法，和 Raft有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同就在于 Raft 的<strong>强领导性（strongleadership）</strong>。Raft 将 leader election作为共识协议中非常重要的一环，并且将尽可能多的功能集中到了 leader身上。这种方法使得算法更加简单和更容易理解。比如说，在 Paxos 中，leaderelection和基本的共识协议是正交的：它只是作为一种性能优化，而不是实现共识所必需的。然而，这带来了很多额外的机制：</p><ul><li>Paxos 中包含了一个两段式的基本共识协议</li><li>Paxos 中还包含了一个单独的 leader election 机制</li></ul><p>相比之下，Raft 将 leader election直接纳入了共识算法并且将其作为共识两阶段中的第一个阶段，这使得 Raft使用的机制要比 Paxos 少得多。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于 leader 的，因此他们也拥有一些Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制。因为 Raft尽可能的减少了非 leader 者的功能。例如，Raft 中日志条目都遵循着从 leader发送给 follower 这一个方向：AppendEntries RPCs 是向外发送的。在 VR中，日志条目的流动是双向的（leader人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像Raft。</p><p>跟我们上述提到的其他基于共识性的日志复制算法相比，Raft的消息类型更少。例如，我们计算了一下 VR 和 ZooKeeper用来实现基本功能和集群成员变更（不包括日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）所需要的消息类型。VR和 ZooKeeper 都分别定义了 10 种不同的消息类型。相比之下，Raft 只有 4种消息类型（两种 RPC Request 及其对应的两种 RPC Response）。Raft的消息的消息量比其他算法的要大一点，但总的来说，它们更加简单。另外，VR和 ZooKeeper 都在 leader改变的时候传输了整个日志，所以这些算法为了能在实践中使用，就不得不增加额外的消息类型了。</p><p>Raft 的强 leader模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义Paxos （EPaxos）在某些没有 leader 的情况下可以达到很高的性能[27]。平等主义 Paxos充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos在服务器之间的负载均衡做的很好，并且很容易在 WAN网络环境下获得很低的延迟。但是，他在 Paxos上增加了非常明显的复杂性。</p><p>一些集群成员变更的方法已经被提出或者在其他的工作中被实现，包括Lamport 的原始的讨论 [15]，VR [22] 和 SMART[24]。我们选择使用联合共识的方法是因为它利用了共识协议的其余部分，这样我们只需要很少的一些机制就可以实现成员变更。Lamport的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有 leader的情况下也可以达到共识性。和 VR 和 SMART 相比较，Raft的重新配置算法可以在不限制正常请求处理的情况下进行。相比之下，VR在配置变更期间需要停止所有正常的处理过程，而 SMART对未完成请求的数量实施了类似 α 方法的限制。另外，和 VR、SMART 相比，Raft的方法也只需要增加更少的额外机制来实现。</p><h2 id="结论">11. 结论</h2><p>算法的设计通常以正确性、效率和简洁性为主要目标。虽然这些都是有价值的目标，但我们相信可理解性同样重要。在开发人员将算法转化为实际实现之前，其他任何目标都不能实现，而实际实现将不可避免地偏离和扩展发布的形式。除非开发人员对算法有深刻的理解，并能对算法有直观的认识，否则他们很难在实现中保留算法理想的特性。</p><p>在本文中，我们讨论了分布式共识的问题，在这个问题上，一个被广泛接受但难以理解的算法：Paxos，多年来一直让学生和开发人员非常挣扎。我们开发了一种新的算法：Raft，我们已经证明它比Paxos 更容易理解。我们也相信 Raft会为系统建设提供更好的基础。将可理解性作为主要设计目标改变了我们处理Raft设计的方式。随着设计的进展，我们发现自己反复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了Raft 的可理解性，而且使我们更容易证实它的正确性。</p><h2 id="致谢">12. 致谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利CS 294-91 课程、斯坦福 CS 240课程的学生，没有他们的大力支持，这项研究是不可能完成的。Scott Klemmer帮我们设计了用户调查，Nelson Ray建议我们进行统计学的分析。在用户调查时使用的关于 Paxos的幻灯片很大一部分是从 Lorenzo Alvisi的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 EzraHoch，他们找到了 Raft中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，ArjunGopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，AleksandarKracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，DavidRamos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，DeianStefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，MateiZaharia 以及 24位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 EddieKohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA支持，在国家科学基金会的 0963859 号批准，并且获得了来自Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。DiegoOngaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考文献">参考文献</h2><p>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., ANDLI, P. Paxos replicated state machines as the basis of ahigh-performance data store. In <em>Proc. NSDI’11, USENIX Conference onNetworked Systems Design and Implementation</em> (2011), USENIX, pp.141–154.</p><p>[2] BURROWS, M. The Chubby lock service for loosely- coupleddistributed systems. In <em>Proc. OSDI’06, Sympo- sium on OperatingSystems Design and Implementation</em> (2006), USENIX, pp. 335–350.</p><p>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. MulticoordinatedPaxos. In <em>Proc. PODC’07, ACM Sym- posium on Principles ofDistributed Computing</em> (2007), ACM, pp. 316–317.</p><p>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live:an engineering perspective. In <em>Proc. PODC’07, ACM Symposium onPrinciples of Distributed Computing</em> (2007), ACM, pp. 398–407.</p><p>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A.,BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: adistributed storage system for structured data. In <em>Proc. OSDI’06,USENIX Symposium on Operating Systems Design and Implementation</em>(2006), USENIX, pp. 205–218.</p><p>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C.,FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P.,HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S.,MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y.,SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’sglobally-distributed database. In <em>Proc. OSDI’12, USENIX Conferenceon Operating Systems Design and Implemen- tation</em> (2012), USENIX,pp. 251–264.</p><p>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D.,AND VANZETTO, H. TLA+ proofs. In <em>Proc. FM’12, Symposium on FormalMethods</em> (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of<em>Lec- ture Notes in Computer Science</em>, Springer, pp. 147–154.</p><p>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google filesystem. In <em>Proc. SOSP’03, ACM Symposium on Operating SystemsPrinciples</em> (2003), ACM, pp. 29–43.</p><p>[9] GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanismfor distributed file cache consistency. In <em>Proceedings of the 12thACM Ssymposium on Operating Systems Principles</em> (1989), pp.202–210.</p><p>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctnesscondition for concurrent objects. <em>ACM Trans- actions on ProgrammingLanguages and Systems 12</em> (July 1990), 463–492.</p><p>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B . ZooKeeper:wait-free coordination for internet-scale systems. In <em>Proc ATC’10,USENIX Annual Technical Con- ference</em> (2010), USENIX, pp.145–158.</p><p>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab:High-performance broadcast for primary-backup sys- tems. In <em>Proc.DSN’11, IEEE/IFIP Int’l Conf. on Depend- able Systems &amp;Networks</em> (2011), IEEE Computer Society, pp. 245–256.</p><p>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep.CNDS-2008-2, Johns Hopkins University, 2008.</p><p>[14] L A M P O RT, L . Time, clocks, and the ordering of events in adistributed system. <em>Commununications of the ACM 21</em>, 7 (July1978), 558–565.</p><p>[15] L A M P O RT, L . The part-time parliament. <em>ACM Transac-tions on Computer Systems 16</em>, 2 (May 1998), 133–169.</p><p>[16] LAMPORT, L. Paxos made simple. <em>ACM SIGACT News 32</em>, 4(Dec. 2001), 18–25.</p><p>[17] L A M P O RT, L . <em>Specifying Systems, The TLA+ Language andTools for Hardware and Software Engineers</em>. Addison- Wesley,2002.</p><p>[18] LAMPORT, L. Generalized consensus and Paxos. Tech. Rep.MSR-TR-2005-33, Microsoft Research, 2005.</p><p>[19] L A M P O RT, L . Fast paxos. (2006), 79–103.</p><p>[20] LAMPSON, B. W. How to build a highly available system usingconsensus. In <em>Distributed Algorithms</em>, O. Baboaglu and K.Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</p><p>[21] LAMPSON, B. W. The ABCD’s of Paxos. In <em>Proc. PODC’01, ACMSymposium on Principles of Distributed Computing</em> (2001), ACM, pp.13–13.</p><p>[22] LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited.Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</p><p>[23] LogCabin source code. http://github.com/ logcabin/logcabin.</p><p>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J.R., AND HOWELL, J. The SMART way to migrate replicated statefulservices. In <em>Proc. Eu- roSys’06, ACM SIGOPS/EuroSys EuropeanConference on Computer Systems</em> (2006), ACM, pp. 103–115.</p><p>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: buildingefficient replicated state machines for WANs. In <em>Proc. OSDI’08,USENIX Conference on Operating Systems Design and Implementation</em>(2008), USENIX, pp. 369–384.</p><p>[26] MAZIE` RES, D. Paxos made practical.http://www.scs.stanford.edu/ ̃dm/home/ papers/paxos.pdf, Jan. 2007.</p><p>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is moreconsensus in egalitarian parliaments. In <em>Proc. SOSP’13, ACMSymposium on Operating System Principles</em> (2013), ACM.</p><p>[28] Raft user study. http://ramcloud.stanford. edu/̃ongaro/userstudy/.</p><p>[29] OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A newprimary copy method to support highly-available distributed systems. In<em>Proc. PODC’88, ACM Symposium on Principles of DistributedComputing</em> (1988), ACM, pp. 8–17.</p><p>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. Thelog-structured merge-tree (LSM-tree). <em>Acta Informat- ica 33</em>, 4(1996), 351–385.</p><p>[31] ONGARO, D. <em>Consensus: Bridging Theory and Practice</em>. PhDthesis, Stanford University, 2014 (work in progress).</p><p>[32] ONGARO, D., AND OUSTERHOUT, J. In search of an understandableconsensus algorithm. In <em>Proc ATC’14, USENIX Annual TechnicalConference</em> (2014), USENIX.</p><p>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C.,LEVERICH, J., MAZIE`RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D.,PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN,R. The case for RAMCloud. <em>Com- munications of the ACM 54</em> (July2011), 121–130.</p><p>[34] Raft consensus algorithm website.http://raftconsensus.github.io.</p><p>[35] REED, B. Personal communications, May 17, 2013.</p><p>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The design andimplementation of a log-structured file system. <em>ACM Trans. Comput.Syst. 10</em> (February 1992), 26–52.</p><p>[37] S C H N E I D E R , F. B . Implementing fault-tolerant servicesusing the state machine approach: a tutorial. <em>ACM Com- putingSurveys 22</em>, 4 (Dec. 1990), 299–319.</p><p>[38] SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoopdistributed file system. In <em>Proc. MSST’10, Symposium on Mass StorageSys- tems and Technologies</em> (2010), IEEE Computer Society, pp.1–10.</p><p>[39] VAN RENESSE, R. Paxos made moderately complex. Tech. rep.,Cornell University, 2012.</p>]]></content>
    
    
    <categories>
      
      <category>论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Raft</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
