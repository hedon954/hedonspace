<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go1.21.0 程序编译过程</title>
    <link href="/2023/11/29/go-compilation/"/>
    <url>/2023/11/29/go-compilation/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul><li>Go 1.21</li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>Go 语言官方文档详细阐述了 Go 语言编译器的具体执行过程，Go1.21 版本可以看这个：<a href="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile">https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile</a></p><p>大致过程如下：</p><ol><li><p><strong>解析</strong> (<code>cmd/compile/internal/syntax</code>):</p><ul><li><strong>词法分析器和语法分析器</strong>：源代码被分词（词法分析）并解析（语法分析）。</li><li><strong>语法树构建</strong>：为每个源文件构建一个语法树。</li></ul></li><li><p><strong>类型检查</strong> (<code>cmd/compile/internal/types2</code>):</p><ul><li><strong>类型检查</strong>：<code>types2</code> 包是 <code>go/types</code> 的一个移植版本，它使用 <code>syntax</code> 包的 AST（抽象语法树）而不是 <code>go/ast</code>。</li></ul></li><li><p><strong>IR 构建（”noding”）</strong>:</p><ul><li><strong>编译器类型</strong> (<code>cmd/compile/internal/types</code>)</li><li><strong>编译器 AST</strong> (<code>cmd/compile/internal/ir</code>)</li><li><strong>AST 转换</strong> (<code>cmd/compile/internal/typecheck</code>)</li><li><strong>创建编译器 AST</strong> (<code>cmd/compile/internal/noder</code>)</li><li>这个阶段使用自己的 AST 定义和 Go 类型的表示，这些定义和表示形式是用 C 编写时遗留下来的。它的所有代码都是根据这些编写的，因此类型检查后的下一步是转换语法和 <code>types2</code> 表示形式到 <code>ir</code> 和 <code>types</code>。这个过程被称为“noding”。</li></ul></li><li><p><strong>中间阶段</strong>:</p><ul><li><strong>死代码消除</strong> (<code>cmd/compile/internal/deadcode</code>)</li><li><strong>函数调用内联</strong> (<code>cmd/compile/internal/inline</code>)</li><li><strong>已知接口方法调用的去虚拟化</strong> (<code>cmd/compile/internal/devirtualize</code>)</li><li><strong>逃逸分析</strong> (<code>cmd/compile/internal/escape</code>)</li><li>在 IR 表示上执行几个优化过程：死代码消除、（早期的）去虚拟化、函数调用内联和逃逸分析。</li></ul></li><li><p><strong>Walk</strong> (<code>cmd/compile/internal/walk</code>):</p><ul><li><strong>求值顺序和语法糖</strong>：这是对 IR 表示的最后一次遍历，它有两个目的：将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；将高级 Go 构造转换为更原始的构造。</li></ul></li><li><p><strong>通用 SSA</strong> (<code>cmd/compile/internal/ssa</code> 和 <code>cmd/compile/internal/ssagen</code>):</p><ul><li>在这个阶段，IR 被转换为静态单赋值（SSA）形式，这是一种具有特定属性的低级中间表示，使得从中实现优化并最终生成机器代码变得更容易。</li></ul></li><li><p><strong>生成机器代码</strong> (<code>cmd/compile/internal/ssa</code> 和 <code>cmd/internal/obj</code>):</p><ul><li>这是编译器的机器依赖阶段，以“lower”过程开始，将通用值重写为它们的机器特定变体。然后进行最终的代码优化过程。最后，Go 函数被转换为一系列 <code>obj.Prog</code> 指令，这些指令被汇编器（<code>cmd/internal/obj</code>）转换为机器代码，并写出最终的目标文件。</li></ul></li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img5eRkfKJ8cMojTjPoZzjr1i-20231129143006857.png" alt="Go编译器概览"></p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>Go 程序的编译过程符合经典编译原理的过程拆解，即三阶段编译器，分别为编译器前端、中端和后端：</p><ul><li><strong>前端（Front End）：</strong> 前端的任务是进行语法分析和语义分析。这一阶段会将源代码转换为一个中间表示。在这个过程中，编译器会检查代码的语法和语义，比如语法错误、类型错误等。前端通常是依赖于具体语言的，比如 Go 的前端和 C++ 的前端就会有很大的不同。</li><li><strong>中间端（Middle End）：</strong> 中间端的任务是对中间表示进行优化。这一阶段的优化是语言无关的，比如常量折叠、死代码消除、循环优化等。这些优化可以提高生成的代码的性能，但是不会改变程序的语义。</li><li><strong>后端（Back End）：</strong> 后端的任务是将优化后的中间表示转换为目标机器代码。这一阶段会进行更多的优化，比如寄存器分配、指令选择、指令调度等。后端通常是依赖于具体机器的，比如 x86 的后端和 ARM 的后端就会有很大的不同。</li></ul><p>参考《Go 语言底层原理剖析（郑建勋）》一书，本文将 Go 语言编译器执行流程拆分为以下几个阶段：</p><ul><li>词法解析</li><li>语法解析</li><li>抽象语法树构建</li><li>类型检查</li><li>死代码消除</li><li>去虚拟化</li><li>函数内联</li><li>逃逸分析</li><li>变量捕获</li><li>闭包重写</li><li>遍历函数</li><li>SSA 生成</li><li>机器码生成</li></ul><p>下面本文将以此书为参考并结合 Go1.21.0 版本，对每个过程进行阐述。</p><blockquote><p>如果只想对 Go 程序的编译过程做一个简单的了解，那阅读到这里就已经足够了。</p></blockquote><h2 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h2><p>词法解析过程主要负责将源代码中的字符序列转换成一系列的标记（tokens），这些标记是编译器更进一步处理的基本单位。在 Go 语言的编译器中，<code>tokens.go</code> 文件包含了与词法分析有关的标记定义。</p><p>词法解析的过程可以分为几个关键步骤：</p><ol><li><strong>扫描（Scanning）</strong>：编译器的扫描器会逐字符读取源代码，识别出基本的语法单位，如标识符、关键字、字面量、运算符等。</li><li><strong>标记生成（Token Generation）</strong>：每当扫描器识别出一个有效的语法单位时，它会生成一个相应的标记。例如，对于一个变量名，扫描器会生成一个标识符标记。</li><li><strong>去除空白字符和注释</strong>：在生成标记的过程中，扫描器还会忽略空白字符（如空格、换行符）和注释，因为它们对程序的逻辑没有影响。</li><li><strong>错误处理</strong>：如果扫描器在源代码中遇到无法识别的字符或序列，它会生成一个错误消息。</li></ol><p>我们来看以下 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/tokens.go">tokens.go</a> 文件中的 <code>token</code> 定义，它们实质上是用 <code>iota</code> 声明的一系列整数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_    token = <span class="hljs-literal">iota</span><br>_EOF       <span class="hljs-comment">// EOF</span><br><br><span class="hljs-comment">// names and literals</span><br>_Name    <span class="hljs-comment">// name</span><br>_Literal <span class="hljs-comment">// literal</span><br><br><span class="hljs-comment">// operators and operations</span><br><span class="hljs-comment">// _Operator is excluding &#x27;*&#x27; (_Star)</span><br>_IncOp    <span class="hljs-comment">// opop</span><br>    _Define   <span class="hljs-comment">// :=</span><br>    ...<br><br><span class="hljs-comment">// delimiters</span><br>_Lparen    <span class="hljs-comment">// (</span><br>_Rparen    <span class="hljs-comment">// )</span><br>...<br><br><span class="hljs-comment">// keywords</span><br>_Break       <span class="hljs-comment">// break</span><br>...<br><br><span class="hljs-comment">// empty line comment to exclude it from .String</span><br>tokenCount <span class="hljs-comment">//</span><br>)<br></code></pre></td></tr></table></figure><p>举个例子，<code>a := b + c(12)</code> 这个表达式，被解析后，如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202200135678.png" alt="Go 语言编译器词法解析示例图"></p><h2 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h2><p>语法解析发生在词法解析之后，其主要目的是分析源代码中标记（tokens）的排列和结构，以确定它们是否形成了有效的语句。核心算法位于两个文件中：</p><ul><li><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/nodes.go">syntax&#x2F;nodes.go</a>：定义了语法节点（Syntax Nodes），这些节点是构成抽象语法树（AST）的基本元素。每个节点代表了 Go 语法中的一个构造，比如变量声明、函数调用、表达式等。通过这些节点，编译器能够理解和表示程序代码的结构。</li><li><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax&#x2F;parser.go</a>：包含了解析器的实现。解析器负责读取词法分析阶段生成的标记流，并根据这些标记构建 AST。它遵循 Go 语言的语法规则，确保代码符合语法结构，并在遇到语法错误时提供相应的反馈。</li></ul><p>Go 语言采用了标准的自上而下的递归下降（Top-Down Recursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描。</p><p>下面我们来看下 <code>nodes.go</code> 文件中对各个节点的声明（以下都省略了 struct 中的具体属性）：</p><h3 id="声明-Declarations"><a href="#声明-Declarations" class="headerlink" title="声明 Declarations"></a>声明 Declarations</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Decl <span class="hljs-keyword">interface</span> &#123;<br>Node<br>aDecl()<br>&#125;<br>ImportDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 导入声明</span><br>ConstDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 常量声明</span><br>TypeDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 类型声明</span><br>VarDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 变量声明</span><br>FuncDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 函数声明</span><br>)<br></code></pre></td></tr></table></figure><h3 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式 Expressions"></a>表达式 Expressions</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Expr <span class="hljs-keyword">interface</span> &#123;<br>Node<br>typeInfo<br>aExpr()<br>&#125;<br><span class="hljs-comment">// 省略了结构体属性</span><br>BadExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 无效表达式</span><br>Name <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>BasicLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>CompositeLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Type &#123; ElemList[0], ElemList[1], ... &#125;</span><br>    KeyValueExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Key: Value</span><br>FuncLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// func Type &#123; Body &#125;</span><br>ParenExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// (X)</span><br>SelectorExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.Sel</span><br>IndexExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index]</span><br>SliceExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index[0] : Index[1] : Index[2]]</span><br>AssertExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.(Type)</span><br>TypeSwitchGuard <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Lhs := X.(type)</span><br>Operation <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 操作 +-*\</span><br>CallExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Fun(ArgList[0], ArgList[1], ...)</span><br>ListExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ElemList[0], ElemList[1], ...</span><br>ArrayType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// [Len]Elem</span><br>SliceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// []Elem</span><br>DotsType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ...Elem</span><br>StructType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// struct &#123; FieldList[0] TagList[0]; FieldList[1] TagList[1]; ... &#125;</span><br>Field <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Name Type</span><br>InterfaceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// interface &#123; MethodList[0]; MethodList[1]; ... &#125;</span><br>    FuncType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// type FuncName func (param1, param2) return1, return2</span><br>MapType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// map[Key]Value</span><br>ChanType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// chan Elem, &lt;-chan Elem, chan&lt;- Elem</span><br>)<br></code></pre></td></tr></table></figure><h3 id="语句-Statements"><a href="#语句-Statements" class="headerlink" title="语句 Statements"></a>语句 Statements</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>    <span class="hljs-comment">// 所有语句的通用接口</span><br>    Stmt <span class="hljs-keyword">interface</span> &#123;<br>       Node<br>       aStmt()<br>    &#125;<br><span class="hljs-comment">// 更加简单语句的通用接口</span><br>    SimpleStmt <span class="hljs-keyword">interface</span> &#123;&#125;<br><br>    EmptyStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 空语句</span><br>    LabeledStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 标签语句</span><br>    BlockStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 代码块语句</span><br>    ExprStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 表达式语句</span><br>    SendStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 发送语句，用于 channel</span><br>    DeclStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 声明语句</span><br>    AssignStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 赋值语句</span><br>    BranchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 分支语句，break, continue</span><br>    CallStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 调用语句</span><br>    ReturnStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 返回语句</span><br>    IfStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// if 条件语句</span><br>    ForStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// for 循环语句</span><br>    SwitchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// switch 语句</span><br>    SelectStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// select 语句</span><br>)<br></code></pre></td></tr></table></figure><p>我们可以重点来看一下最常用的赋值语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AssignStmt <span class="hljs-keyword">struct</span> &#123;<br>    Op       Operator <span class="hljs-comment">// 操作符 0 means no operation</span><br>    Lhs, Rhs Expr     <span class="hljs-comment">// 左右两个表达式 Rhs == nil means Lhs++ (Op == Add) or Lhs-- (Op == Sub)</span><br>    simpleStmt<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-keyword">type</span> String <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s String = <span class="hljs-string">&quot;hello &quot;</span> + word<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源代码会被解析成如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202195439495.png" alt="Go 编译器语法解析示例图"></p><p>再来看一个赋值语句是如何解析的，就以之前的 <code>a := b + c(12)</code> 为例：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003155036.png" alt="特定赋值语句的语法解析示例"></p><h2 id="抽象语法树构建"><a href="#抽象语法树构建" class="headerlink" title="抽象语法树构建"></a>抽象语法树构建</h2><p>编译器前端必须构建程序的中间表示形式，以便在编译器中端及后端使用，抽象语法树（Abstract Syntax Tree，AST）是一种常见的树状结构的中间态。</p><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>抽象语法树（AST，Abstract Syntax Tree）是源代码的树状结构表示，它用于表示编程语言的语法结构，但不包括所有语法细节。AST 是编译器设计中的关键概念，广泛应用于编译器的各个阶段。</p><p>基本概念：</p><ul><li>结构：AST 是一种树形结构，其中每个节点代表程序中的一种构造（如表达式、语句等）。</li><li>抽象性：它抽象出了代码的语法结构，省略了某些语法细节（如括号、特定的语法格式等）。</li></ul><p>节点类型：</p><ul><li>根节点：代表整个程序或一段完整代码。</li><li>内部节点：通常代表控制结构（如循环、条件语句）和操作符（如加、减、乘、除）。</li><li>叶节点：代表程序中的基本元素，如常量、变量和标识符。</li></ul><p>构建过程：</p><ul><li>词法分析：源代码首先经过词法分析，分解为一系列标记（tokens）。</li><li>语法分析：然后，基于这些标记，语法分析器根据编程语言的语法规则构建 AST。</li><li>树的构建：在这个过程中，分析器会根据语言的语法创建不同类型的节点，并按照程序的结构将它们组织成树。</li></ul><p>使用场景：</p><ul><li>语义分析：编译器使用 AST 来进行类型检查和其他语义分析。</li><li>代码优化：在优化阶段，编译器会对 AST 进行变换，以提高代码的执行效率。</li><li>代码生成：编译器根据 AST 生成中间代码或目标代码。</li></ul><p>优点：</p><ul><li>简化处理：由于省略了不必要的语法细节，AST 使得编译器的设计更为简洁和高效。</li><li>灵活性：AST 可以轻松地进行修改和扩展，便于实现各种编译器功能。</li><li>可视化：AST 的树形结构使得代码的逻辑结构一目了然，有助于理解和调试。</li></ul><h3 id="Go-构建抽象语法树"><a href="#Go-构建抽象语法树" class="headerlink" title="Go 构建抽象语法树"></a>Go 构建抽象语法树</h3><p>在 Go 语言源文件中的任何一种 Declarations 都是一个根节点，如下 <code>pkgInit(decls)</code> 函数将源文件中的所有声明语句都转换为节点（Node），代码位于：<a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/syntax.go">syntax&#x2F;syntax.go</a> 和 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax&#x2F;parser.go</a> 中。</p><h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse()"></a>Parse()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode)</span></span> (_ *File, first <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err, ok := p.(Error); ok &#123;<br>first = err<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-built_in">panic</span>(p)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> p parser<br>p.init(base, src, errh, pragh, mode)<br>p.next()<br><span class="hljs-keyword">return</span> p.fileOrNil(), p.first<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是对 <code>Parse()</code> 函数的一个简单解释：</p><ul><li>作用：解析单个 Go 源文件并返回相应的语法树。</li><li>参数<ul><li><code>base</code>: 位置基础信息。</li><li><code>src</code>: 要解析的源文件。</li><li><code>errh</code>: 错误处理函数。</li><li><code>pragh</code>: 用于处理每个遇到的编译指令（pragma）。</li><li><code>mode</code>: 解析模式。</li></ul></li><li>返回值：返回一个 <code>File</code>  类型的指针，表示解析后的 AST，以及可能的错误。</li><li>错误处理<ul><li>如果  <code>errh</code> 不为空：将会调用它处理每个遇到的错误，解析器尽可能多地处理源文件。此时，只有在没有找到正确的包声明时，返回的语法树才为 <code>nil</code>。</li><li>如果 <code>errh</code> 为空：解析器在遇到第一个错误时立即终止，返回的语法树为 <code>nil</code>。</li></ul></li></ul><p>其中 <code>File</code> 类型结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>Pragma    Pragma <span class="hljs-comment">// 编译指令</span><br>PkgName   *Name  <span class="hljs-comment">// 包名</span><br>DeclList  []Decl <span class="hljs-comment">// 源文件中的各种声明</span><br>EOF       Pos <span class="hljs-comment">// 解析位置</span><br>GoVersion <span class="hljs-type">string</span> <span class="hljs-comment">// go 版本</span><br>node<span class="hljs-comment">// 该源文件的 AST 根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parser-fileOrNil"><a href="#parser-fileOrNil" class="headerlink" title="parser.fileOrNil()"></a>parser.fileOrNil()</h4><p>具体的解析过程在 <code>parser.fileOrNil()</code> 方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *parser)</span></span> fileOrNil() *File &#123;<br><span class="hljs-keyword">if</span> trace &#123;<br><span class="hljs-keyword">defer</span> p.trace(<span class="hljs-string">&quot;file&quot;</span>)()<br>&#125;<br><br>    <span class="hljs-comment">// 1. 初始化文件节点</span><br>f := <span class="hljs-built_in">new</span>(File)<br>f.pos = p.pos()<br><br><span class="hljs-comment">// 2. 解析包声明</span><br>f.GoVersion = p.goVersion<br>p.top = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> !p.got(_Package) &#123;<span class="hljs-comment">// 包声明必须放在第一位，这跟我们学 Go 语法对应上了</span><br>p.syntaxError(<span class="hljs-string">&quot;package statement must be first&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>f.Pragma = p.takePragma() <span class="hljs-comment">// 获取编译指令</span><br>f.PkgName = p.name()<span class="hljs-comment">// 获取包名</span><br>    p.want(_Semi) <span class="hljs-comment">// _Semi 在之前的 tokens.go 中可以发现是分号（;)，是的，包声明后面就是得带分号</span><br><br><span class="hljs-comment">// 3. 处理包声明错误</span><br><span class="hljs-keyword">if</span> p.first != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 4. 循环解析顶层声明</span><br>    <span class="hljs-comment">// 循环处理文件中的所有声明，包括 import、const、type、var 和 func</span><br>    <span class="hljs-comment">// 对每种类型的声明，调用其解析函数，如 importDecl、constDecl 进行解析</span><br>prev := _Import<br><span class="hljs-keyword">for</span> p.tok != _EOF &#123;<br><span class="hljs-keyword">if</span> p.tok == _Import &amp;&amp; prev != _Import &#123;<br>p.syntaxError(<span class="hljs-string">&quot;imports must appear before other declarations&quot;</span>)<br>&#125;<br>prev = p.tok<br><br><span class="hljs-keyword">switch</span> p.tok &#123;<br><span class="hljs-keyword">case</span> _Import:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.importDecl)<br><br><span class="hljs-keyword">case</span> _Const:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.constDecl)<br><br><span class="hljs-keyword">case</span> _Type:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)<br><br><span class="hljs-keyword">case</span> _Var:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.varDecl)<br><br><span class="hljs-keyword">case</span> _Func:<br>p.next()<br><span class="hljs-keyword">if</span> d := p.funcDeclOrNil(); d != <span class="hljs-literal">nil</span> &#123;<br>f.DeclList = <span class="hljs-built_in">append</span>(f.DeclList, d)<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>             <span class="hljs-comment">// 5. 处理异常和错误</span><br><span class="hljs-keyword">if</span> p.tok == _Lbrace &amp;&amp; <span class="hljs-built_in">len</span>(f.DeclList) &gt; <span class="hljs-number">0</span> &amp;&amp; isEmptyFuncDecl(f.DeclList[<span class="hljs-built_in">len</span>(f.DeclList)<span class="hljs-number">-1</span>]) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;unexpected semicolon or newline before &#123;&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.syntaxError(<span class="hljs-string">&quot;non-declaration statement outside function body&quot;</span>)<br>&#125;<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Reset p.pragma BEFORE advancing to the next token (consuming &#x27;;&#x27;)</span><br><span class="hljs-comment">// since comments before may set pragmas for the next function decl.</span><br>p.clearPragma()<br><br><span class="hljs-keyword">if</span> p.tok != _EOF &amp;&amp; !p.got(_Semi) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;after top level declaration&quot;</span>)<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 6. 完成解析，记录文件结束的位置</span><br>p.clearPragma()<br>f.EOF = p.pos()<br><br><span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>parser.fileOrNil()</code> 方法的处理过程大致如下：</p><ol><li><strong>初始化文件节点</strong>：<ul><li><code>f := new(File)</code>: 创建一个新的 <code>File</code> 节点。</li><li><code>f.pos = p.pos()</code>: 设置节点的位置信息。</li></ul></li><li><strong>解析包声明（Package Clause）</strong>：<ul><li><code>f.GoVersion = p.goVersion</code>: 记录 Go 版本。</li><li><code>p.top = false</code>: 设置状态，表示不再处于文件顶层。</li><li><code>if !p.got(_Package) &#123;...&#125;</code>: 检查是否存在包声明，如果没有，则报错并返回 <code>nil</code>。</li><li><code>f.Pragma = p.takePragma()</code>: 获取与包声明相关的编译指令。</li><li><code>f.PkgName = p.name()</code>: 获取包名。</li><li><code>p.want(_Semi)</code>: 确认包声明后有分号。</li></ul></li><li><strong>处理包声明错误</strong>：<ul><li><code>if p.first != nil &#123;...&#125;</code>: 如果已有错误，停止解析并返回 <code>nil</code>。</li></ul></li><li><strong>解析顶层声明</strong>：<ul><li>通过一个循环处理文件中的所有声明，包括导入（import）、常量（const）、类型（type）、变量（var）和函数（func）。</li><li>对每种类型的声明，调用相应的解析函数（如 <code>p.importDecl</code>、<code>p.constDecl</code> 等）。</li><li>将解析得到的声明添加到 <code>f.DeclList</code> 中。</li></ul></li><li><strong>处理异常和错误</strong>：<ul><li>在解析过程中遇到的任何不符合语法的情况都会触发错误处理。</li><li>使用 <code>p.syntaxError</code> 报告语法错误。</li><li>使用 <code>p.advance</code> 在遇到错误时跳过一些标记，以尝试恢复到一个已知的稳定状态。</li></ul></li><li><strong>完成解析</strong>：<ul><li>当遇到文件结束标记（EOF）时，完成解析。</li><li><code>f.EOF = p.pos()</code>: 记录文件结束的位置。</li><li>返回构建的 <code>File</code> 节点。</li></ul></li></ol><h3 id="Op-字段"><a href="#Op-字段" class="headerlink" title="Op 字段"></a>Op 字段</h3><p>AST 每个节点都包含了当前节点属性的 Op 字段，定义在 <code>ir/node.go</code> 中，以 O 开头。与词法解析阶段中的 token 相同的是，Op 字段也是一个整数。不同的是，每个 Op 字段都包含了语义信息。例如，当一个节点的 Op 操作为 OAS 时，该节点代表的语义为 Left :&#x3D; Right，而当节点的操作为 OAS2 时，代码的语义为 x,y,z &#x3D; a,b,c。</p><p>这里仅展示部分 Op 字段的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Op <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// Node ops.</span><br><span class="hljs-keyword">const</span> (<br>OXXX Op = <span class="hljs-literal">iota</span><br><br><span class="hljs-comment">// names</span><br>ONAME <span class="hljs-comment">// var or func name</span><br><span class="hljs-comment">// Unnamed arg or return value: f(int, string) (int, error) &#123; etc &#125;</span><br><span class="hljs-comment">// Also used for a qualified package identifier that hasn&#x27;t been resolved yet.</span><br>ONONAME<br>OTYPE    <span class="hljs-comment">// type name</span><br>OLITERAL <span class="hljs-comment">// literal</span><br>ONIL     <span class="hljs-comment">// nil</span><br><br><span class="hljs-comment">// expressions</span><br>OADD          <span class="hljs-comment">// X + Y</span><br>...<br><span class="hljs-comment">// X = Y or (if Def=true) X := Y</span><br><span class="hljs-comment">// If Def, then Init includes a DCL node for X.</span><br>OAS<br><span class="hljs-comment">// Lhs = Rhs (x, y, z = a, b, c) or (if Def=true) Lhs := Rhs</span><br><span class="hljs-comment">// If Def, then Init includes DCL nodes for Lhs</span><br>OAS2<br>...<br>    <br>    <span class="hljs-comment">// statements</span><br>    OLABEL    <span class="hljs-comment">// Label:</span><br>    ...<br>OEND<br>)<br></code></pre></td></tr></table></figure><p>以前面举例的赋值语句 <code>a := b + c(12)</code> 为例，该赋值语句最终会编程如下图所示的抽象语法树，节点之间具有从上到下的层次结构和依赖关系。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003058976.png" alt="抽象语法树示例图"></p><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>完成 AST 的初步构建后，就进入类型检查阶段遍历节点树并决定节点的类型。具体的代码在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/types2/check.go">types2&#x2F;check,go</a>。</p><h3 id="checker-CheckFiles"><a href="#checker-CheckFiles" class="headerlink" title="checker.CheckFiles()"></a>checker.CheckFiles()</h3><p>其中最核心的方法就是 <code>checker.CheckFiles()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> checkFiles(files []*syntax.File) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 1. 不检查 unsafe 包</span><br><span class="hljs-keyword">if</span> check.pkg == Unsafe &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 2. 检查 go 版本</span><br>check.version, err = parseGoVersion(check.conf.GoVersion)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> check.version.after(version&#123;<span class="hljs-number">1</span>, goversion.Version&#125;) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;package requires newer Go version %v&quot;</span>, check.version)<br>&#125;<br><span class="hljs-keyword">if</span> check.conf.FakeImportC &amp;&amp; check.conf.go115UsesCgo &#123;<br><span class="hljs-keyword">return</span> errBadCgo<br>&#125;<br><br>    <span class="hljs-comment">// 3. 错误处理</span><br><span class="hljs-keyword">defer</span> check.handleBailout(&amp;err)<br><br>    <span class="hljs-comment">// 4. 详细检查每个地方</span><br><span class="hljs-built_in">print</span> := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> check.conf.Trace &#123;<br>fmt.Println()<br>fmt.Println(msg)<br>&#125;<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initFiles ==&quot;</span>)<br>check.initFiles(files)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== collectObjects ==&quot;</span>)<br>check.collectObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== packageObjects ==&quot;</span>)<br>check.packageObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== processDelayed ==&quot;</span>)<br>check.processDelayed(<span class="hljs-number">0</span>) <span class="hljs-comment">// incl. all functions</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== cleanup ==&quot;</span>)<br>check.cleanup()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initOrder ==&quot;</span>)<br>check.initOrder()<br><span class="hljs-keyword">if</span> !check.conf.DisableUnusedImportCheck &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== unusedImports ==&quot;</span>)<br>check.unusedImports()<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== recordUntyped ==&quot;</span>)<br>check.recordUntyped()<br><span class="hljs-keyword">if</span> check.firstErr == <span class="hljs-literal">nil</span> &#123;<br>check.monomorph()<br>&#125;<br>check.pkg.goVersion = check.conf.GoVersion<br>check.pkg.complete = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 5. 更新和清理</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.pkgPathMap = <span class="hljs-literal">nil</span><br>check.seenPkgMap = <span class="hljs-literal">nil</span><br>check.recvTParamMap = <span class="hljs-literal">nil</span><br>check.brokenAliases = <span class="hljs-literal">nil</span><br>check.unionTypeSets = <span class="hljs-literal">nil</span><br>check.ctxt = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.checkFiles()</code> 的过程大致如下：</p><ol><li><strong>检查特殊包</strong>：如果是 <code>Unsafe</code> 包，则直接返回，因为它不能进行类型检查且不应被修改。</li><li><strong>解析Go版本</strong>：根据配置解析 Go 版本，并进行兼容性检查。</li><li><strong>错误处理</strong>：设置一个延迟函数来处理任何可能出现的错误。</li><li><strong>类型检查的步骤</strong>：<ul><li><code>initFiles</code>: 初始化文件。</li><li><code>collectObjects</code>: 收集对象。</li><li><code>packageObjects</code>: 打包对象。</li><li><code>processDelayed</code>: 处理延迟的任务（包括所有函数）。</li><li><code>cleanup</code>: 清理。</li><li><code>initOrder</code>: 初始化顺序。</li><li><code>unusedImports</code>: 检查未使用的导入。</li><li><code>recordUntyped</code>: 记录未定类型。</li><li><code>monomorph</code>: 如果没有错误，进行单态化处理。</li></ul></li><li><strong>更新和清理</strong>：<ul><li>更新包的 Go 版本和完成状态。</li><li>清理不再需要的内部数据结构，释放内存。</li></ul></li><li><strong>返回</strong>：函数完成类型检查并返回。</li></ol><p>可以看出具体的检查步骤都封装在第 4 点的各个函数中，其实检查的东西我们学习 Go 语言时所需要掌握的那些语法，我们以 <code>initFiles</code> 为例子来分析一下，对于其他检查函数，你有兴趣的话也可以了解一下，这里推荐将函数源代码拷贝发给 <strong>ChatGPT-4</strong>，相信对你会有很大的帮助。</p><h3 id="checker-initFiles"><a href="#checker-initFiles" class="headerlink" title="checker.initFiles()"></a>checker.initFiles()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initFiles 初始化与文件相关的类型检查器</span><br><span class="hljs-comment">// 参数中的 files 必须都属于同一个 package</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> initFiles(files []*syntax.File) &#123;<br><span class="hljs-comment">// 1. 初始化</span><br>check.files = <span class="hljs-literal">nil</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.firstErr = <span class="hljs-literal">nil</span><br>check.methods = <span class="hljs-literal">nil</span><br>check.untyped = <span class="hljs-literal">nil</span><br>check.delayed = <span class="hljs-literal">nil</span><br>check.objPath = <span class="hljs-literal">nil</span><br>check.cleaners = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 2. 确定包名和有效文件</span><br>pkg := check.pkg<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br><span class="hljs-keyword">switch</span> name := file.PkgName.Value; pkg.name &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:<br><span class="hljs-keyword">if</span> name != <span class="hljs-string">&quot;_&quot;</span> &#123;<br>pkg.name = name<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>check.<span class="hljs-type">error</span>(file.PkgName, BlankPkgName, <span class="hljs-string">&quot;invalid package name _&quot;</span>)<br>&#125;<br><span class="hljs-keyword">fallthrough</span><br><br><span class="hljs-keyword">case</span> name:<br>check.files = <span class="hljs-built_in">append</span>(check.files, file)<br><br><span class="hljs-keyword">default</span>:<br>check.errorf(file, MismatchedPkgName, <span class="hljs-string">&quot;package %s; expected %s&quot;</span>, name, pkg.name)<br><span class="hljs-comment">// ignore this file</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 3. 对每个文件，解析其中指定的 Go 版本</span><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> check.files &#123;<br>v, _ := parseGoVersion(file.GoVersion)<br><span class="hljs-keyword">if</span> v.major &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> v.equal(check.version) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Go 1.21 introduced the feature of setting the go.mod</span><br><span class="hljs-comment">// go line to an early version of Go and allowing //go:build lines</span><br><span class="hljs-comment">// to “upgrade” the Go version in a given file.</span><br><span class="hljs-comment">// We can do that backwards compatibly.</span><br><span class="hljs-comment">// Go 1.21 also introduced the feature of allowing //go:build lines</span><br><span class="hljs-comment">// to “downgrade” the Go version in a given file.</span><br><span class="hljs-comment">// That can&#x27;t be done compatibly in general, since before the</span><br><span class="hljs-comment">// build lines were ignored and code got the module&#x27;s Go version.</span><br><span class="hljs-comment">// To work around this, downgrades are only allowed when the</span><br><span class="hljs-comment">// module&#x27;s Go version is Go 1.21 or later.</span><br><span class="hljs-comment">// If there is no check.version, then we don&#x27;t really know what Go version to apply.</span><br><span class="hljs-comment">// Legacy tools may do this, and they historically have accepted everything.</span><br><span class="hljs-comment">// Preserve that behavior by ignoring //go:build constraints entirely in that case.</span><br><span class="hljs-keyword">if</span> (v.before(check.version) &amp;&amp; check.version.before(version&#123;<span class="hljs-number">1</span>, <span class="hljs-number">21</span>&#125;)) || check.version.equal(version&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> check.posVers == <span class="hljs-literal">nil</span> &#123;<br>check.posVers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*syntax.PosBase]version)<br>&#125;<br>check.posVers[base(file.Pos())] = v<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.initFiles()</code> 方法的大致流程如下：</p><ol><li><strong>初始化状态</strong>：清空 <code>Checker</code> 结构体中与文件相关的多个字段，如 <code>files</code>, <code>imports</code>, <code>dotImportMap</code> 等，为新的检查过程做准备。</li><li><strong>确定包名和有效文件</strong>：<ul><li>遍历提供的文件，确定包名，并收集有效的文件。</li><li>如果文件的包名与 <code>Checker</code> 中的包名不匹配，则报错并忽略该文件。</li></ul></li><li><strong>处理Go版本</strong>：<ul><li>对每个文件，解析其中指定的 Go 版本。</li><li>处理 Go 版本的兼容性和升级逻辑，尤其是在 Go 1.21 引入的一些特性，如 <code>//go:build</code> 行的处理。</li></ul></li></ol><p>可以看到 Go 语言开发团队在这里写了一大段关于 Go1.21 的注释，这段注释描述了 Go 1.21 版本引入的关于 Go 版本设置的两个新特性,这里简单解释一下：</p><ol><li><strong>升级 Go 版本的特性</strong>：在 Go 1.21 版本中，可以在 <code>go.mod</code> 文件里设置一个较旧的Go版本，同时允许在源文件中通过 <code>//go:build</code> 行来指定一个更高的 Go 版本。这样做可以向后兼容，即允许旧版本代码在新版本的 Go 环境中运行。</li><li><strong>降级 Go 版本的限制</strong>：Go 1.21 也允许通过 <code>//go:build</code> 行来降低源文件中的 Go 版本。但这通常不是向后兼容的，因为在以前，<code>//go:build</code> 行被忽略，代码总是使用模块定义的 Go 版本。为了避免兼容性问题，仅当模块的 Go 版本为 1.21 或更高时，才允许这种降级。</li></ol><p><strong>未指定版本的情况</strong>：如果没有明确指定 <code>check.version</code>，编译器就不确定应该使用哪个 Go 版本。为了保持与旧工具的兼容，如果没有明确的版本约束，编译器将忽略 <code>//go:build</code> 行的限制。</p><h2 id="死代码消除"><a href="#死代码消除" class="headerlink" title="死代码消除"></a>死代码消除</h2><p>类型检查阶段完成后，编译器前端工作基本完成，后面就进入中端了。这个阶段 Go 语言编译器将对 AST 进行分析和重构，从而完成一系列优化。</p><p>第一部分是死代码消除（dead code elimination），过程识别并移除不会在运行时执行的代码。这包括未使用的变量、函数、常量等。通过删除这些无用代码片段，可以减小最终程序的大小并提高运行效率。</p><p>这部分的代码在：<a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/deadcode/deadcode.go">deadcode&#x2F;deadcode.go</a>。打开代码文件，可以看到核心就是 <code>Func()</code> 和 <code>stmt()</code> 这 2 个函数。</p><h3 id="Func"><a href="#Func" class="headerlink" title="Func()"></a>Func()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Func</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 对函数体进行预处理</span><br>stmts(&amp;fn.Body)<br><br>    <span class="hljs-comment">// 2. 空函数体直接返回</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 3. 遍历函数体，对其中每个节点进行处理</span><br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> fn.Body &#123;<br>        <span class="hljs-comment">// 节点有任何初始化操作，则不可消除，提前返回。</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>            <span class="hljs-comment">// 如果 if 语句判断条件不是常量，或者 if else 中的 body 不为空，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || <span class="hljs-built_in">len</span>(n.Body) &gt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(n.Else) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>            <span class="hljs-comment">// 如果 for 循环条件不是常量或一直为真，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || ir.BoolVal(n.Cond) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 4. 标记隐藏闭包为死代码</span><br>ir.VisitList(fn.Body, markHiddenClosureDead)<br>    <span class="hljs-comment">// 5. 重置函数体，替换为一个空语句，进行清理和优化</span><br>fn.Body = []ir.Node&#123;ir.NewBlockStmt(base.Pos, <span class="hljs-literal">nil</span>)&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><strong>语句处理（<code>stmts(&amp;fn.Body)</code>）</strong>：对函数体中的语句进行预处理或转换，以便于后续的分析和优化。</li><li><strong>空函数体直接返回</strong>：如果函数体为空，没有任何代码需要执行，因此函数直接返回。这是一种优化，避免对空函数体进行不必要的分析。</li><li><strong>遍历函数体</strong>:<ul><li><strong>节点初始化检查</strong>：如果任何节点有初始化操作，意味着可能存在副作用或必要的代码执行，因此函数提前返回。</li><li><code>If</code> 和 <code>For</code> 语句特殊处理<ul><li><code>ir.OIF</code>：如果 <code>If</code> 语句的条件不是常量布尔值，或者 <code>If</code> 语句有非空的 body 或 else 分支，则提前返回，因为这些分支可能包含重要的代码。</li><li><code>ir.OFOR</code>：对于 <code>For</code> 循环，如果条件不是常量布尔值或者布尔值为真，意味着循环可能执行，因此提前返回。</li></ul></li></ul></li><li><strong>标记隐藏闭包为死代码（<code>markHiddenClosureDead</code>）</strong>：如果所有节点都不触发提前返回，意味着整个函数体可能没有有效的代码执行。此时，将隐藏的闭包标记为死代码，可能是为了进一步的优化处理，如移除这些代码。</li><li><strong>重置函数体</strong>：最后，将函数体替换为一个空的新块语句，这表明原始的函数体被认为是无效的或不会被执行，从而进行了代码的清理和优化。</li></ol><h3 id="stmt"><a href="#stmt" class="headerlink" title="stmt()"></a>stmt()</h3><p>这个函数的目的是通过分析和简化控制流结构，来识别和移除那些在程序执行中永远不会到达的代码部分。这样的优化可以减少编译后的代码量，并提高程序运行时的效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stmts</span><span class="hljs-params">(nn *ir.Nodes)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 标记最后一个标签，其对应的 Op 字段就是 OLABEL</span><br><span class="hljs-keyword">var</span> lastLabel = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &amp;&amp; n.Op() == ir.OLABEL &#123;<br>lastLabel = i<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 处理 if 和 switch 语句</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br>cut := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> n.Op() == ir.OIF &#123;<br>n := n.(*ir.IfStmt)<br>n.Cond = expr(n.Cond)<br>             <span class="hljs-comment">// if 语句根据条件是否为常量来保留和移除分支</span><br><span class="hljs-keyword">if</span> ir.IsConst(n.Cond, constant.Bool) &#123;<br><span class="hljs-keyword">var</span> body ir.Nodes<br><span class="hljs-keyword">if</span> ir.BoolVal(n.Cond) &#123;<br>ir.VisitList(n.Else, markHiddenClosureDead)<br>n.Else = ir.Nodes&#123;&#125;<br>body = n.Body<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ir.VisitList(n.Body, markHiddenClosureDead)<br>n.Body = ir.Nodes&#123;&#125;<br>body = n.Else<br>&#125;<br>                 <span class="hljs-comment">// 如果 then 或 else 分支以 panic 或 return 语句结束，那么可以安全地移除该节点之后的所有语句。</span><br>                 <span class="hljs-comment">// 这是因为 panic 或 return 会导致函数终止，后续的代码永远不会被执行。</span><br>                 <span class="hljs-comment">// 同时，注释提到要避免移除标签（labels），因为它们可能是 goto 语句的目标，</span><br>                 <span class="hljs-comment">// 而且为了避免 goto 相关的复杂性，没有使用 isterminating 标记。</span><br>                 <span class="hljs-comment">// might be the target of a goto. See issue 28616.</span><br><span class="hljs-keyword">if</span> body := body; <span class="hljs-built_in">len</span>(body) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">switch</span> body[(<span class="hljs-built_in">len</span>(body) - <span class="hljs-number">1</span>)].Op() &#123;<br><span class="hljs-keyword">case</span> ir.ORETURN, ir.OTAILCALL, ir.OPANIC:<br><span class="hljs-keyword">if</span> i &gt; lastLabel &#123;<br>cut = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 尝试简化 switch 语句，根据条件值决定哪个分支始终被执行</span><br><span class="hljs-keyword">if</span> n.Op() == ir.OSWITCH &#123;<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &amp;&amp; n.Tag.Op() == ir.OTYPESW &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// no special type-switch case yet.</span><br>&#125;<br><span class="hljs-keyword">var</span> x constant.Value <span class="hljs-comment">// value we&#x27;re switching on</span><br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(n.Tag) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>x = n.Tag.Val()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>x = constant.MakeBool(<span class="hljs-literal">true</span>) <span class="hljs-comment">// switch &#123; ... &#125;  =&gt;  switch true &#123; ... &#125;</span><br>&#125;<br><span class="hljs-keyword">var</span> def *ir.CaseClause<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cas.List) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// default case</span><br>def = cas<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cas.List &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(c) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// can&#x27;t statically tell if it matches or not - give up.</span><br>&#125;<br><span class="hljs-keyword">if</span> constant.Compare(x, token.EQL, c.Val()) &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> cas.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// This switch entry is the one that always triggers.</span><br><span class="hljs-keyword">for</span> _, cas2 := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">for</span> _, c2 := <span class="hljs-keyword">range</span> cas2.List &#123;<br>ir.Visit(c2, markHiddenClosureDead)<br>&#125;<br><span class="hljs-keyword">if</span> cas2 != cas &#123;<br>ir.VisitList(cas2.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Rewrite to switch &#123; case true: ... &#125;</span><br>n.Tag = <span class="hljs-literal">nil</span><br>cas.List[<span class="hljs-number">0</span>] = ir.NewBool(c.Pos(), <span class="hljs-literal">true</span>)<br>cas.List = cas.List[:<span class="hljs-number">1</span>]<br>n.Cases[<span class="hljs-number">0</span>] = cas<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> def != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> def.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> cas != def &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br>n.Cases[<span class="hljs-number">0</span>] = def<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle case bodies ending with panic/return as we do in the IF case above.</span><br><br><span class="hljs-comment">// entire switch is a nop - no case ever triggers</span><br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>n.Cases = n.Cases[:<span class="hljs-number">0</span>]<br>&#125;()<br>&#125;<br><br>        <span class="hljs-comment">// 3. 对节点的初始化语句递归调用 stmt 函数进行处理</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) != <span class="hljs-number">0</span> &#123;<br>stmts(n.(ir.InitNode).PtrInit())<br>&#125;<br>        <span class="hljs-comment">// 4. 遍历其他控制结构，递归处理它们的内部语句</span><br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OBLOCK:<br>n := n.(*ir.BlockStmt)<br>stmts(&amp;n.List)<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>stmts(&amp;n.Body)<br>stmts(&amp;n.Else)<br><span class="hljs-keyword">case</span> ir.ORANGE:<br>n := n.(*ir.RangeStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OSELECT:<br>n := n.(*ir.SelectStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br><span class="hljs-keyword">case</span> ir.OSWITCH:<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 5. 如果确定了是可以消除的代码，则对函数体进行阶段，且标记其中的闭包为死代码</span><br><span class="hljs-keyword">if</span> cut &#123;<br>ir.VisitList((*nn)[i+<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(*nn)], markHiddenClosureDead)<br>*nn = (*nn)[:i+<span class="hljs-number">1</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>标记最后一个标签</strong>：遍历所有节点，记录最后一个标签（<code>OLABEL</code>）的位置。这对于后面判断是否可以安全地移除代码非常重要。</li><li><strong>处理 <code>if</code> 和 <code>switch</code> 语句</strong>：<ul><li>对于 <code>if</code> 语句，它根据条件是否为常量来决定保留哪个分支，移除另一个分支。</li><li>对于 <code>switch</code> 语句，它尝试简化 <code>switch</code>，根据条件值决定哪个分支将始终被执行。</li></ul></li><li><strong>节点初始化</strong>：如果节点有初始化语句，对这些初始化语句递归调用 <code>stmts</code> 函数。</li><li><strong>遍历其他控制结构</strong>：对于 <code>for</code>、<code>if</code>、<code>range</code>、<code>select</code> 和 <code>switch</code> 等控制结构，递归地处理它们的内部语句。</li><li><strong>消除死代码</strong>：如果判断一个节点之后的所有代码都是无效的，它会标记这些代码为死代码并截断函数体。</li></ol><h2 id="去虚拟化"><a href="#去虚拟化" class="headerlink" title="去虚拟化"></a>去虚拟化</h2><p>去虚拟化（Devirtualization）是编译器优化的一种技术，用于提高面向对象程序的性能。在面向对象编程中，方法调用通常是通过虚拟函数表（vtable）动态解析的，这被称为虚拟调用。虚拟调用允许对象在运行时表现出多态行为，但这也带来了一定的性能开销。</p><p>去虚拟化的目的是在编译时静态确定方法调用的目标，从而避免运行时的动态查找。如果编译器能够确定一个特定的接口调用总是调用同一个方法，它可以将这个虚拟调用替换为直接调用，减少运行时开销。这种优化特别适用于那些调用目标不会因为程序执行的不同路径而改变的情况。</p><p>这部分的代码在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/devirtualize/devirtualize.go">devirtuailze&#x2F;devirtualize.go</a>。</p><p>核心就 2 个函数：</p><ul><li><code>Static()</code> ：遍历函数中的所有节点，尤其注意跳过在 <code>go</code> 或 <code>defer</code> 语句中的调用，并对其他接口方法调用尝试进行静态去虚拟化优化。</li><li><code>staticCall()</code> ：针对一个具体的接口方法调用，如果可能，将其替换为直接的具体类型方法调用，以优化性能。</li></ul><h3 id="Static"><a href="#Static" class="headerlink" title="Static()"></a>Static()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Static</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>ir.CurFunc = fn<br>goDeferCall := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ir.CallExpr]<span class="hljs-type">bool</span>)<br>    <span class="hljs-comment">// 1. VisitList 对 fn.Body 中所有节点调用后面的 func</span><br>ir.VisitList(fn.Body, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n ir.Node)</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := n.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-comment">// 2. 跳过 go 和 defer 语句</span><br><span class="hljs-keyword">case</span> *ir.GoDeferStmt:<br><span class="hljs-keyword">if</span> call, ok := n.Call.(*ir.CallExpr); ok &#123;<br>goDeferCall[call] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 3. 调用 staticCall 尝试进行去虚拟化</span><br><span class="hljs-keyword">case</span> *ir.CallExpr:<br><span class="hljs-keyword">if</span> !goDeferCall[n] &#123;<br>staticCall(n)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>设定当前函数为 <code>fn</code>。</li><li>遍历函数体内的节点，特别注意 <code>go</code> 和 <code>defer</code> 语句。如果调用发生在这些语句中，它会被跳过，因为去虚拟化可能改变程序的语义。</li><li>对于不在 <code>go</code> 或 <code>defer</code> 语句中的接口方法调用，调用 <code>staticCall</code> 函数尝试进行去虚拟化。</li></ol><h3 id="staticCall"><a href="#staticCall" class="headerlink" title="staticCall()"></a>staticCall()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">staticCall</span><span class="hljs-params">(call *ir.CallExpr)</span></span> &#123;<br>    <span class="hljs-comment">// 1. 检查调用是否为接口方法调用，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> call.Op() != ir.OCALLINTER &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 获取接收器和相关类型</span><br>sel := call.X.(*ir.SelectorExpr)<br>r := ir.StaticValue(sel.X)<br>    <br>     <span class="hljs-comment">// 3. 检查接收器是否是接口转换，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> r.Op() != ir.OCONVIFACE &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>recv := r.(*ir.ConvExpr)<br><br>   <span class="hljs-comment">// 4. 提取接收器类型</span><br>typ := recv.X.Type()<br><span class="hljs-keyword">if</span> typ.IsInterface() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 5. shape 类型直接返回，因为这一般涉及到泛型，需要通过字典进行间接调用</span><br><span class="hljs-keyword">if</span> typ.IsShape() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> typ.HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped receiver %v&quot;</span>, call, typ)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> sel.X.Type().HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped interface %v&quot;</span>, call, sel.X.Type())<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 6. 类型断言和方法选择，尝试确定调用的具体方法</span><br>dt := ir.NewTypeAssertExpr(sel.Pos(), sel.X, <span class="hljs-literal">nil</span>)<br>dt.SetType(typ)<br>x := typecheck.Callee(ir.NewSelectorExpr(sel.Pos(), ir.OXDOT, dt, sel.Sel))<br><span class="hljs-keyword">switch</span> x.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODOTMETH:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLMETH)<br>call.X = x<br><span class="hljs-keyword">case</span> ir.ODOTINTER:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;partially devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLINTER)<br>call.X = x<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;failed to devirtualize %v (%v)&quot;</span>, x, x.Op())<br>&#125;<br><span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment">// 7. 根据类型断言的结果，尝试将接口方法调用转换为直接方法调用或保留为接口方法调用。</span><br>types.CheckSize(x.Type())<br><span class="hljs-keyword">switch</span> ft := x.Type(); ft.NumResults() &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>call.SetType(ft.Results().Field(<span class="hljs-number">0</span>).Type)<br><span class="hljs-keyword">default</span>:<br>call.SetType(ft.Results())<br>&#125;<br><br><span class="hljs-comment">// 8. 对可能修改后的方法调用进行进一步的类型检查和调整。</span><br>typecheck.FixMethodCall(call)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>检查是否为接口方法调用</strong>：函数首先判断传入的调用是否是接口方法调用（<code>ir.OCALLINTER</code>），这是去虚拟化的前提条件。</li><li><strong>处理形状类型</strong>：代码中提到，如果接收器的类型是形状类型（用于泛型），则无法去虚拟化，因为这需要通过字典进行间接调用。</li><li><strong>处理形状类型的接收器</strong>：如果接收器的类型具有形状类型，则当前无法进行去虚拟化。注释中还提到了一些待实现（TODO）的优化点，例如处理非泛型的提升方法。</li><li><strong>处理形状类型的接口</strong>：如果调用的接口本身是一个形状类型，由于指针身份的不同，类型断言可能会失败，因此在这种情况下也无法去虚拟化。</li><li><strong>转换方法调用</strong>：根据调用的具体情况，将接口方法调用转换为直接的方法调用（<code>OCALLMETH</code>）或保留为接口方法调用（<code>OCALLINTER</code>）。</li><li><strong>更新调用类型</strong>：为了正确处理函数返回值，需要更新调用的类型，确保参数大小和栈偏移量正确。</li><li><strong>反糖化方法调用</strong>：如果创建了直接方法调用，需要对其进行后续的类型检查和调整。</li></ol><h2 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h2><p>函数内联是将一个函数的代码直接插入到每个调用点，而不是进行常规的函数调用。这意味着函数的整个体被复制到每个调用该函数的地方。</p><p>优点：</p><ul><li><strong>减少开销</strong>：内联消除了函数调用的开销，如参数传递、栈操作等。</li><li><strong>提升性能</strong>：有助于其他优化，比如循环展开、常量传播，因为编译器可以看到函数体内的代码。</li></ul><p>选择哪些函数内联：</p><ul><li><strong>小函数</strong>：通常是小函数，因为它们的内联带来的性能提升相对于代码膨胀的代价来说是值得的。</li><li><strong>调用频率高的函数</strong>：这些函数如果内联，可以显著减少运行时的调用开销。</li></ul><p>在 Go 语言中，可以通过 <code>//go:noinline</code> 来禁止函数内联。</p><p>这部分的主要实现在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal~/inl.go">inline.inl.go</a>，核心函数是：<code>CanInline()</code> 和 <code>InlineImpossible()</code>。</p><h3 id="CanInline"><a href="#CanInline" class="headerlink" title="CanInline()"></a>CanInline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Inlining budget parameters, gathered in one place</span><br><span class="hljs-keyword">const</span> (<br>    <span class="hljs-comment">// budget 是内联复杂度的衡量，</span><br>    <span class="hljs-comment">// 超过 80 表示编译器认为这个函数太复杂了，就不进行函数内联了</span><br>inlineMaxBudget       = <span class="hljs-number">80</span><br>)<br><br><span class="hljs-comment">// CanInline 用于判断 fn 是否可内联。</span><br><span class="hljs-comment">// 如果可以，会将 fn.Body 和 fn.Dcl 拷贝一份放到 fn.Inl，</span><br><span class="hljs-comment">// 其中 fn 和 fn.Body 需要确保已经经过类型检查了。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CanInline</span><span class="hljs-params">(fn *ir.Func, profile *pgo.Profile)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 函数名必须有效</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline no nname %+v&quot;</span>, fn)<br>&#125;<br><br>    <span class="hljs-comment">// 如果不能内联，输出原因</span><br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> || logopt.Enabled() &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: cannot inline %v: %s\n&quot;</span>, ir.Line(fn), fn.Nname, reason)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;cannotInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), reason)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br>    <span class="hljs-comment">// 检查是否符合不可能内联的情况，如果返回的 reason 不为空，则表示有不可以内联的原因</span><br>reason = InlineImpossible(fn)<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> fn.Typecheck() == <span class="hljs-number">0</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline on non-typechecked function %v&quot;</span>, fn)<br>&#125;<br><br>n := fn.Nname<br><span class="hljs-keyword">if</span> n.Func.InlinabilityChecked() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> n.Func.SetInlinabilityChecked(<span class="hljs-literal">true</span>)<br><br>cc := <span class="hljs-type">int32</span>(inlineExtraCallCost)<br><span class="hljs-keyword">if</span> base.Flag.LowerL == <span class="hljs-number">4</span> &#123;<br>cc = <span class="hljs-number">1</span> <span class="hljs-comment">// this appears to yield better performance than 0.</span><br>&#125;<br><br><span class="hljs-comment">// 设置内联预算，后面如果检查函数的复杂度超过预算了，就不内联了</span><br>budget := <span class="hljs-type">int32</span>(inlineMaxBudget)<br><span class="hljs-keyword">if</span> profile != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> n, ok := profile.WeightedCG.IRNodes[ir.LinkFuncName(fn)]; ok &#123;<br><span class="hljs-keyword">if</span> _, ok := candHotCalleeMap[n]; ok &#123;<br>budget = <span class="hljs-type">int32</span>(inlineHotMaxBudget)<br><span class="hljs-keyword">if</span> base.Debug.PGODebug &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;hot-node enabled increased budget=%v for func=%v\n&quot;</span>, budget, ir.PkgFuncName(fn))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 遍历函数体，计算复杂度，判断是否超过内联预算</span><br>visitor := hairyVisitor&#123;<br>curFunc:       fn,<br>budget:        budget,<br>maxBudget:     budget,<br>extraCallCost: cc,<br>profile:       profile,<br>&#125;<br><span class="hljs-keyword">if</span> visitor.tooHairy(fn) &#123;<br>reason = visitor.reason<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 前面检查都没问题，则标记为可以内联，并复制其函数体和声明到内联结构体中</span><br>n.Func.Inl = &amp;ir.Inline&#123;<br>Cost: budget - visitor.budget,<br>Dcl:  pruneUnusedAutos(n.Defn.(*ir.Func).Dcl, &amp;visitor),<br>Body: inlcopylist(fn.Body),<br><br>CanDelayResults: canDelayResults(fn),<br>&#125;<br><br>    <span class="hljs-comment">// 日志和调试</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v with cost %d as: %v &#123; %v &#125;\n&quot;</span>, ir.Line(fn), n, budget-visitor.budget, fn.Type(), ir.Nodes(n.Func.Inl.Body))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v\n&quot;</span>, ir.Line(fn), n)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;canInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), fmt.Sprintf(<span class="hljs-string">&quot;cost: %d&quot;</span>, budget-visitor.budget))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>基本检查</strong>：验证函数是否已经进行了类型检查，以及函数名是否有效。</li><li><strong>判断是否可以内联</strong>：调用 <code>InlineImpossible</code> 函数来检查是否有任何基本的限制条件阻止内联（例如函数太大、递归等）。</li><li><strong>内联预算设置</strong>：根据函数的特征和可能的性能剖析信息来设定内联预算。这个预算是内联决策的关键参数之一。</li><li><strong>详细分析</strong>：<code>hairyVisitor</code> 结构用于遍历函数体，判断是否超出了内联预算。这涉及对函数体的复杂度和大小的评估。</li><li><strong>内联决策</strong>：如果函数通过了所有检查并且未超出预算，则标记为可以内联，并复制其函数体和声明（Dcl）到内联结构体中。</li><li><strong>日志和调试</strong>：根据编译器的日志级别，输出关于内联决策的详细信息，例如为什么一个函数不能被内联或者它的内联成本是多少。</li></ol><h3 id="InlineImpossible"><a href="#InlineImpossible" class="headerlink" title="InlineImpossible()"></a>InlineImpossible()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InlineImpossible</span><span class="hljs-params">(fn *ir.Func)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span> <span class="hljs-comment">// reason, if any, that the function can not be inlined.</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>reason = <span class="hljs-string">&quot;no name&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:noinline&quot;, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Noinline != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:noinline&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:norace&quot; and -race compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Flag.Race &amp;&amp; fn.Pragma&amp;ir.Norace != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:norace with -race compilation&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:nocheckptr&quot; and -d checkptr compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Debug.Checkptr != <span class="hljs-number">0</span> &amp;&amp; fn.Pragma&amp;ir.NoCheckPtr != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:nocheckptr&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:cgo_unsafe_args&quot;, don&#x27;t inline, since the function</span><br><span class="hljs-comment">// makes assumptions about its argument frame layout.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.CgoUnsafeArgs != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:cgo_unsafe_args&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrkeepalive&quot;, don&#x27;t inline, since the keep</span><br><span class="hljs-comment">// alive information is lost during inlining.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// TODO(prattmic): This is handled on calls during escape analysis,</span><br><span class="hljs-comment">// which is after inlining. Move prior to inlining so the keep-alive is</span><br><span class="hljs-comment">// maintained after inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrKeepAlive != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having a keep-alive uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrescapes&quot;, don&#x27;t inline, since the escape</span><br><span class="hljs-comment">// information is lost during inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrEscapes != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having an escaping uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// The nowritebarrierrec checker currently works at function</span><br><span class="hljs-comment">// granularity, so inlining yeswritebarrierrec functions can confuse it</span><br><span class="hljs-comment">// (#22342). As a workaround, disallow inlining them for now.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Yeswritebarrierrec != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:yeswritebarrierrec&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If a local function has no fn.Body (is defined outside of Go), cannot inline it.</span><br><span class="hljs-comment">// Imported functions don&#x27;t have fn.Body but might have inline body in fn.Inl.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &amp;&amp; !typecheck.HaveInlineBody(fn) &#123;<br>reason = <span class="hljs-string">&quot;no function body&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If fn is synthetic hash or eq function, cannot inline it.</span><br><span class="hljs-comment">// The function is not generated in Unified IR frontend at this moment.</span><br><span class="hljs-keyword">if</span> ir.IsEqOrHashFunc(fn) &#123;<br>reason = <span class="hljs-string">&quot;type eq/hash function&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>无函数名</strong>：如果函数没有名字，不能内联。</li><li><strong>有 <code>go:noinline</code> 指令</strong>：显式标记为不内联。</li><li><strong>有 <code>go:norace</code> 指令并在 <code>-race</code> 编译模式下</strong>：在竞态检测编译模式下不内联标记为 <code>norace</code> 的函数。</li><li><strong>有 <code>go:nocheckptr</code> 指令并在 <code>-d checkptr</code> 编译模式下</strong>：在指针检查编译模式下不内联标记为 <code>nocheckptr</code> 的函数。</li><li><strong>有 <code>go:cgo_unsafe_args</code> 指令</strong>：对于标记为 <code>cgo_unsafe_args</code> 的函数，由于参数布局的假设，不内联。</li><li><strong>有 <code>go:uintptrkeepalive</code> 指令</strong>：不内联标记为 <code>uintptrkeepalive</code> 的函数。</li><li><strong>有 <code>go:uintptrescapes</code> 指令</strong>：不内联标记为 <code>uintptrescapes</code> 的函数。</li><li><strong>有 <code>go:yeswritebarrierrec</code> 指令</strong>：为了防止写屏障记录检查器的混淆，不内联标记为 <code>yeswritebarrierrec</code> 的函数。</li><li><strong>无函数体</strong>：本地定义但没有函数体的函数（外部定义的 Go 函数）不可内联。</li><li><strong>是合成的 hash 或 eq 函数</strong>：不能内联这些类型的函数。</li></ol><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>我们通过一段代码来看看编译器的函数内联情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(index <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> index<br>&#125;<br><span class="hljs-keyword">return</span> Fib(index<span class="hljs-number">-1</span>) + Fib(index<span class="hljs-number">-2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForSearch</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> s = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> s[i] == i &#123;<br>res = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>SayHello()<br>Fib(<span class="hljs-number">65</span>)<br>ForSearch()<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译时我们可以加入 <code>-m=2</code> 标签，来打印函数的内联调试信息。在 <code>main.go</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:3:6: can inline SayHello with cost 7 as: func() string &#123; s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-built_in">return</span> s &#125;<br>main.go:8:6: cannot inline Fib: recursive<br>main.go:15:6: can inline ForSearch with cost 45 as: func() int &#123; s := []int&#123;...&#125;; res := 0; <span class="hljs-keyword">for</span> loop; <span class="hljs-built_in">return</span> res &#125;<br>main.go:26:6: cannot inline main: <span class="hljs-keyword">function</span> too complex: cost 116 exceeds budget 80<br>main.go:27:10: inlining call to SayHello<br>main.go:29:11: inlining call to ForSearch<br>main.go:16:15: []int&#123;...&#125; does not escape<br>main.go:29:11: []int&#123;...&#125; does not escape<br></code></pre></td></tr></table></figure><p>可以看到 <code>SayHello()</code> 和 <code>ForSearch</code> 都被内联了，而 <code>Fib()</code> 因为有递归，所以不会被内联。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析是 Go 语言中非常重要的优化阶段，<strong>用于标识变量内存应该被分配在栈上还是堆上</strong>。</p><p>在传统的 C 或 C++ 开发中，开发者经常会犯的错误就是函数返回了一个栈上的对象指针，在函数执行完毕后，函数栈会被销毁，如果继续访问被销毁栈上的对象指针，那么就会出现问题。</p><p>Go 语言能够通过编译时的逃逸分析识别这种问题，自动将这类变量放置到堆区，并借助 Go 运行时的垃圾回收机制自动释放内存。编译器会尽可能地将变量放置在栈上，因为栈中的对象会随着函数调用结束被自动销毁，这可以减轻运行时分配和垃圾回收的负担。</p><p>在 Go 语言中，开发者模糊了栈区和堆区的区别，不管是字符串、数组字面量，还是通过 new、make 标识符创建的对象，都既可能被分配到栈上，也可能被分配到堆上。但是，整体上会遵循 2 个原则：</p><ol><li>指向栈上对象的指针不能被存储到堆上；</li><li>指向栈上对象的指针不能超过该栈对象的生命周期。</li></ol><p>这部分的代码主要在 <a href="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/escape">escape</a>。</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>Go 语言通过对 AST 的静态数据流分析来实现逃逸分析（<a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/graph.go">escape&#x2F;graph.go</a>），在这个过程，它会构建带权重的有向图，其中权重可以表面当前变量引用和解引用的数量。</p><ul><li>引用（&amp;a） 减 1</li><li>解引用（*a）加 1</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> deref(where ir.Node, why <span class="hljs-type">string</span>) hole &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">1</span>).note(where, why) &#125; <span class="hljs-comment">// 解引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> addr(where ir.Node, why <span class="hljs-type">string</span>) hole  &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">-1</span>).note(where, why) &#125; <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>具体来说，Go 逃逸分析会按照如下规则生成数据流图（带权重的有向图）：</p><ol><li>每个变量作为一个节点（location）；</li><li>每个赋值动作是一个有向边（edge），赋值给谁则指向谁；</li><li>解引用（deref），即 <code>*</code>操作会给边的权重 +1；</li><li>引用（addr），即 <code>&amp;</code> 操作会给边权重 -1。</li></ol><p>其中：<strong>节点权重 &#x3D; 指向的节点权重 + 边权重</strong></p><p>逃逸分析的目标就是<strong>找到其中节点权重为 -1 的变量</strong>，并结合上述提到的 2 个原则，来判断要不要将变量分配到堆上。</p><h3 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h3><p>我们举一个例子来进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) <br>*l = <span class="hljs-number">42</span><br>m := &amp;l<br>n := &amp;m<br>o = **n<br>&#125;<br></code></pre></td></tr></table></figure><p>再次回顾一下，<code>*</code> 是加 1，<code>&amp;</code> 是减一。按照常规思路，我们从上往下分析：</p><p>先画出节点的赋值顺序，赋值给谁，边就指向谁：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203193913047.png" alt="第1步：梳理节点顺序"></p><p>然后根据引用和解引用给边赋权重，因为 <code>new(int)</code> 其实就是分配一个 <code>int(0)</code> 并取地址，相当于 <code>&amp;</code>，所以指向 <code>l</code> 的边权重是 <code>-1</code>：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194101882.png" alt="第2步：给边赋值"></p><p>节点权重 &#x3D; 边权重 + 指向节点权重，因为没有对 <code>o</code> 变量进行任何的操作，所以 <code>o</code> 权重为 0，从右往左推可以得到：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194432349.png" alt="第3步：计算节点权重"></p><p>经过分析，我们就找到了节点权重为 <code>-1</code> 的节点 <code>new(int)</code>，又由于它的节点变量地址最终会被传递到变量 <code>o</code> 上，结合之前的 2 个原则，<code>o</code> 是一个全局变量，声明周期是超过函数栈的，所以 <code>new(int)</code> 会被分配到堆上。</p><p>可以执行下面语句输出逃逸结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:5:6: can inline main<br>/escape/main.go:6:10: new(int) escapes to hea<br></code></pre></td></tr></table></figure><p>也可以执行下面语句输出数据流图构建过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags=<span class="hljs-string">&quot;-m -m -l&quot;</span> main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>./main.go:6:10: new(int) escapes to heap:<br>./main.go:6:10:   flow: l = &amp;&#123;storage <span class="hljs-keyword">for</span> new(int)&#125;:<br>./main.go:6:10:     from new(int) (spill) at ./main.go:6:10<br>./main.go:6:10:     from l := new(int) (assign) at ./main.go:6:4<br>./main.go:6:10:   flow: m = &amp;l:<br>./main.go:6:10:     from &amp;l (address-of) at ./main.go:8:7<br>./main.go:6:10:     from m := &amp;l (assign) at ./main.go:8:4<br>./main.go:6:10:   flow: n = &amp;m:<br>./main.go:6:10:     from &amp;m (address-of) at ./main.go:9:7<br>./main.go:6:10:     from n := &amp;m (assign) at ./main.go:9:4<br>./main.go:6:10:   flow: &#123;heap&#125; = **n:<br>./main.go:6:10:     from *n (indirection) at ./main.go:10:7<br>./main.go:6:10:     from *(*n) (indirection) at ./main.go:10:6<br>./main.go:6:10:     from o = *(*n) (assign) at ./main.go:10:4<br>./main.go:6:10: new(int) escapes to heap<br></code></pre></td></tr></table></figure><p>如果我们试一下，把 <code>o</code> 放在 <code>main()</code> 里面呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*l = <span class="hljs-number">42</span><br>m := &amp;l <br>n := &amp;m <br>o = **n <br>o = o   <span class="hljs-comment">// 让编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:3:6: can inline main<br>/escape/main.go:5:10: new(int) does not escape<br></code></pre></td></tr></table></figure><p>如我们所想，虽然 <code>new(int)</code> 的权重为 <code>-1</code>，但是它的声明周期始终没有超过 <code>main()</code>，所以没必要逃逸到堆上。</p><h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>变量捕获主要是针对闭包（closure）场景而言的，由于闭包函数中可能引用闭包外的变量，因此变量捕获需要明确在闭包中通过值引用或者地址引用的方式来捕获变量。</p><p>这一过程在前面提到的逃逸分析过程中进行，具体实现在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/escape.go">escape&#x2F;escape.go</a> 的 <code>flowClosure()</code> 函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *batch)</span></span> flowClosure(k hole, clo *ir.ClosureExpr) &#123;<br>    <span class="hljs-comment">// 遍历闭包中的所有变量</span><br>    <span class="hljs-keyword">for</span> _, cv := <span class="hljs-keyword">range</span> clo.Func.ClosureVars &#123;<br>        n := cv.Canonical()<br>        loc := b.oldLoc(cv)<br>        <span class="hljs-comment">// 如果变量未被捕获，则触发错误</span><br>        <span class="hljs-keyword">if</span> !loc.captured &#123;<br>            base.FatalfAt(cv.Pos(), <span class="hljs-string">&quot;closure variable never captured: %v&quot;</span>, cv)<br>        &#125;<br><br>        <span class="hljs-comment">// 根据变量的特性决定是通过值还是引用捕获</span><br>        <span class="hljs-comment">// 如果变量未被重新赋值或取址，并且小于等于 128 字节，则通过值捕获</span><br>        n.SetByval(!loc.addrtaken &amp;&amp; !loc.reassigned &amp;&amp; n.Type().Size() &lt;= <span class="hljs-number">128</span>)<br>        <span class="hljs-keyword">if</span> !n.Byval() &#123;<br>            n.SetAddrtaken(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">// 特殊情况处理：字典变量不通过值捕获</span><br>            <span class="hljs-keyword">if</span> n.Sym().Name == typecheck.LocalDictName &#123;<br>                base.FatalfAt(n.Pos(), <span class="hljs-string">&quot;dictionary variable not captured by value&quot;</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 记录闭包捕获变量的方式（值或引用）</span><br>        <span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>            how := <span class="hljs-string">&quot;ref&quot;</span><br>            <span class="hljs-keyword">if</span> n.Byval() &#123;<br>                how = <span class="hljs-string">&quot;value&quot;</span><br>            &#125;<br>            base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%v capturing by %s: %v (addr=%v assign=%v width=%d)&quot;</span>, n.Curfn, how, n, loc.addrtaken, loc.reassigned, n.Type().Size())<br>        &#125;<br><br>        <span class="hljs-comment">// 建立闭包变量的数据流</span><br>        k := k<br>        <span class="hljs-keyword">if</span> !cv.Byval() &#123;<br>            k = k.addr(cv, <span class="hljs-string">&quot;reference&quot;</span>)<br>        &#125;<br>        b.flow(k.note(cv, <span class="hljs-string">&quot;captured by a closure&quot;</span>), loc)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句看看变量的捕获方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go  | grep <span class="hljs-string">&quot;capturing&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:4:2: main capturing by ref: a (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">true</span> width=8)<br>main.go:5:2: main capturing by value: b (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">false</span> width=8)<br></code></pre></td></tr></table></figure><p>可以看到 <code>a</code> 是通过 <code>ref 地址引用</code> 的方式进行引用的，而 <code>b</code> 是通过 <code>value 值传递</code> 的方式进行引用的。</p><p>简单分析一下：上述例子中，闭包引用了 <code>a</code> 和 <code>b</code> 这 2 个闭包外声明的变量，而变量 <code>a</code> 在闭包之前又做了一些其他的操作，而 b 没有，所以对于 <code>a</code>，因为闭包外有操作，所以闭包内的操作可能是有特殊意义的，需要反馈到闭包外，就需要用 <code>ref 地址引用</code>了，而 <code>b</code> 在闭包外并不关心，所以闭包内的操作不会影响到闭包外，故直接使用 <code>value 值传递</code> 即可。</p><h2 id="闭包重写"><a href="#闭包重写" class="headerlink" title="闭包重写"></a>闭包重写</h2><p>逃逸分析后，现在我们进入 <code>walk</code> 阶段了。这里首先会进行闭包重写。其核心逻辑在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/walk/closure.go">walk&#x2F;closure.go</a> 中。</p><p>闭包重写分为 2 种情况：</p><ul><li>闭包定义后被立即调用</li><li>闭包定义后不立即调用</li></ul><h3 id="闭包定义后被立即调用"><a href="#闭包定义后被立即调用" class="headerlink" title="闭包定义后被立即调用"></a>闭包定义后被立即调用</h3><p>在闭包定义后被立即调用的情况下，闭包只会被调用一次，这时可以将闭包转换为普通函数的调用形式。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换为普通函数的调用形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> func1(&amp;a, b)<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-comment">// 注意这里 a 的类型的 *int，因为在变量捕获阶段，判断了 a 应该用地址引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(a *<span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> &#123;<br>add(*a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器具体的处理逻辑在 <code>directClosureCall()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// directClosureCall rewrites a direct call of a function literal into</span><br><span class="hljs-comment">// a normal function call with closure variables passed as arguments.</span><br><span class="hljs-comment">// This avoids allocation of a closure object.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For illustration, the following call:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//byref++</span><br><span class="hljs-comment">//&#125;(42)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// becomes:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(byval int, &amp;byref *int, a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//(*&amp;byref)++</span><br><span class="hljs-comment">//&#125;(byval, &amp;byref, 42)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directClosureCall</span><span class="hljs-params">(n *ir.CallExpr)</span></span> &#123;<br>clo := n.X.(*ir.ClosureExpr)<br>clofn := clo.Func<br><br>    <span class="hljs-comment">// 如果闭包足够简单，不进行处理，留给 walkClosure 处理。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// leave for walkClosure to handle</span><br>&#125;<br><br><span class="hljs-comment">// 将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</span><br><span class="hljs-keyword">var</span> params []*types.Field<br><span class="hljs-keyword">var</span> decls []*ir.Name<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> clofn.ClosureVars &#123;<br><span class="hljs-keyword">if</span> !v.Byval() &#123;<br><span class="hljs-comment">// 对于引用捕获的变量，创建相应的指针参数。</span><br>addr := ir.NewNameAt(clofn.Pos(), typecheck.Lookup(<span class="hljs-string">&quot;&amp;&quot;</span>+v.Sym().Name))<br>addr.Curfn = clofn<br>addr.SetType(types.NewPtr(v.Type()))<br>v.Heapaddr = addr<br>v = addr<br>&#125;<br><br>v.Class = ir.PPARAM<br>decls = <span class="hljs-built_in">append</span>(decls, v)<br><br>fld := types.NewField(src.NoXPos, v.Sym(), v.Type())<br>fld.Nname = v<br>params = <span class="hljs-built_in">append</span>(params, fld)<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</span><br>f := clofn.Nname<br>typ := f.Type()<br>typ = types.NewSignature(<span class="hljs-literal">nil</span>, <span class="hljs-built_in">append</span>(params, typ.Params().FieldSlice()...), typ.Results().FieldSlice())<br>f.SetType(typ)<br>clofn.Dcl = <span class="hljs-built_in">append</span>(decls, clofn.Dcl...)<br><br><span class="hljs-comment">// 将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</span><br>n.X = f<br>n.Args.Prepend(closureArgs(clo)...)<br><br><span class="hljs-comment">// 调整调用表达式的类型，以反映参数和返回值类型的变化。</span><br><span class="hljs-keyword">if</span> typ.NumResults() == <span class="hljs-number">1</span> &#123;<br>n.SetType(typ.Results().Field(<span class="hljs-number">0</span>).Type)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>n.SetType(typ.Results())<br>&#125;<br><br><span class="hljs-comment">// 虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</span><br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是 Go 编译器中的 <code>directClosureCall</code> 函数，用于将直接调用的函数字面量重写为正常的函数调用，同时将闭包变量作为参数传递。这避免了闭包对象的分配。</p><p>主要步骤如下：</p><ol><li><strong>检查闭包是否简单</strong>：如果闭包足够简单，不进行处理，留给 <code>walkClosure</code> 处理。</li><li><strong>处理闭包变量</strong>：将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</li><li><strong>更新函数类型和声明</strong>：创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</li><li><strong>重写调用</strong>：将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</li><li><strong>更新调用表达式类型</strong>：调整调用表达式的类型，以反映参数和返回值类型的变化。</li><li><strong>添加到待编译列表</strong>：虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</li></ol><p>这个函数的目的是优化闭包的调用，通过避免闭包对象的分配来提高性能。</p><h3 id="闭包定义后不立即调用"><a href="#闭包定义后不立即调用" class="headerlink" title="闭包定义后不立即调用"></a>闭包定义后不立即调用</h3><p>如果闭包定义后不被立即调用，而是后续调用，那么同一个闭包可能会被调用多次，这个时候就必须创建闭包对象了。</p><p>编译器具体的处理逻辑在 <code>walkClosure()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkClosure</span><span class="hljs-params">(clo *ir.ClosureExpr, init *ir.Nodes)</span></span> ir.Node &#123;<br>clofn := clo.Func<br><br><span class="hljs-comment">// 如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">if</span> base.Debug.Closure &gt; <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(clo.Pos(), <span class="hljs-string">&quot;closure converted to global&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> clofn.Nname<br>&#125;<br><br><span class="hljs-comment">// 对于复杂闭包，设置需要上下文标记，并进行运行时检查。</span><br>ir.ClosureDebugRuntimeCheck(clo)<br>clofn.SetNeedctxt(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 确保闭包函数不会被重复添加到编译队列。</span><br><span class="hljs-keyword">if</span> !clofn.Walked() &#123;<br>clofn.SetWalked(<span class="hljs-literal">true</span>)<br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br><br><span class="hljs-comment">// 构造一个复合字面量表达式来表示闭包实例。</span><br>typ := typecheck.ClosureType(clo)<br><br>    <span class="hljs-comment">// 将闭包函数和捕获的变量作为字段添加到闭包结构中。</span><br>clos := ir.NewCompLitExpr(base.Pos, ir.OCOMPLIT, typ, <span class="hljs-literal">nil</span>)<br>clos.SetEsc(clo.Esc())<br>clos.List = <span class="hljs-built_in">append</span>([]ir.Node&#123;ir.NewUnaryExpr(base.Pos, ir.OCFUNC, clofn.Nname)&#125;, closureArgs(clo)...)<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> clos.List &#123;<br>clos.List[i] = ir.NewStructKeyExpr(base.Pos, typ.Field(i), value)<br>&#125;<br><br>    <span class="hljs-comment">// 创建闭包结构的地址，并进行类型转换以符合闭包类型。</span><br>addr := typecheck.NodAddr(clos)<br>addr.SetEsc(clo.Esc())<br>cfn := typecheck.ConvNop(addr, clo.Type())<br><br><span class="hljs-comment">// 如果存在预分配的闭包对象，进行相关处理。</span><br><span class="hljs-keyword">if</span> x := clo.Prealloc; x != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !types.Identical(typ, x.Type()) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;closure type does not match order&#x27;s assigned type&quot;</span>)<br>&#125;<br>addr.Prealloc = x<br>clo.Prealloc = <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 对最终构建的闭包表达式进行进一步处理。</span><br><span class="hljs-keyword">return</span> walkExpr(cfn, init)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>检查是否为简单闭包</strong>：如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</li><li><strong>处理非简单闭包</strong>：对于复杂闭包，设置需要上下文标记，并进行运行时检查。</li><li><strong>防止重复处理</strong>：确保闭包函数不会被重复添加到编译队列。</li><li><strong>创建闭包结构</strong>：构造一个复合字面量表达式来表示闭包实例。</li><li><strong>填充闭包参数</strong>：将闭包函数和捕获的变量作为字段添加到闭包结构中。</li><li><strong>地址和类型转换</strong>：创建闭包结构的地址，并进行类型转换以符合闭包类型。</li><li><strong>处理预分配的闭包</strong>：如果存在预分配的闭包对象，进行相关处理。</li><li><strong>表达式处理</strong>：对最终构建的闭包表达式进行进一步处理。</li></ol><h2 id="遍历函数"><a href="#遍历函数" class="headerlink" title="遍历函数"></a>遍历函数</h2><p>闭包重写后，会进入 walk 阶段，如官方 文档所说：这是对 IR 表示的最后一次遍历，它有两个目的：</p><ol><li>将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；</li><li>将高级 Go 构造转换为更原始的构造。</li></ol><p>举个例子，<code>walkRange()</code> 函数针对不同类型的 <code>range</code> 语句（数组、切片、映射、通道和字符串）进行处理，将其转换为更基本的循环结构，并应用必要的变换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkRange</span><span class="hljs-params">(nrange *ir.RangeStmt)</span></span> ir.Node &#123;<br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 遍历 range 语句的不同情况</span><br>    <span class="hljs-keyword">switch</span> t.Kind() &#123;<br>    <span class="hljs-keyword">default</span>:<br>        base.Fatalf(<span class="hljs-string">&quot;walkRange&quot;</span>)<br><br>    <span class="hljs-comment">// 处理数组、切片、指针（指向数组）的情况</span><br>    <span class="hljs-keyword">case</span> types.TARRAY, types.TSLICE, types.TPTR:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理映射的情况</span><br>    <span class="hljs-keyword">case</span> types.TMAP:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理通道的情况</span><br>    <span class="hljs-keyword">case</span> types.TCHAN:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理字符串的情况</span><br>    <span class="hljs-keyword">case</span> types.TSTRING:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 构建并返回新的 for 语句</span><br>    nfor.PtrInit().Append(init...)<br>    typecheck.Stmts(nfor.Cond.Init())<br>    nfor.Cond = typecheck.Expr(nfor.Cond)<br>    nfor.Cond = typecheck.DefaultLit(nfor.Cond, <span class="hljs-literal">nil</span>)<br>    nfor.Post = typecheck.Stmt(nfor.Post)<br>    typecheck.Stmts(body)<br>    nfor.Body.Append(body...)<br>    nfor.Body.Append(nrange.Body...)<br><br>    <span class="hljs-keyword">var</span> n ir.Node = nfor<br>    n = walkStmt(n)<br><br>    base.Pos = lno<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码在 <a href="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/walk">walk</a>，对其他优化感兴趣的读者可以阅读这部分的代码。</p><h2 id="SSA-生成"><a href="#SSA-生成" class="headerlink" title="SSA 生成"></a>SSA 生成</h2><p>遍历函数（Walk）阶段后，编译器会将 AST 转换为下一个重要的中间表示形态，称为 SSA，其全称为 Static Single Assignment，静态单赋值。SSA 被大多数现代的编译器（包括 GCC 和 LLVM）使用，用于编译过程中的优化和代码生成。其核心特点和用途如下：</p><ol><li><strong>变量唯一赋值</strong>：在 SSA 形式中，每个变量只被赋值一次，使得变量的使用和修改更加清晰。</li><li><strong>方便的数据流分析</strong>：SSA 使得数据流分析更加直接和高效，因为每个变量的赋值点只有一个。</li><li><strong>优化算法的基础</strong>：许多编译器优化技术，如死代码消除、常量传播、强度削减等，在 SSA 形式下更易实现。</li><li><strong>Phi 函数</strong>：SSA 引入了 Phi 函数来处理变量在不同控制流路径上的不同赋值。</li><li><strong>代码生成</strong>：SSA 形式简化了目标代码生成的过程，因为它提供了更清晰的操作和变量使用视图。</li></ol><p>官方对 SSA 生成阶段进行了详细的描述：<a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/README.md">Introduction to the Go compiler’s SSA backend</a></p><p>Go 提供了强有力的工具查看 SSA 初始及其后续优化阶段生成的代码片段，可以通过编译时指定 <code>GOSSAFUNC=&#123;pkg.func&#125;</code> 实现。</p><p>以下面代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> d <span class="hljs-type">uint8</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>a = <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>a = <span class="hljs-number">3</span><br>&#125;<br>d = a<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以自行简单分析一下，这段代码前面 <code>a</code> 的所有操作其实都是无意义的，整段代码其实就在说 <code>d = 3</code> 这件事。</p><p>在 linux 或者 mac 上执行： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GOSSAFUNC=main.main <span class="hljs-keyword">go</span> build main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>在 Windows 上执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:GOSSAFUNC</span>=<span class="hljs-string">&quot;main&quot;</span><br>go build .\main.go<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dumped SSA to .\ssa.html<br></code></pre></td></tr></table></figure><p>通过浏览器打开生成的 <code>ssa.html</code> 文件，我们可以看到 SSA 的初始阶段、优化阶段和最终阶段的代码片段。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ssa.png" alt="ssa.html 文件示例"></p><p>我们直接看最终的结果，来看看我们前面的分析正确与否：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203211001137.png" alt="ssa 最终结果"></p><p>可以看到这一行：<code>00003 (**+11**) MOVB $3, main.d(SB)</code>，那其实就是直接 <code>d = 3</code>。</p><h2 id="机器码生成"><a href="#机器码生成" class="headerlink" title="机器码生成"></a>机器码生成</h2><p>在 SSA 阶段，编译器先执行与特定指令集无关的优化，再执行与特定指令集有关的优化，并最终生成与特定指令集有关的指令和寄存器分配方式。如  <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/genericOps.go">ssa&#x2F;_gen&#x2F;genericOps.go</a> 中包含了与特定指令集无关的 Op 操作，在 <a href="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/S390XOps.go">ssa&#x2F;_gen&#x2F;AMD64Ops.go</a> 中包含了和 AMD64 指令集相关的 Op 操作。</p><p>机器码生成阶段是编译器的机器依赖阶段，主要过程如下：</p><ol><li><strong>Lowering 过程</strong>：这个过程将通用的 SSA 形式转换为特定于目标机器的变体。这包括将通用操作符替换为针对特定硬件优化的操作。</li><li><strong>代码优化</strong>：在机器特定的形式上执行最终优化，进一步提高代码效率。</li><li><strong>生成机器指令</strong>：将 Go 函数转换为 <code>obj.Prog</code> 指令序列。</li><li><strong>汇编和输出</strong>：这些指令由 <code>cmd/internal/obj</code> 模块的汇编器处理，转换为机器代码，并输出最终的目标文件。</li></ol><p>Go 为我们了解 Go 语言程序的编译和链接过程提供了一个非常好用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n<br></code></pre></td></tr></table></figure><p>其中 <code>-n</code> 表示<strong>只输出编译过程中将要执行的 shell 命令，但不执行</strong>。</p><p>以下面程序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cast&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := cast.ToInt(<span class="hljs-string">&quot;1&quot;</span>)<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序引入了标准库 <code>fmt</code> 以及第三方库 <code>github.com/spf13/cast</code>。</p><p>在工程目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n -o main<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/<br><span class="hljs-built_in">cat</span> &gt;<span class="hljs-variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="hljs-string">&#x27;EOF&#x27;</span> <span class="hljs-comment"># internal</span><br>packagefile go-compilation=/Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>packagefile <span class="hljs-built_in">fmt</span>=/Users/wangjiahan/Library/Caches/go-build/10/10ab74ff0df27a2f4bdbe7651290f13ad466f3df63e11241e07ccd21c169b206-d<br>packagefile github.com/spf13/cast=/Users/wangjiahan/Library/Caches/go-build/77/77eed0b7028cfc4c90d78d6670325d982325399573dff9d7f82ffbf76e4559e8-d<br>...<br>packagefile net/url=/Users/wangjiahan/Library/Caches/go-build/72/72d0ef9b8f99a52bf1de760bb2f630998d6bb66a3d2a3fa66bd66f4efddfbc71-d<br>modinfo <span class="hljs-string">&quot;0w\xaf\f\x92t\b\x02A\xe1\xc1\a\xe6\xd6\x18\xe6path\tgo-compilation\nmod\tgo-compilation\t(devel)\t\ndep\tgithub.com/spf13/cast\tv1.6.0\th1:GEiTHELF+vaR5dhz3VqZfFSzZjYbgeKDpBxQVS4GYJ0=\nbuild\t-buildmode=exe\nbuild\t-compiler=gc\nbuild\tCGO_ENABLED=1\nbuild\tCGO_CFLAGS=\nbuild\tCGO_CPPFLAGS=\nbuild\tCGO_CXXFLAGS=\nbuild\tCGO_LDFLAGS=\nbuild\tGOARCH=arm64\nbuild\tGOOS=darwin\n\xf92C1\x86\x18 r\x00\x82B\x10A\x16\xd8\xf2&quot;</span><br>EOF<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/exe/<br><span class="hljs-built_in">cd</span> .<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=FDJiS-4glijTlqBbjVbe/UWsngURatTblImv3DE6-/OjO-hZGekrr-XpHFs_zA/FDJiS-4glijTlqBbjVbe -extld=cc /Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w <span class="hljs-variable">$WORK</span>/b001/exe/a.out <span class="hljs-comment"># internal</span><br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$WORK</span>/b001/exe/a.out main<br></code></pre></td></tr></table></figure><p>这里建议你先尝试自行分析一下这个编译过程，再继续往下阅读。</p><p>经过分析，上述过程可以分为以下 8 个步骤：</p><ol><li><strong>创建工作目录</strong>：<code>mkdir -p $WORK/b001/</code> 创建一个临时工作目录，用于存放编译过程中的临时文件。</li><li><strong>生成导入配置文件</strong>：<code>cat &gt;$WORK/b001/importcfg.link &lt;&lt; &#39;EOF&#39;</code> 命令开始创建一个名为 <code>importcfg.link</code> 的文件，这个文件包含了编译过程中需要的包文件路径。</li><li><strong>写入包文件路径</strong>：接下来的多行内容是对 <code>importcfg.link</code> 文件的填充，指定了各个依赖包的存储位置。</li><li><strong>结束文件写入</strong>：<code>EOF</code> 标志着 <code>importcfg.link</code> 文件内容的结束。</li><li><strong>创建可执行文件目录</strong>：<code>mkdir -p $WORK/b001/exe/</code> 创建一个目录，用于存放最终的可执行文件。</li><li><strong>编译链接</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/a.out ...</code> 这一步是编译链接的核心，它使用Go的链接工具，根据之前生成的 <code>importcfg.link</code> 文件，将代码编译成可执行文件。</li><li><strong>更新构建ID</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w $WORK/b001/exe/a.out</code> 这一步更新了可执行文件的构建ID。</li><li><strong>移动可执行文件</strong>：<code>mv $WORK/b001/exe/a.out main</code> 将编译好的可执行文件移动到当前目录，并重命名为 <code>main</code>。</li></ol><p>如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img6sR2uDuHwbkSNk3FuUxHmY-20231129143014805.png" alt="Go语言编译和链接过程"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile">Go1.21 官方文档</a></li><li><a href="https://book.douban.com/subject/35556889/">《Go 语言底层原理剖析》</a></li><li><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">《Go 语言设计与实现》</a></li><li><a href="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">Go: Overview of the Compiler</a></li><li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">维基百科 - AST</a></li><li><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">维基百科 - SSA</a></li><li><a href="https://zhuanlan.zhihu.com/p/592602585">Go 机制：逃逸分析学习笔记</a></li><li>ChatGPT-4</li></ul><hr><p>以上便是 Go 语言在 1.21.0 这个版本下编译过程的整个过程，笔者会在阅读完《用 Go 语言自制解释器》和《用 Go 语言自制编译器》这两本书后，若有对编译原理有更深入的体会和感悟，再回过来对本文的内容进行勘误和进一步提炼。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 顺序消息实现</title>
    <link href="/2023/11/23/kafka-ordered-msg/"/>
    <url>/2023/11/23/kafka-ordered-msg/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>本文所有的讨论均在如下版本进行，其他版本可能会有所不同。</p><ul><li>Kafka: 3.6.0</li><li>Pulsar: 2.9.0</li><li>RabbitMQ 3.7.8</li><li>RocketMQ 5.0</li><li>Go1.21</li><li>github.com&#x2F;segmentio&#x2F;kafka-go v0.4.45</li></ul><h2 id="结论先行"><a href="#结论先行" class="headerlink" title="结论先行"></a>结论先行</h2><p>Kafka 只能保证单一分区内的顺序消息，无法保证多分区间的顺序消息。具体来说，要在 Kafka 完全实现顺序消息，至少需要保证以下几个条件：</p><ol><li>同一生产者生产消息；</li><li>同步发送消息到 Kafka broker；</li><li>所有消息发布到同一个分区；</li><li>同一消费者同步按照顺序消费消息。</li></ol><p>而要满足第 3 点，常用的有 2 种思路：</p><ol><li>固定消息的 key，生产端采用 <code>key hash</code> 的方式写入  broker；</li><li>自定义分区策略，要保证顺序的消息都写入到指定的分区。</li></ol><h2 id="消息队列中的顺序消息如何实现"><a href="#消息队列中的顺序消息如何实现" class="headerlink" title="消息队列中的顺序消息如何实现"></a>消息队列中的顺序消息如何实现</h2><h3 id="顺序消息定义"><a href="#顺序消息定义" class="headerlink" title="顺序消息定义"></a>顺序消息定义</h3><p>生产端发送出来的消息的顺序和消费端接收到消息的顺序是一样的。</p><h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p>一般来说，消息队列都是基于<strong>顺序存储结构</strong>来存储数据的，不需要 B 树、B+ 树等复杂数据结构，利用文件的顺序读写，性能也很高。所以理想情况下，生产者按顺序发送消息，broker 会按顺序存储消息，消费者再按顺序消费消息，那么天然就实现了我们要的<strong>顺序消息</strong>了，如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231124235214392.png" alt="消息队列顺序存储结构"></p><h3 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h3><p>但是一般情况下，消息队列为了支持更高的并发和吞吐，大多数都有分区（partition）和消费者组（consumer group）机制，而为了高可用，一般也会有副本（replica）机制，所以情况就复杂得多了，如下面几个例子，就会导致消息失序：</p><ol><li>多个生产者同时发送消息，那么到达 broker 的时间也是不确定的，所以 broker 就无法保证落盘的顺序性了；</li><li>单个生产者，但是采用异步发送，因为异步线程是并发执行的，由 CPU 进行调度，且有可能会因为发送失败而重试，所以也无法保证消息可以按照顺序到达 broker，同理，消费者异步处理消息，也无法保证顺序性；</li><li>一个 topic 有多个分区，那么即使是同一个生产者，由于分区策略，消息可能会被分发到多个分区中，消费者也就无法保证顺序性了。</li></ol><p>所以到这里，我们可以总结出实现顺序消息，至少需要满足以下 3 点：</p><ol><li>单一生产者同步发送；</li><li>单一分区；</li><li>单一消费者同步消费；</li></ol><p>第 1、3 点比较简单，Kafka 通过分区和 offset 的方式保证了消息的顺序。每个分区都是一个有序的、不可变的消息序列，每个消息在分区中都有一个唯一的序数标识，称为 <code>offset</code>。生产者在发送消息到分区时，Kafka 会自动为消息分配一个 offset。消费者在读取消息时，会按照 offset 的顺序来读取，从而保证了消息的顺序。</p><p>下面我们主要来谈一谈第 2 点。</p><h2 id="Kafka-顺序消息的实现"><a href="#Kafka-顺序消息的实现" class="headerlink" title="Kafka 顺序消息的实现"></a>Kafka 顺序消息的实现</h2><h3 id="写入消息的过程"><a href="#写入消息的过程" class="headerlink" title="写入消息的过程"></a>写入消息的过程</h3><ol><li><strong>配置生产者</strong>：首先，你需要配置 Kafka 生产者。这包括指定 Kafka 集群的地址和端口，以及其他相关配置项，如消息序列化器、分区策略等。</li><li><strong>创建生产者实例</strong>：在应用程序中，你需要创建一个 Kafka 生产者的实例。这个实例将用于与 Kafka 集群进行通信。</li><li><strong>序列化消息</strong>：在将消息发送到 Kafka 集群之前，你需要将消息进行序列化。Kafka 使用字节数组来表示消息的内容，因此你需要将消息对象序列化为字节数组。这通常涉及将消息对象转换为 JSON、Avro、Protobuf 等格式。</li><li><strong>选择分区</strong>：Kafka 的主题（topic）被分为多个分区（partition），每个分区都是有序且持久化的消息日志。当你发送消息时，你可以选择将消息发送到特定的分区，或者让 Kafka 根据分区策略自动选择分区。</li><li><strong>发送消息</strong>：一旦消息被序列化并选择了目标分区，你可以使用 Kafka 生产者的 <code>send()</code> 方法将消息发送到 Kafka 集群。发送消息时，生产者会将消息发送到对应分区的 leader 副本。</li><li><strong>异步发送</strong>：Kafka 生产者通常使用异步方式发送消息，这样可以提高吞吐量。生产者将消息添加到一个发送缓冲区（send buffer）中，并在后台线程中批量发送消息到 Kafka 集群。</li><li><strong>消息持久化</strong>：一旦消息被发送到 Kafka 集群的 leader 副本，它将被持久化并复制到其他副本，以确保数据的高可靠性和冗余性。只有当消息被成功写入到指定数量的副本后，生产者才会收到确认（acknowledgement）。</li><li><strong>错误处理和重试</strong>：如果发送消息时发生错误，生产者可以根据配置进行错误处理和重试。你可以设置重试次数、重试间隔等参数来控制重试行为。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125013322459.png" alt="Kafka 生产者组件 -《Kafka权威指南第2版》"></p><h3 id="实现单一分区"><a href="#实现单一分区" class="headerlink" title="实现单一分区"></a>实现单一分区</h3><p>再 Kafka 中，我们要实现将消息写入到同一个分区，有 3 种思路：</p><ul><li>配置 <code>num.partitions=1</code> 或者创建 topic 的时候指定只有 1 个分区，但这会显著降低 Kafka 的吞吐量。</li><li><strong>固定消息的 key</strong>，然后采用 <strong>key hash</strong> 的分区策略，这样就可以让所有消息都被分到同一个分区中。</li><li>实现并指定<strong>自定义分区策略</strong>，可以根据业务需求，将需要顺序消费的消息都分到固定一个分区中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如下例子，所有使用&quot;same-key&quot;作为key的消息都会被发送到同一个Partition</span><br>ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;topic&quot;</span>, <span class="hljs-string">&quot;same-key&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>);<br>producer.send(record);<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题"><a href="#重平衡带来的问题" class="headerlink" title="重平衡带来的问题"></a>重平衡带来的问题</h3><p>如果采用上述的第 2 种思路：<strong>固定消息 key，依靠 key hash 分区策略，实现单一分区</strong>。在我们只有 1 个消费者的情况下是没有问题的，但是如果我们使用的是消费者组，那么，在发生<strong>重平衡</strong>操作的时候，就可能会有问题了。</p><p>Kafka 的重平衡（Rebalance）是指 Kafka 消费者组（Consumer Group）中的消费者实例对分区的重新分配。这个过程主要发生在以下几种情况：</p><ol><li>消费者组中新的消费者加入。</li><li>消费者组中的消费者离开或者挂掉。</li><li>订阅的 Topic 的分区数发生变化。</li><li>消费者调用了 <code>#unsubscribe()</code> 或者 <code>#subscribe()</code> 方法。</li></ol><p>重平衡的过程主要包括以下几个步骤：</p><ol><li><strong>Revoke</strong>：首先，Kafka 会撤销消费者组中所有消费者当前持有的分区。</li><li><strong>Assignment</strong>：然后，Kafka 会重新计算分区的分配情况，然后将分区分配给消费者。</li><li><strong>Resume</strong>：最后，消费者会开始消费新分配到的分区。</li></ol><p>重平衡的目的是为了保证消费者组中的消费者能够公平地消费 Topic 的分区。通过重平衡，Kafka 可以在消费者的数量发生变化时，动态地调整消费者对分区的分配，从而实现负载均衡。</p><p>然而，当发生重平衡时，分区可能会被重新分配给不同的消费者，这可能会影响消息的消费顺序。</p><p>举个例子：</p><ol><li>假设消费者 A 正在消费分区 P 的消息，它已经消费了消息 1，消息 2，正在处理消息 3。</li><li>此时，发生了重平衡，分区 P 被重新分配给了消费者 B。</li><li>消费者 B 开始消费分区 P，它会从上一次提交的偏移量（offset）开始消费。假设消费者 A 在处理消息 3 时发生了故障，没有提交偏移量，那么消费者 B 会从消息 3 开始消费。</li><li>这样，消息 3 可能会被消费两次，而且如果消费者 B 处理消息 3 的速度快于消费者A，那么消息 3 可能会在消息 2 之后被处理，这就打破了消息的顺序性。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125003222491.png" alt="重平衡导致消息失序"></p><p>再举个例子：</p><ol><li>topic-A 本来只有 3 个分区，按照 key hash，key 为 <code>same-key</code> 的消息应该都发到 第 2 个分区；</li><li>但是后来 topic-A 变成了 4 个分区，按照 key hash，key 为 <code>same-key</code> 的消息可能就被发到第 3 个分区了；</li><li>这就无法做到单一分区，可能会导致消息失序。</li></ol><p>当然这个例子不是由重平衡直接引起的，但是这种情况也是有可能导致消息失序的。</p><h3 id="缓解重平衡的问题"><a href="#缓解重平衡的问题" class="headerlink" title="缓解重平衡的问题"></a>缓解重平衡的问题</h3><ul><li><strong>避免动态改变分区数</strong>：在需要严格保持消息顺序的场景下，应避免动态地改变分区数。这意味着在设计 Kafka 主题时，应提前规划好所需的分区数，以避免日后需要进行更改。</li><li><strong>使用单个分区</strong>：对于严格顺序要求的场景，可以考虑使用单分区主题。虽然这会限制吞吐量和并发性，但可以保证消息的全局顺序。</li><li><strong>使用其他策略保持顺序</strong>：在某些情况下，可以通过在应用层实现逻辑来保持顺序，比如在消息中包含顺序号或时间戳，并在消费时根据这些信息重建正确的顺序。</li><li><strong>使用静态成员功能</strong>：它允许消费者在断开和重新连接时保持其消费者组内的身份，这可以减少因短暂的网络问题或消费者重启导致的不必要的重平衡。</li></ul><p>上面这些措施，只能减少重平衡带来的问题，并无法根除，如果非要实现严格意义上的顺序消息，要么在消息中加入时间戳等标记，在业务层保证顺序消费，要么就只能采用 <code>单一生产者同步发送 + 单一分区 +单一消费者同步消费</code> 这种模式了。</p><h3 id="静态成员功能"><a href="#静态成员功能" class="headerlink" title="静态成员功能"></a>静态成员功能</h3><p>Kafka 2.3.0 版本引入了一项新功能：静态成员（Static Membership）。这个功能主要是为了减少由于消费者重平衡（rebalance）引起的开销和延迟。在传统的 Kafka 消费者组中，当新的消费者加入或离开消费者组时，会触发重平衡。这个过程可能会导致消息的处理延迟，并且在高吞吐量的场景下可能会对性能造成影响。静态成员功能旨在缓解这些问题。以下是它的一些关键点：</p><p>静态成员的工作原理：</p><ol><li><p><strong>静态成员标识</strong>：消费者在加入消费者组时可以提供一个静态成员标识（Static Member ID）。这允许 Kafka Broker 识别特定的消费者实例，而不是仅仅依赖于消费者组内的动态分配。</p></li><li><p><strong>重平衡优化</strong>：当使用静态成员功能时，如果一个已知的消费者由于某种原因（如网络问题）短暂断开后重新连接，Kafka 不会立即触发重平衡。相反，Kafka 会等待一个预设的超时期限（session.timeout.ms），在此期间如果消费者重新连接，它将保留原来的分区分配。</p></li><li><p><strong>减少重平衡次数</strong>：这大大减少了由于消费者崩溃和恢复、网络问题或维护操作引起的不必要的重平衡次数。</p></li></ol><p>使用静态成员的优点：</p><ol><li><p><strong>提高稳定性</strong>：减少重平衡可以提高消费者组的整体稳定性，尤其是在大型消费者组和高吞吐量的情况下。</p></li><li><p><strong>减少延迟</strong>：由于减少了重平衡的次数，可以减少因重平衡导致的消息处理延迟。</p></li><li><p><strong>持久的消费者分区分配</strong>：这使得消费者在分区分配上更加持久，有助于更好地管理和优化消息的消费。</p></li></ol><p>如何使用：</p><ul><li>要使用静态成员功能，需要在 Kafka 消费者的配置中设置 <code>group.instance.id</code>。这个 ID 应该是唯一的，并且在消费者重启或重新连接时保持不变。同时，还需要配置 <code>session.timeout.ms</code>，以决定在触发重平衡之前消费者可以离线多长时间。</li></ul><p>注意事项：</p><ul><li>虽然静态成员功能可以减少重平衡的发生，但它不会完全消除重平衡。在消费者组成员的长期变化（如新消费者的加入或永久离开）时，仍然会发生重平衡。</li><li>需要合理设置 <code>session.timeout.ms</code>，以避免消费者由于短暂的网络问题或其他原因的断开而过早触发重平衡。</li></ul><p>静态成员功能在处理大规模 Kafka 应用时尤其有用，它提供了一种机制来优化消费者组的性能和稳定性。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>Kafka 0.11 版本后提供了幂等性生产者，这意味着即使生产者因为某些错误重试发送相同的消息，这些消息也只会被记录一次。这是通过给每一批发送到 Kafka 的消息分配一个序列号实现的，broker 使用这个序列号来删除重复发送的消息。使用幂等性生产者，可以减少重复消息的风险，这意味着即使在网络重试等情况下，消息的顺序也能得到更好的保证。因为重复消息不会被多次记录，所以不会破坏已有消息的顺序。</p><h2 id="其他常见消息队列顺序消息的实现"><a href="#其他常见消息队列顺序消息的实现" class="headerlink" title="其他常见消息队列顺序消息的实现"></a>其他常见消息队列顺序消息的实现</h2><h3 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h3><p>Pulsar 和 Kafka 一样，都是通过生产端按 Key Hash 的方案将数据写入到同一个分区。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 在生产时没有生产分区分配的过程。它是通过 <code>Exchange</code> 和 <code>Route Key</code> 机制来实现顺序消息的。<code>Exchange</code> 会根据设置好的 <code>Route Key</code> 将数据路由到不同的 <code>Queue</code> 中存储。此时 <code>Route Key</code> 的作用和 Kafka 的消息的 <code>Key</code> 是一样的。</p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocektMQ 支持<code>消息组（MessageGroup）</code>的概念。在生产端指定消息组，则同一个消息组的消息就会被发送到同一个分区中。此时这个消息组起到的作用和 Kakfa 的消息的 Key 是一样的。</p><h2 id="实战-Kafka-实现顺序消息"><a href="#实战-Kafka-实现顺序消息" class="headerlink" title="实战 Kafka 实现顺序消息"></a>实战 Kafka 实现顺序消息</h2><blockquote><p>代码仓库：<a href="https://github.com/hedon954/kafka-go-examples/tree/master/orderedmsg">https://github.com/hedon954/kafka-go-examples/tree/master/orderedmsg</a></p></blockquote><p>下面我们来写一写实战用例，更加直观地感受一下 Kafka 顺序消息的实现细节。</p><p>首先我们在集群上创建一个 topic <code>ordered-msg-topic</code>，分区为 <code>3</code> 个，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>搭建 Kafka 集群可以看这两篇：<a href="https://hedon.top/2023/11/22/kakfa-cluster-deploy/">Kafka集群搭建(Zookeeper)</a>、<a href="https://hedon.top/2023/11/22/kafka-kraft-deploy/">Kafka集群搭建(KRaft)</a>。</p><h3 id="单生产者单消费者"><a href="#单生产者单消费者" class="headerlink" title="单生产者单消费者"></a>单生产者单消费者</h3><p>正常情况下，使用单一生产者同步发送和单一消费者同步发送，只要我们保证 key 是固定的，则所有消息都会写到同一个分区，是可以实现顺序消息的。</p><p>代码目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">├─config<br>│      config.go<span class="hljs-comment"># 常量定义</span><br>├─consumer<br>│      consumer.go<span class="hljs-comment"># 消费者</span><br>└─producer<br>        producer.go<span class="hljs-comment"># 生产者</span><br></code></pre></td></tr></table></figure><p>首先我们先定义一些常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>Topic      = <span class="hljs-string">&quot;ordered-msg-topic&quot;</span><br>Brokers    = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;kafka1.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka2.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka3.com:9092&quot;</span>&#125;<br>Addr       = kafka.TCP(Brokers...)<br>GroupId    = <span class="hljs-string">&quot;ordered-msg-group&quot;</span><br>MessageKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;message-key&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>我们先实现生产者端，主要是不断往 <code>ordered-msg-topic</code> 中写入数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewProducer</span><span class="hljs-params">()</span></span> *kafka.Writer &#123;<br><span class="hljs-keyword">return</span> &amp;kafka.Writer&#123;<br>Addr:     config.Addr,<br>Topic:    config.Topic,<br>Balancer: &amp;kafka.Hash&#123;&#125;, <span class="hljs-comment">// 哈希分区</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMessages</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []kafka.Message &#123;<br>res := <span class="hljs-built_in">make</span>([]kafka.Message, count)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>res[i] = kafka.Message&#123;<br>Key:   config.MessageKey,<br>Value: []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;msg-%d&quot;</span>, i+<span class="hljs-number">1</span>)),<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>producer := NewProducer()<br>messages := NewMessages(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> err := producer.WriteMessages(context.Background(), messages...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>_ = producer.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来实现消费者，目前我们就启动 1 个消费者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span> &#123;<br>Id <span class="hljs-type">string</span><br>*kafka.Reader<br>&#125;<br><br><span class="hljs-comment">// NewConsumer 创建一个消费者，它属于 config.GroupId 这个消费者组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsumer</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> *Consumer &#123;<br>c := &amp;Consumer&#123;<br>Id: id,<br>Reader: kafka.NewReader(kafka.ReaderConfig&#123;<br>Brokers: config.Brokers,<br>GroupID: config.GroupId,<br>Topic:   config.Topic,<br>Dialer: &amp;kafka.Dialer&#123;<br>ClientID: id,<br>&#125;,<br>&#125;),<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// Read 读取消息，intervalMs 用来控制消费者的消费速度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Read(intervalMs <span class="hljs-type">int</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s start read\n&quot;</span>, c.Id)<br><span class="hljs-keyword">for</span> &#123;<br>msg, err := c.ReadMessage(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg err: %v\n&quot;</span>, c.Id, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 模拟消费速度</span><br>time.Sleep(time.Millisecond * time.Duration(intervalMs))<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg: %s, time: %s\n&quot;</span>, c.Id, <span class="hljs-type">string</span>(msg.Value), time.Now().Format(<span class="hljs-string">&quot;03-04-05&quot;</span>))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>启动生产者生产消息，然后启动消费者，观察控制台，不难看出这种情况下就是顺序消费：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">consumer-1 read msg: msg-10, time: 04:29:10<br>consumer-1 read msg: msg-11, time: 04:29:11<br>consumer-1 read msg: msg-12, time: 04:29:12<br>consumer-1 read msg: msg-13, time: 04:29:13<br>consumer-1 read msg: msg-14, time: 04:29:14<br>consumer-1 read msg: msg-15, time: 04:29:15<br>consumer-1 read msg: msg-16, time: 04:29:16<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题-1"><a href="#重平衡带来的问题-1" class="headerlink" title="重平衡带来的问题"></a>重平衡带来的问题</h3><p>我们先重建 topic，清楚掉之前的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic ordered-msg-topic<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>下面我们来采用消费者组的形式消费消息，在这期间，我们不断往消费者组中新增消费者，使其发生重平衡，我们来观察下消息的消费情况。</p><p>修改消费者端的 main()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 先启动 c1</span><br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;()<br><br><span class="hljs-comment">// 5 秒后启动 c2</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c2 := NewConsumer(<span class="hljs-string">&quot;consumer-2&quot;</span>)<br>c2.Read(<span class="hljs-number">300</span>)<br>&#125;()<br><br><span class="hljs-comment">// 再 10 秒后启动 c3 和 c4</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c3 := NewConsumer(<span class="hljs-string">&quot;consumer-3&quot;</span>)<br>c3.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c4 := NewConsumer(<span class="hljs-string">&quot;consumer-4&quot;</span>)<br>c4.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先启动生产者重新生产数据，然后再启动消费者消费数据，观察控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">consumer-1 start <span class="hljs-built_in">read</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-1, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-2, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-3, time: 04:44:29<span class="hljs-comment"># consumer-1 按顺序消费</span><br>consumer-2 start <span class="hljs-built_in">read</span>  <span class="hljs-comment"># consumer-2 进来</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-4, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-5, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-6, time: 04:44:31      <span class="hljs-comment"># 这里相差了 6s，就是在进行重平衡</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37      <span class="hljs-comment"># 重平衡后发现原来的分区给 consumer-2 消费了</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37    <span class="hljs-comment"># 这里发生了重复消费</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-8, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-9, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-10, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-11, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-12, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-13, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-14, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-15, time: 04:44:39      <span class="hljs-comment"># consumer-2 按顺序消息</span><br>consumer-4 start <span class="hljs-built_in">read</span>   <span class="hljs-comment"># consumer-3 和 consumer-4 进来</span><br>consumer-3 start <span class="hljs-built_in">read</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-16, time: 04:44:40   <br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里发生重平衡</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-18, time: 04:44:46      <span class="hljs-comment"># 重平衡后由 consumer-4 负责该分区</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里由于 2 的速度比 4 慢很多，所以就乱序了，还重复消费</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-19, time: 04:44:46<br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-20, time: 04:44:46<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们采用消费者组的时候，由于重平衡机制的存在，单纯从 Kafka 的角度来说是无法完全实现顺序消息的，只能通过静态成员功能、避免分区数量变化和减少消费者组成员数量变化等方式来尽可能减少重平衡的发生，进而尽可能维持消息的顺序性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://time.geekbang.com/column/intro/100552001">极客时间 - 深入拆解消息队列 47 讲（许文强）</a></li><li><a href="https://www.qidian.com/book/1035938080/">《Kafka 权威指南（第 2 版）》</a></li><li><a href="https://pulsar.staged.apache.org/docs/zh-CN/next/concepts-messaging/#%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81">Pulsar 官方文档-分区topic-顺序保证</a></li><li><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">RocketMQ 官方文档-功能特性-顺序消息</a></li><li><a href="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">RabbitMQ 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署（KRaft）</title>
    <link href="/2023/11/22/kafka-kraft-deploy/"/>
    <url>/2023/11/22/kafka-kraft-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Kafka 3.6.0</li><li>JDK8</li></ul><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><table><thead><tr><th align="center">操作系统</th><th align="center">ip</th><th align="center">域名</th><th align="center">Kafka Broker 端口</th><th align="center">Kafka Controller 端口</th></tr></thead><tbody><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.131</td><td align="center">kafka1.com</td><td align="center">9092</td><td align="center">9093</td></tr><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.132</td><td align="center">kafka2.com</td><td align="center">9092</td><td align="center">9093</td></tr><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.133</td><td align="center">kafka3.com</td><td align="center">9092</td><td align="center">9093</td></tr></tbody></table><h2 id="安装-vim-curl"><a href="#安装-vim-curl" class="headerlink" title="安装 vim, curl"></a>安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts"><a href="#配置静态-ip-和-hosts" class="headerlink" title="配置静态 ip 和 hosts"></a>配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配 IP，所以需要手动设置一下每台机器 IP 地址，这里以 <code>192.168.50.131</code> 为例。</p><ol><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code> 开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code> 表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为 <code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在 <code>192.168.50.xxx</code>，所以我们会将静态 IP 配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP 地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>   address 192.168.50.131<br>   netmask 255.255.255.0<br>   gateway 192.168.50.2<br>   dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><p> Ubuntu 系统使用 <code>systemd-resolved</code> 服务来管理 DNS，你可以在 <code>/etc/systemd/resolved.conf</code> 文件中进行 DNS 配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/systemd/resolved.conf<br></code></pre></td></tr></table></figure><p>取消或添加 <code>DNS</code> 的注释，并修改为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">[Resolve]<br>DNS=8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure><p>重启启动 <code>systemd-resolved</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart systemd-resolved<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为 <code>ens33</code> 的网络接口配置了静态 IP 地址和相关的网络设置。下面是各行的解释：</p><ol><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活 <code>ens33</code> 网络接口。<code>auto</code> 关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了 <code>ens33</code> 网络接口的配置。<code>iface</code> 关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4 地址，<code>static</code> 表示我们要为接口分配一个静态 IP 地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态 IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了 <code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet 协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的 IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4 和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>: 这一行定义了子网掩码。在这个例子中，子网掩码是 <code>255.255.255.0</code>，表示前三个字节（24 位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP 地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP 地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>: 这一行设置了默认网关。在这个例子中，我们将默认网关设置为 <code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的 IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS 服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器 <code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS 服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 <a href="http://www.baidu.com)ip/">www.baidu.com）IP</a> 地址的系统。DNS 服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向 DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP 地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-Kafka"><a href="#安装-Kafka" class="headerlink" title="安装 Kafka"></a>安装 Kafka</h2><ol><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/3.6.0/kafka_2.13-3.6.0.tgz<br>tar -zxvf kafka_2.13-3.6.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-3.6.0 /opt/kafka-3.6.0<br></code></pre></td></tr></table></figure></li><li><p>使用 Kafka 提供的脚本生成一个 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=<span class="hljs-string">&quot;<span class="hljs-subst">$(/opt/kafka-3.6.0/bin/kafka-storage.sh random-uuid)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>输出 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$KAFKA_CLUSTER_ID</span><br>XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure><p>在其他节点上将 <code>KAFKA_CLUSTER_ID</code> 设置为上面的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure></li><li><p>备份配置文件，注意这里的配置文件是 <code>config/kraft/server.properties</code>，在 <code>config</code> 目录下的 <code>kraft</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /opt/kafka-3.6.0/config/kraft/server.properties /opt/kafka-3.6.0/config/kraft/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>主要修改内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 节点 ID，分别为 1，2，3</span><br><span class="hljs-attr">node.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-3.6.0/kafka-combined-logs</span><br><span class="hljs-comment"># 可以成为控制器的节点和它们的端口</span><br><span class="hljs-attr">controller.quorum.voters</span>=<span class="hljs-string">1@kafka1.com:9093,2@kafka2.com:9093,3@kafka3.com:9093</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。</span><br><span class="hljs-comment"># 这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。</span><br><span class="hljs-comment"># 例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，</span><br><span class="hljs-comment"># 那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-comment"># 这里我们需要在 3 个节点分别设置对应的地址</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>格式化日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-storage.sh format -t <span class="hljs-variable">$KAFKA_CLUSTER_ID</span> -c /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Formatting /opt/kafka-3.6.0/kraft-combined-logs with metadata.version 3.6-IV2.<br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-server-start.sh -daemon /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code> 的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code> 的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>TopicId: svJClTUpSFa9Z6FWDvkARgPartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 2Replicas: 2Isr: 2<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 3Replicas: 3Isr: 3<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，往 <code>test</code> 里面写入数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p> 输入数据后按回车即发送一条数据，可以随时按 <code>Ctrl + C</code> 退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~/Downloads$ /opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br>&gt;msg1<br>&gt;msg2<br>&gt;msg 3<br>&gt;^<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，启动消费者消费 <code>topic</code> 中的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ /opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br>msg1<br>msg2<br>msg 3<br>^CProcessed a total of 3 messages<br></code></pre></td></tr></table></figure></li></ol><p>至此，Kafka 的 KRaft 版本集群就部署完毕了！</p><div class="note note-info">            <h2 id="补充说明-KRaft-配置文件"><a href="#补充说明-KRaft-配置文件" class="headerlink" title="补充说明 - KRaft 配置文件"></a>补充说明 - KRaft 配置文件</h2><p>下面是 Kafka KRaft 版本配置文件每个配置项的解释：</p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>process.roles</td><td>Kafka 服务器的角色，设置此项将 Kafka 置于 KRaft 模式。可能的值包括 “broker” 和 “controller”。</td></tr><tr><td>node.id</td><td>与此实例关联的节点 ID。</td></tr><tr><td>controller.quorum.voters</td><td>控制器选举的投票节点，格式为 <code>node-id@host:port</code>。</td></tr><tr><td>listeners</td><td>服务器监听的地址，格式为 <code>listener_name://host_name:port</code>。</td></tr><tr><td>inter.broker.listener.name</td><td>用于 broker 之间通信的监听器名称。</td></tr><tr><td>advertised.listeners</td><td>服务器向客户端宣告的监听器名称、主机名和端口。</td></tr><tr><td>controller.listener.names</td><td>控制器使用的监听器名称列表。</td></tr><tr><td>listener.security.protocol.map</td><td>监听器名称到安全协议的映射。默认情况下，它们是相同的。</td></tr><tr><td>num.network.threads</td><td>服务器用于从网络接收请求和向网络发送响应的线程数。</td></tr><tr><td>num.io.threads</td><td>服务器用于处理请求（可能包括磁盘 I&#x2F;O）的线程数。</td></tr><tr><td>socket.send.buffer.bytes</td><td>服务器用于发送数据的缓冲区大小。</td></tr><tr><td>socket.receive.buffer.bytes</td><td>服务器用于接收数据的缓冲区大小。</td></tr><tr><td>socket.request.max.bytes</td><td>服务器接受的请求的最大大小（用于防止内存溢出）。</td></tr><tr><td>log.dirs</td><td>用于存储日志文件的目录列表。</td></tr><tr><td>num.partitions</td><td>每个主题的默认日志分区数。</td></tr><tr><td>num.recovery.threads.per.data.dir</td><td>每个数据目录在启动时用于日志恢复和关闭时用于刷新的线程数。</td></tr><tr><td>offsets.topic.replication.factor</td><td>内部主题 “__consumer_offsets” 和 “__transaction_state” 的复制因子。</td></tr><tr><td>transaction.state.log.replication.factor</td><td>事务状态日志的复制因子。</td></tr><tr><td>transaction.state.log.min.isr</td><td>事务状态日志的最小同步副本数。</td></tr><tr><td>log.flush.interval.messages</td><td>强制将数据刷新到磁盘之前接受的消息数。</td></tr><tr><td>log.flush.interval.ms</td><td>消息在日志中停留的最大时间，超过这个时间就会强制刷新到磁盘。</td></tr><tr><td>log.retention.hours</td><td>由于年龄而使日志文件有资格被删除的最小年龄。</td></tr><tr><td>log.retention.bytes</td><td>基于大小的日志保留策略。</td></tr><tr><td>log.segment.bytes</td><td>日志段文件的最大大小。</td></tr><tr><td>log.retention.check.interval.ms</td><td>检查日志段是否可以根据保留策略被删除的间隔。</td></tr></tbody></table><p>请注意，这只是 Kafka 配置的一部分，Kafka 配置的完整列表可以在 <a href="https://kafka.apache.org/36/documentation.html#configuration">Kafka 的官方文档</a>中找到。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署</title>
    <link href="/2023/11/22/kakfa-cluster-deploy/"/>
    <url>/2023/11/22/kakfa-cluster-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Zookeeper 3.5.9</li><li>Kafka 2.7.0</li><li>JDK8</li></ul><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><table><thead><tr><th align="center">操作系统</th><th align="center">ip</th><th align="center">域名</th><th align="center">Zookeeper 端口</th><th align="center">Kafka 端口</th></tr></thead><tbody><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.131</td><td align="center">kafka1.com</td><td align="center">2181</td><td align="center">9092</td></tr><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.132</td><td align="center">kafka2.com</td><td align="center">2181</td><td align="center">9092</td></tr><tr><td align="center">Ubuntu 18.04.6</td><td align="center">192.168.50.133</td><td align="center">kafka3.com</td><td align="center">2181</td><td align="center">9092</td></tr></tbody></table><h2 id="安装-vim-curl"><a href="#安装-vim-curl" class="headerlink" title="安装 vim, curl"></a>安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts"><a href="#配置静态-ip-和-hosts" class="headerlink" title="配置静态 ip 和 hosts"></a>配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配 IP，所以需要手动设置一下每台机器 IP 地址，这里以 <code>192.168.50.131</code> 为例。</p><ol><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code> 开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code> 表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为 <code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在 <code>192.168.50.xxx</code>，所以我们会将静态 IP 配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP 地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>address 192.168.50.131<br>netmask 255.255.255.0<br>gateway 192.168.50.2<br>dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>追加下面内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">nameserver 8.8.8.8<br>nameserver 8.8.4.4<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为 <code>ens33</code> 的网络接口配置了静态 IP 地址和相关的网络设置。下面是各行的解释：</p><ol><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活 <code>ens33</code> 网络接口。<code>auto</code> 关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了 <code>ens33</code> 网络接口的配置。<code>iface</code> 关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4 地址，<code>static</code> 表示我们要为接口分配一个静态 IP 地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态 IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了 <code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet 协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的 IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4 和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>: 这一行定义了子网掩码。在这个例子中，子网掩码是 <code>255.255.255.0</code>，表示前三个字节（24 位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP 地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP 地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>: 这一行设置了默认网关。在这个例子中，我们将默认网关设置为 <code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的 IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS 服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器 <code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS 服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 <a href="http://www.baidu.com)ip/">www.baidu.com）IP</a> 地址的系统。DNS 服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向 DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP 地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-zookeeper"><a href="#安装-zookeeper" class="headerlink" title="安装 zookeeper"></a>安装 zookeeper</h2><p>在 Ubuntu 上，您可以通过以下步骤安装 Apache Zookeeper 3.5.9：</p><ol><li>下载 Apache Zookeeper 3.5.9 的二进制文件。使用以下命令下载并解压缩 Zookeeper：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz<br>tar -xzf apache-zookeeper-3.5.9-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="4"><li>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> apache-zookeeper-3.5.9-bin /opt/zookeeper-3.5.9<br></code></pre></td></tr></table></figure><ol start="5"><li>在 <code>/opt/zookeeper-3.5.9</code> 目录中创建一个名为 <code>data</code> 的文件夹，用于存储 Zookeeper 的数据：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/zookeeper-3.5.9/data<br></code></pre></td></tr></table></figure><ol start="6"><li>在 <code>/opt/zookeeper-3.5.9/data</code> 下创建 myid 文件并设置内容为 <code>1</code>，其他两台机器则为 <code>2</code> 和 <code>3</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 | sudo <span class="hljs-built_in">tee</span> /opt/zookeeper-3.5.9/data/myid<br></code></pre></td></tr></table></figure><ol start="7"><li>复制 Zookeeper 配置文件样本，并将其命名为 <code>zoo.cfg</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/zookeeper-3.5.9/conf/zoo_sample.cfg /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="8"><li>使用文本编辑器（例如 vim）编辑 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="9"><li>修改 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># The number of milliseconds of each tick</span><br>tickTime=2000<br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br>initLimit=10<br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br>syncLimit=5<br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># 设置数据存储目录</span><br>dataDir=/opt/zookeeper-3.5.9/data<br><span class="hljs-comment"># the port at which the clients will connect</span><br>clientPort=2181<br><span class="hljs-comment"># 设置集群信息</span><br>server.1=kafka1.com:2888:3888<br>server.2=kafka2.com:2888:3888<br>server.3=kafka3.com:2888:3888<br></code></pre></td></tr></table></figure><blockquote><p>在 Zookeeper 的配置文件中，<code>server.x=hostname:port1:port2</code> 这种格式的配置项是用来设置 Zookeeper 集群（集群模式下）的。其中，<code>x</code> 是服务器的 ID，<code>hostname</code> 是服务器的主机名或 IP 地址，<code>port1</code> 和 <code>port2</code> 是用于集群间通信的端口。</p><p>具体来说：</p><ul><li><p><code>port1（2888）</code>：这是服务器之间用于相互通信的端口。Zookeeper 服务器使用这个端口进行 leader 选举以及同步 follower 和 leader 之间的状态。</p></li><li><p><code>port2（3888）</code>：这个端口用于服务器之间的 leader 选举。在 Zookeeper 集群启动或者在 leader 服务器崩溃后，follower 服务器会通过这个端口进行新一轮的 leader 选举。</p></li></ul><p>这两个端口可以根据你的网络配置进行修改，但必须在所有的 Zookeeper 服务器上保持一致。</p></blockquote><ol start="10"><li>三个节点都启动 Zookeeper 服务器：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh start<br></code></pre></td></tr></table></figure><p>可以连接到 Zookeeper 的端口上（默认是 <code>2181</code>），通过发送四字命令 <code>srvr</code> 来验证 Zookeeper 是否安装正确（部署集群的话需要把所有 Zookeeper 启动）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/zookeeper-3.5.9$ telnet localhost 2181<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>srvr<br>Zookeeper version: 3.5.9-83df9301aa5c2a5d284a9940177808c01bc35cef, built on 01/06/2021 19:49 GMT<br>Latency min/avg/max: 0/0/0<br>Received: 1<br>Sent: 0<br>Connections: 1<br>Outstanding: 0<br>Zxid: 0x0<br>Mode: standalone<br>Node count: 5<br>Connection closed by foreign host.<br></code></pre></td></tr></table></figure><ol start="11"><li>要停止 Zookeeper 服务器，可以使用以下命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh stop<br></code></pre></td></tr></table></figure><h2 id="安装-Kafka"><a href="#安装-Kafka" class="headerlink" title="安装 Kafka"></a>安装 Kafka</h2><ol><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/2.7.0/kafka_2.13-2.7.0.tgz<br>tar -zxvf kafka_2.13-2.7.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-2.7.0 /opt/kafka-2.7.0<br></code></pre></td></tr></table></figure></li><li><p>创建日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/kafka-2.7.0/kafka-logs<br></code></pre></td></tr></table></figure></li><li><p>备份 Kafka 默认配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/kafka-2.7.0/config/server.properties /opt/kafka-2.7.0/config/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改 Kafka 配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure><p>主要是修改下面几个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 集群中每个 broker 的 id 必须唯一，这里分别为 1，2，3</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-2.7.0/kafka-logs</span><br><span class="hljs-comment"># 配置 Zookeeper</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">kafka1.com:2181,kafka2.com:2181,kafka3.com:2181</span><br><span class="hljs-comment"># 定义 Kafka Broker 在哪些网络地址上监听连接，下面配置表示在所有的 IP 地址上监听 9092 端口</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://:9092</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-server-start.sh -daemon /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code> 的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code> 的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>PartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 1Replicas: 1Isr: 1<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 2Replicas: 2Isr: 2<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft-Extended 论文翻译</title>
    <link href="/2023/11/18/raft/"/>
    <url>/2023/11/18/raft/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></p></blockquote><h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><p><strong>consensus</strong> vs <strong>consistency</strong></p><p>一致性（consistency）往往指分布式系统中多个副本对外呈现的数据的状态。如顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p>共识（consensus）则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。</p><p>因此，一致性描述的是<strong>结果</strong>，共识则是一种<strong>手段</strong>。</p><p>有的人会说一致性和共识实际上是一个问题的一体两面，某种程度上来说，共识方法确实可以看作是实现强一致性的一种方法。事实上在工业界有许多以共识算法作为核心组件的多副本状态机（Replicated State Machine）实现，本质上利用了共识算法保证了所有副本的操作日志具有完全相同的顺序，从而实现了副本的一致性。但是，即使是在这样的场景下，讨论一个共识算法的一致性也是不合适的，因<strong>为整个分布式系统最终的一致性并不单单取决于共识算法，共识算法只是解决了其中一个问题。</strong></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/68743917">https://zhuanlan.zhihu.com/p/68743917</a></p></blockquote><h2 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0. 摘要"></a>0. 摘要</h2><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟 multi-Paxos 作用相同，效率也相当。但是它的组织结构跟 Paxos 不同，也是因为 Raft 更简单的架构使得它更容易被理解，并且更容易在实际工程中得以实现。</p><p>为了让 Raft 更容易被理解，Raft 将共识算法的关键性因素切分成几个部分，比如：</p><ul><li>leader election（领导者选举）</li><li>log replication（日志复制）</li><li>safety（安全性）</li></ul><p>并且 Raft 实施了一种更强的共识性以便减少必须要考虑的状态（states）的数量。</p><p>用户研究表明，对于学生来说，Raft 相比于 Paxos 是更容易学习的。</p><p>Raft 还包括一个用于解决<strong>变更集群成员问题</strong>的新机制，它使用重写多数来保证安全性。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>共识算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，共识算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，Paxos [15,16] 主导了关于共识算法的讨论：大多数共识性的实现都是基于 Paxos 或受其影响，Paxos 已经成为教授学生关于共识知识的主要工具。</p><p>比较遗憾的是，尽管很多人一直在努力尝试使 Paxos 更易懂，Paxos 还是太难理解了。此外，Paxos 的架构需要复杂的改变来支持实际系统。这导致的结果就是系统开发者和学生在学生和使用 Paxos 过程中都很挣扎。</p><p>在我们自己与 Paxos 斗争之后，我们开始着手寻找一个新的共识算法，希望可以为系统开发和教学提供更好的基础。 我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以设计一个比 Paxos 更适合用于实际工程实现并且更易懂的共识算法吗？</p><p>在该算法的设计中，重要的不仅是如何让算法起作用，还要清晰地知道该算法为什么会起作用。</p><p>这项工作的结果是一个称为 Raft 的共识性算法。在设计 Raft 时，我们使用了特定的技术来提高它的可理解性，包括：</p><ul><li>分解（Raft 分离出三个关键点：leader election、log replication、safety）</li><li>减少状态空间（相比于 Paxos，Raft 降低了不确定性的程度和服务器之间的不一致）</li></ul><p>一项针对 2 所大学共 43 名学生的用户研究表明，Raft 比 Paxos 更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答 Raft 的相关问题。</p><p>Raft 在许多方面类似于现有的公式算法（尤其是 Oki、Liskov 的 Viewstamped Replication [29,22]），但它有几个新特性：</p><ul><li><strong>Strong leader（强领导性）</strong>：相比于其他算法，Raft 使用了更强的领导形式。比如，日志条目只能从 leader 流向 follower（集群中除 leader 外其他的服务器）。这在使 Raft 更易懂的同时简化了日志复制的管理流程。</li><li><strong>Leader election（领导选举）</strong>：Raft 使用随机计时器来进行领导选举。任何共识算法都需要心跳机制（heartbeats），Raft 只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li><li><strong>Membership changes（成员变更）</strong>：Raft 在更改集群中服务器集的机制中使用了一个 <strong>联合共识（joint consensus）</strong> 的方法。在联合共识（joint consensus）下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ul><p>我们认为 Raft 跟 Paxos 以及其他共识算法相比是更优的，这不仅体现在教学方面，还体现在工程实现方面。</p><ul><li>它比其他算法更简单且更易于理解</li><li>它被描述得十分详细足以满足实际系统的需要</li><li>它有多个开源实现，并被多家公司使用</li><li>它的安全性已被正式规定和验证</li><li>它的效率与其他算法相当</li></ul><p>本文剩余部分：</p><table><thead><tr><th>所在节</th><th>内容</th></tr></thead><tbody><tr><td>第 2 节</td><td>复制状态机问题（replicated state machine problem）</td></tr><tr><td>第 3 节</td><td>Paxos 的优缺点</td></tr><tr><td>第 4 节</td><td>实现 Raft 易理解性的措施</td></tr><tr><td>第 5-8 节</td><td>Raft 共识性算法详细阐述</td></tr><tr><td>第 9 节</td><td>评估 Raft</td></tr><tr><td>第 10 节</td><td>其他相关工作</td></tr></tbody></table><h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2. 复制状态机"></a>2. 复制状态机</h2><p>共识算法一般都是在复制状态机 [37] 的背景下实现的。在这种方法下，一组服务器在的状态机计算相同状态的相同副本，即使某些服务器崩溃，它们也可以继续运行。</p><p>复制状态机是用来解决分布式系统中的各种容错问题。比如说，具有单个 leader 的大规模的系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33] ，他们通常都使用单独的复制状态机来管理 leader election 和保存 leader 崩溃后重新选举所需的配置信息。像 Chubby [2] 和 ZooKeeper [11] 都是复制状态机。</p><p>复制状态机通常都是使用日志复制（log replication）来实现。如图1：每个服务器都保存着一份拥有一系列命令的日志，然后服务器上的状态机会按顺序执行日志中的命令。每一份日志中命令相同并且顺序也相同，因此每个状态机可以处理相同的命令序列。所以状态机是可确定的，每个状态机都执行相同的状态和相同的输出序列。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsmihlh9ptj322u0nsgpj.jpg" alt="image-20210719200404010"></p><p>共识算法的主要工作就是保证复制日志（replicated log）的一致性。每台服务器上的共识模块接收来自客户端的命令，并将这些命令添加到其日志当中。它（指共识模块）与其他服务器上的共识模块进行通信，以确保每台服务器上最终以相同的顺序包含相同的命令，即使部分服务器崩溃了，这个条件也可以满足。一旦命令被正确复制，每台服务器上的状态机就会按日志顺序处理它们，并将输出返回给客户端。这样就形成了高可用的复制状态机。</p><p>适用于实际系统的共识算法通常都包含以下几点特征：</p><ul><li><p>它们确保在所有非拜占庭错误下的安全性，也就是从不返回一个错误的结果。（即使是网络延迟、分区、数据包丢失、数据包重复和数据包乱序）</p><blockquote><p><strong><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭错误</a>：</strong></p><p>出现故障（crash 或 fail-stop，即不响应）但不会伪造信息的情况称为“非拜占庭错误”。</p><p>伪造信息恶意响应的情况称为“拜占庭错误”，对应节点称为拜占庭节点。</p></blockquote></li><li><p>只要任何大多数（过半）服务器是可运行的，并且可以互相通信和与客户端通信，那么共识算法就可用。假设服务器崩溃了，一小段时间后，它们很可能会根据已经稳定存储的状态来进行恢复，并重新加入集群。</p></li><li><p>它们在保证日志一致性上不依赖于时序：错误的时钟和极端消息延迟在最坏的情况下会产生影响可用性的一系列问题。</p></li><li><p>在通常情况下，只要集群中大部分（过半）服务器已经响应了单轮远程过程调用（RPC），命令就可以被视为完成。少数（一半以下）慢服务器不会影响整个系统的性能。</p></li></ul><h2 id="3-Paxos-存在的问题"><a href="#3-Paxos-存在的问题" class="headerlink" title="3. Paxos 存在的问题"></a>3. Paxos 存在的问题</h2><p>在过去的十年间，Leslie Lamport 的 Paxos 协议 [15] 几乎成为共识性（consensus）的同义词。它是课堂上被教授最多的共识协议，大多数共识性的实现也是以它为起点。Paxos 首先定义了能在单个决策问题（例如单个复制日志条目）上达成共识的协议。我们将这个子集称为 <em>signle-degree Paxos</em>。然后 Paxos 组合该协议的多个实例去实现一系列决策，比如日志（<em>mutil-Paxos</em>）。Paxos 保证了安全性和活性，它也支持改变集群中的成员，它的安全性也已经被论证了，并且大多数情况下都是高效的。</p><p>美中不足的是，Paxos 有两个严重的缺点：</p><ol><li><p><strong>Paxos 非常难理解</strong></p><p>众所周知，Paxos 非常晦涩难懂，除非下了很大的功夫，很少有人能够成功理解它。因此，尽管目前已经有几个尝试希望将 Paxos [16,20,21]  解释得通俗易懂一些，而且这些解释都集中在 <code>single-decree Paxos</code>，但是它们还是很难懂。</p><p>在对 NSDI 2012 参会者的非正式调查中，我们发现很少人会喜欢 Paxos，即使是经验丰富的研究人员。我们自己也一直在跟 Paxos 作斗争，我们也无法完全理解整个  Paxos 协议，直到阅读了几个更简单的描述和自己设计了替代 Paxos 的协议，我们才对 Paxos 有了比较深刻的理解。但这个过程，花了将近一年。</p><p>我们推测 Paxos 这么晦涩难懂，主要是因为作者选择了 <code>Single-decree Paxos</code> 来作为基础。<code>Single-decree Paxso</code> 非常搞人：它分为两个阶段，但是并没有对这两个阶段进行简单直观的说明，而且这两个阶段也不能分开了单独理解，所以使用者将就很难理解为什么该算法能起作用。<code>Multi-Paxos</code> 的合成规则又增加了许多复杂性。我们相信，对多个决定（日志，并非单个日志条目）达成共识的总体问题可以用其他更直接和更明显的方式进行分解。</p></li><li><p><strong>Paxos 没有为实际实现提供一个良好的基础</strong></p><p>其中一个原因是没有广泛认同的针对 <code>Multi-Paxos</code> 的算法。Lamport 的描述主要是针对 <code>signle-decree Paxos</code> 的，他描述了针对 <code>multi-Paxos</code> 的可能方法，但缺少了很多细节。</p><p>目前已经有人在尝试具体化和优化 Paxos，比如 [26]，[39] 和 [13]，但是这些尝试都互不相同并且它们跟 Lamport 描述的也不尽相同。虽然像 Chubby [4] 这样的系统已经实现了类 Paxos（Paxos-like）算法，但是他们并没有透露出很多的实现细节。</p></li></ol><p>此外，Paxos 的架构对于构建实际系统来说其实是一个糟糕的设计，这是 <code>single-decree Paxos</code> 分解的另一个结果。举个例子，这对于独立选择地日志条目的集合，然后再将它们合并到顺序日志当中没有任何好处，这只会增加复杂性。围绕日志来设计系统是更加简单和高效的方法，其中新条目按受约束的顺序依次附加。另外一个问题是 Paxos 在其核心使用了<strong>对称对等方法</strong>（尽管它最终表明了这会被用作一种性能优化的弱领导模式）。这在只有一个决策的情况下是有意义的，但是尽管如此，还是很少有实际系统采用了这种方法。如果有一系列的决策需要制定，更简单和更快速的方法应该是首先选择一个 leader，然后由 leader 去协调这些决策。</p><p>因此，按照 Paxos 来实现的实际系统往往跟 Paxos 相差很大。几乎所有的实现都是从 Paxos 开始，然后在实现的过程中发现了一系列的难题，在解决难题的过程中，开发出了跟 Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos 本身的晦涩难懂又使得问题变得更加严重。Paxos 公式可能是证明其正确性的一个很好的公式，但真正的实现与 Paxos 又相差很大，这证明了它其实没有什么价值。下面来自 Chubby 作者的评论非常典型：</p><blockquote><p>在 Paxos 算法描述和现实实现系统之间有着巨大的鸿沟… （如果一直按照 Paxos 算法走下去），最终的系统往往会建立在一个还未被证明的协议之上。</p></blockquote><p>综合上述问题，我们觉得 Paxos 在教学端和系统构建端都没有提供一个良好的基础。考虑到共识性在大规模软件系统中的重要性，我们决定去尝试一下看看能不能设计一个替代 Paxos 并且具有更好特性的共识算法。Raft 就是这次实验的结果。</p><h2 id="4-为可理解性而设计"><a href="#4-为可理解性而设计" class="headerlink" title="4. 为可理解性而设计"></a>4. 为可理解性而设计</h2><p>在设计 Raft 算法过程中我们有几个目标：</p><ul><li>它必须为系统构建提供一个完整且实际的基础，这样才能大大减少开发者的工作</li><li>它必须在任何情况下都是安全的并且在典型的应用条件下是可用的，并且在正常情况下是高效的</li></ul><p>但是我们最重要的目标，也是我们遇到的最大的挑战：</p><ul><li>它必须具有易理解性，它必须保证能够被大多数人轻松地理解。而且它必须能够让人形成直观的认识，这样系统构建者才能在实现过程中对它进行不可避免的拓展。</li></ul><p>在设计 Raft 算法的过程中，很多情况下我们需要在多个备选方案下做出抉择。在这种情况下，我们往往会基于可理解性来进行抉择：</p><ul><li>解释各个备选方案的难度有多大？例如，它的状态空间有多复杂？它是否具有难以理解的含义？</li><li>对于一个读者来说，完成理解这个方案和方案中的各种含义是否简单？</li></ul><p>我们意识到这一的分析具有高度的主观性。所以我们采取了两种通用的措施来解决这个问题。</p><ol><li>第一个措施就是众所周知的问题分解：只要有可能，我们就将问题划分成几个相对独立地解决、解释和理解的子问题。例如，Raft 算法被我们划分成 leader 选举、日志复制、安全性和成员变更几个部分。</li><li>第二个措施是通过减少状态的数量来简化状态空间，尽可能地使系统变得更加连贯和尽可能地消除不确定性。很明显的一个例子就是，所有的日志都是不允许有空挡的，并且 Raft 限制了日志之间可能不一样的方式。尽管在大多数情况下我们都极力去消除不确定性，但是在某些情况下不确定性却可以提高可理解性。一个重要的例子就是随机化方法，它们虽然引入了不确定性，但是它们往往能够通过以类似的方式处理所有可能的选择来减少状态空间（随便选，没关系）。所有我们使用了随机化来简化 Raft 中的 leader election 算法。</li></ol><h2 id="5-Raft-共识算法"><a href="#5-Raft-共识算法" class="headerlink" title="5. Raft 共识算法"></a>5. Raft 共识算法</h2><p>Raft 是一种用来管理第 2 节中提到的复制日志（replicated log）的算法。图 2 是该算法的浓缩，可以作为参考。图 3 列举了该算法的一些关键特性。这两张图中的内容将会在后面的各个章节中逐一介绍。</p><p>Raft 在实现共识算法的过程中，首先选举一个 distinguished leader，然后由该 leader 全权负责复制日志的一致性。Leader 从客户端接收日志条目，然后将这些日志条目复制给其他服务器，并且在保证安全性的情况下通知其他服务器将日志条目应用到他们的状态机中。拥有一个 leader 大大简化了对复制日志的管理流程。例如，leader 可以在不跟其他服务器商议的情况下决定新的日志条目应该存放在日志的什么位置，并且数据都是从 leader 流向其他服务器。当然了，一个 leader 可能会崩溃，也可能与其他服务器断开连接，那么这个时候，Raft 就会选举出一个新的 leader 出来。</p><p>通过选举一个 leader 的方式，Raft 将共识问题分解成三个独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p><ul><li><p><strong>Leader election（领导选举）</strong></p><p>一个 leader 倒下之后，一定会有一个新的 leader 站起来。</p></li><li><p><strong>Log replication（日志复制）</strong></p><p>leader 必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</p></li><li><p><strong>Safety（安全性）</strong></p><p>Raft 中安全性的关键是图 3 中状态机的安全性：只要有任何服务器节点将一个特定的日志条目应用到它的状态机中，那么其他服务器节点就不能在同一个日志索引位置上存储另外一条不同的指令。第 5.4 节将会描述 Raft 如何保证这种特性，而且该解决方案在 5.2 节描述的选举机制上还增加了额外的限制。</p></li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsar1v5rklj32300pc4bj.jpg" alt="image-20210709155333989"></p><p>在展示了 Raft 共识算法后，本章节将讨论可用性的一些问题以及时序在系统中的所用。</p><h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群中包含若干个服务器节点，<font color="green"><strong>5 个一个比较典型的数字，5 个服务器的集群可以容忍 2 个节点的失效</strong></font>。在任何一个时刻，集群中的每一个节点都只可能是以下是三种身份之一：</p><ul><li>leader：它会处理所有来自客户端的请求（如果一个客户端和 follower 通信，follower 会将请求重定向到 leader 上）</li><li>follower：它们被动的：它们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求</li><li>candidate：这是用来选举一个新的 leader 的时候出现的一种临时状态，这将在第 5.2 节中详细描述</li></ul><p>在正常情况下，集群中只有一个 leader，然后剩下的节点都是 follower。图 4 展示了这些状态和它们之间的转换关系，这些转换关系将会在接下来进行讨论。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsap8d6ijjj322s0l47g5.jpg" alt="image-20210709145034498"></p><p>如图 5 所示，Raft 将时间划分成任意长度的任期（term）。每一段任期从一次选举开始，在这个时候会有一个或者多个 candidate 尝试去成为 leader。如果某一个 candidate 赢得了选举，那么它就会在任期剩下的时间里承担一个 leader 的角色。在某些情况下，一次选举无法选出 leader，这个时候这个任期会以没有 leader 而结束。同时一个新的任期（包含一次新的选举）会很快重新开始。这是因为 Raft 会保证在任意一个任期内，至多有一个 leader。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsapcmhhi4j31ym0ig78s.jpg" alt="image-20210709145441879"></p><p>集群中不同的服务器观察到的任期转换的次数也许是不同的，在某些情况下，一个节点可能没有观察到 leader 选举过程甚至是整个任期过程。</p><p>任期在 Raft 中还扮演着一个逻辑时钟（logical clock）的角色，这使得服务器可以发现一些过期的信息，比如过时的 leader。</p><p>每一个节点都存储着一个当前任期号（current term number），该任期号会随着时间<strong>单调递增</strong>。节点之间通信的时候会交换当前任期号，如果一个节点的当前任期号比其他节点小，那么它就将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它就会立刻回到 follower 状态。如果一个节点接收了一个带着过期的任期号的请求，那么它会拒绝这次请求。</p><p>Raft 算法中服务器节点之间采用 RPC 进行通信，一般的共识算法都只需要两种类型的 RPC。</p><ul><li><strong>RequestVote RPCs（请求投票）</strong>：由 candidate 在选举过程中发出（5.2 节中描述）</li><li><strong>AppendEntries RPCs（追加条目）</strong>：由 leader 发出，用来做日志复制和提供心跳机制（5.3 节中描述）。</li></ul><p>在第 7 节中为了在节点之间传输快照（snapshot）增加了第三种 RPC。当节点没有及时的收到 RPC 的响应时，会进行重试，而且节点之间都是以并行（parallel）的方式发送 RPC 请求，以此来获得最佳的性能。</p><h3 id="5-2-Leader-election"><a href="#5-2-Leader-election" class="headerlink" title="5.2 Leader election"></a>5.2 Leader election</h3><p>Raft 采用一种心跳机制来触发 leader 选举。当服务器启动的时候，他们都会称为 follower。一个服务器节点只要从 candidate 或者 leader 那接收到有效的 RPC 就一直保持 follower 的状态。Leader 会周期性地向所有的 follower 发起心跳来维持自己的 leader 地位，所谓心跳，就是不包含日志条目的 AppendEntries RPC。如果一个 follower 在一段时间内没有收到任何信息（这段时间我们称为<strong>选举超时 election timeout</strong>），那么它就会假定目前集群中没有一个可用的 leader，然后开启一次选举来选择一个新的 leader。</p><p>开始进行选举的时候，一个 follower 会自增当前任期号然后切换为 candidate 状态。然后它会给自己投票，同时以并行的方式发送一个 RequestVote RPCs 给集群中的其他服务器节点（企图得到它们的投票）。一个 candidate 会一直保持当前状态直到以下的三件事之一发生（这些情况都会在下面的章节里分别讨论）：</p><ul><li>它赢得选举，成为了 leader</li><li>其他节点赢得了选择，那么它会变成 follower</li><li>一段时间之后没有任何节点在选举中胜出</li></ul><p>当一个 candidate 获取集群中过半服务器节点针对同一任期的投票时，它就赢得了这次选举并成为新的 leader。对于同一个任期，每一个服务器节点会按照 <strong>先来先服务原则（first-come-first-served）</strong> 只投给一个 candidate（在5.4 节会在投票上增加额外的限制）。这种要求获得过半投票才能成为 leader 的规则确保了最多只有一个 candidate 赢得此次选举（图 3 中的选举安全性）。只要有一个 candidate 赢得选举，它就会成为 leader。然后它就会向集群中其他节点发送心跳消息来确定自己的地位并阻止新的选举。</p><p>一个 candidate 在等待其他节点给它投票的时候，它也有可能接收到另外一个自称为 leader 的节点给它发过来的 AppendEntries RPC。</p><ul><li>如果这个 leader 的任期号（这个任期号会在这次 RPC 中携带着）不小于这个 candidate 的当前任期号，那么这个 candidate 就会觉得这个 leader 是合法的，然后将自己转变为 follower 状态。</li><li>如果这个 leader 的任期号小于这个 candidate 的当前任期号，那么这个 candidate 就会拒绝这次 RPC，然后继续保持 candidate 状态。</li></ul><p>第三种可能的结果是 candidate 既没有赢得选举也没有输。可以设想一下这么一个情况。所有的 follower 同时变成  candidate，然后它们都将票投给自己，那这样就没有 candidate 能得到超过半数的投票了，投票无果。当这种情况发生的时候，每个 candidate 都会进行一次超时响应（time out），然后通过自增任期号来开启一轮新的选举，并启动另一轮的 RequestVote RPCs。然而，如果没有额外的措施，这种无结果的投票可能会无限重复下去。</p><p>为了解决上述问题，Raft 采用 <strong>随机选举超时时间（randomized election timeouts）</strong> 来确保很少发生无果的投票，并且就算发生了也能很快地解决。<strong>为了防止选票一开始就被瓜分，选举超时时间是从一个固定的区间（比如，150-300ms）中随机选择。这样可以把服务器分散开来以确保在大多数情况下会只有一个服务器率先结束超时，那么这个时候，它就可以赢得选举并在其他服务器结束超时之前发送心跳</strong>（译者注：乘虚而入，不讲武德）。</p><p>同样的机制也可以被用来解决选票被瓜分（split votes）的情况。每个 candidate 在开始一轮选举之前会重置一个随机选举超时时间，然后一直等待直到结束超时状态。这样减少了在一次投票无果后再一次投票无果的可能性。9.3 节展示了该方案能够快速地选出一个 leader。</p><p>选举的例子可以很好地展现可理解性是如何指导我们在多种备选设计方案中做出抉择的。在一开始，我们本打算使用一种等级系统（rank system）：每一个 candidate 被赋予一个一次的等级（rank），如果一个 candidate 发现另外一个 candidate 有着更高的登记，那么它就会返回 follower 状态，这样可以使高等级的 candidate 更加容易地赢得下一轮选举。但是我们发现这种方法在可用性方面会有一些小问题： <strong>如果等级较高的服务器崩溃了，那么等级较低的服务器可能需要进入超时状态，然后重新成为一个 candidate。如果这种操作出现得太快，那么它可能会重启进程去开启一轮新的选举。</strong> 经过我们对该算法做出了多次的调整，我们最终还是认为随机重试的方法更加通俗易懂。</p><h3 id="5-3-Log-replication"><a href="#5-3-Log-replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h3><p>Leader 一旦被选举出来，它就要开始为客户端的请求提供服务了。每一个客户端请求都包含一条将被复制状态机执行的命令。leader 会以一个新条目的方式将该命令追加到自己的日志中，并且以同步的方式向集群中的其他节点发起 AppendEntires RPCs，让它们复制该条目。当条目被安全地复制（何为安全复制，后面会介绍）之后，leader 会将该条目应用到自己的状态机中，状态机执行该指令，然后把执行的结果返回给客户端。如果 follower 崩溃了或者运行缓慢，或者网络丢包，leader 会不断地重试 AppendEntiries RPCs（即使已经对客户端作出了响应）直到所有的 follower 都成功存储了所有的日志条目。</p><p>日志以图 6 展示的方式组织着。每条日志条目都存储着一条状态机指令和 leader 收到该指定时的任期号。日志条目中的任期号可以用来检测多个日志副本之间是否不一致，以此来保证图 3 中的某些性质。每个日志条目还有一个整数索引值来表明它在日志中的位置。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsasp7ss8gj32220ssjy9.jpg" alt="image-20210709165036190"></p><p>那么问题就来了，<strong>leader 什么时候会觉得把日志条目应用到状态机是安全的呢？</strong> 这种日志条目被称为已提交的日志条目。Raft 保证这种已提交的日志条目都是持久化的并且最终都会被所有可用的状态机执行。 <strong>一旦创建该日志条目的 leader 将它复制到过半的节点上时（比如图 6 中的条目 7），该日志条目就会被提交。</strong> 同时，leader 日志中该日志条目之前的所有日志条目也都会被提交，包括由之前的其他 leader 创建的日志条目。5.4 节会讨论在 leader 变更之后应用该规则的一些细节，并证明这种提交的规则是安全的。leader 会追踪它所知道的要提交的最高索引，并将该索引包含在未来的 AppendEntries RPC 中（包括心跳），以便其他的节点可以发现这个索引。一旦一个 follower 知道了一个日志条目被提交了。它就会将该日志条目按日志顺序应用到自己的状态机中。</p><p>我们设计 Raft 日志机制来使得不同节点上的日志之间可以保持高水平的一致性。这么做不仅简化了系统的行为也使得系统更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 会一直维护着以下的特性，这些特性也同时构成了图 3 中的日志匹配特性（Log Matching Property）：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期值，那么它们就存储着相同的命令</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么他们之前的所有日志条目也都相同</li></ul><p>第一条特性源于这样一个事实，在给定的一个任期值和给定的一个日志索引中，一个 leader 最多创建一个日志条目，而且日志条目永远不会改变它们在日志中的位置。</p><p>第二条特性是由 AppendEntries RPC 执行的一个简单的一致性检查所保证的。当 leader 发送一个 AppendEntries RPC 的时候，leader 会将前一个日志条目的索引位置和任期号包含在里面（紧邻最新的日志条目）。如果一个 follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性（Log Matching Property）的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，当 AppendEntries RPC 返回成功时，leader 就知道 follower 的日志一定和自己相同（从第一个日志条目到最新条目）。</p><p>正常操作期间，leader 和 follower 的日志都是保持一致的，所以 AppendEntries 的一致性检查从来不会失败。但是，如果 leader 崩溃了，那么就有可能会造成日志处于不一致的状态，比如说老的 leader 可能还没有完全复制它日志中的所有条目它就崩溃了。这些不一致的情况会在一系列的 leader 和 follower 崩溃的情况下加剧。图 7 解释了什么情况下 follower 的日志可能和新的 leader 的日志不同。follower 可能会确实一些在新 leader 中有的日志条目，也有可能拥有一些新的 leader 没有的日志条目，或者同时存在。缺失或多出日志条目的情况有可能会涉及到多个任期。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse5vxj5sfj31se0u017c.jpg" alt="image-20210712144330139"></p><p>在 Raft 算法中，leader 通过强制 follower 复制 leader 日志来解决日志不一致的问题。也就是说，follower 中跟 leader 冲突的日志条目会被 leader 的日志条目所覆盖。5.4 节会证明通过增加一个限制，这种方式就可以保证安全性。</p><p>为了使 follower 的日志跟自己（leader）一致，leader 必须找到两者达成一致的最大的日志条目索引，删除 follower 日志中从那个索引之后的所有日志条目，并且将自己那个索引之后的所有日志条目发送给 follower。所有的这些操作都发生在 AppendEntries RPCs 的一致性检查的回复中。leader 维护着一个针对每一个 follower 的 <strong>nextIndex</strong>，这个 nextIndex 代表的就是 leader 要发送给 follower 的下一个日志条目的索引。<strong>当选出一个新的 leader 时，该 leader 将所有的 nextIndex 的值都初始化为自己最后一个日志条目的 index 加 1（图7 中的 11）</strong>。如果一个 follower 的日志跟 leader 的是不一致的，那么下一次的 AppendEntries RPC 的一致性检查就会失败。<strong>AppendEntries RPC 在被 follower 拒绝之后，leader 对 nextIndex 进行减 1，然后重试 AppendEntries RPC。最终 nextIndex 会在某个位置满足 leader 和 follower 在该位置及之前的日志是一致的，此时，AppendEntries RPC 就会成功，将 follower 跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（需要的话）</strong>。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 的一致了，并且在该任期接下来的时间里都保持一致。</p><blockquote><p>如果需要的话，下面的协议可以用来优化被拒绝的 AppendEntries RPCs 的个数。</p><p>比如说，当拒绝一个 AppendEntries RPC 的时候，follower 可以包含冲突条目的任期号和自己存储的那个任期的第一个 index。借助这些信息，leader 可以跳过那个任期内所有的日志条目来减少 indexIndex。这样就变成了每个有冲突日志条目的任期只需要一个 AppendEntries RPC，而不是每一个日志条目都需要一次 AppendEntires RPC。</p><p>在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p></blockquote><p>通过上述机制，leader 在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。leader 只需进行正常的操作，然后日志就能在回复  AppendEntries RPC 一致性检查的时候自动趋于一致。leader 从来不会重写或者删除自己的日志条目（图3 中的 Leader Append-Only 属性）。</p><p>上述这种日志复制机制展现了第 2 节中描述的 Raft 算法的共识特性：只要过半的节点能正常运行，Raft 就能接受、复制并处理新的日志条目。在通常情况下，一个新的条目可以在一轮 RPC 中被复制给集群中过半的节点，并且单个运行缓慢的 follower 并不会影响整个集群的性能。</p><blockquote><p>译者注：<strong>总结</strong></p><p>Leader 收到 Client 的写请求，向所有 Follower 发起一个日志同步请求，得到集群内过半节点（包括 Leader 自己）的响应，就推进 commitIndex，然后 apply 日志到状态机，再推进 applyIndex，返回 Client 成功。</p><p>状态机同步分为两轮 RPC 广播：</p><ul><li>第一轮：同步日志 AppendEntries，得到过半节点回复，Leader 状态机推进，返回 Client 成功。</li><li>第二轮：在下一次的 AppendEntries 中附带上一次的 commitIndex，Follower 收到后，apply 日志条目到各自的状态机。</li></ul></blockquote><h3 id="5-4-Safety"><a href="#5-4-Safety" class="headerlink" title="5.4 Safety"></a>5.4 Safety</h3><p>前面的章节描述了 Raft 如何做 Leader Election 和 Log Replication。然而，到目前为止所讨论的机制并不能充分地保证每一个状态机会按相同的顺序执行相同的指令。比如说，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目，然后这个 follower 可能被选举为新的 leader 并且用新的日志条目去覆盖这些日志条目。这样就会造成不同的状态机执行不同的指令的情况。</p><p>本节通过对 Leader Election 增加一个限制来完善 Raft 算法。这个限制保证了对于给定的任意任期号，该任期号对应的 leader 都包含了之前各个任期所有被提交的日志条目（图3 中的 Leader Completeness 性质）。有了这个限制，我们也可以使日志提交规则更加清晰。最后，我们会展示对于 Leader Completeness 性质的简要证明并且说该性质是如何保证状态机执行正确的行为的。</p><h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于 leader 的共识算法中，leader 最终都必须存储所有已经提交的日志条目。在某些共识算法中，例如 Viewstamped Replication [22]，即使一个节点它一开始并没有包含所有已经提交的日志条目，它也有可能被选举为 leader。这些算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的 leader，这个机制要么发生在选举阶段，要么在选举完成之后很快进行。比较遗憾的是，这种方法会增加许多额外的机制，使得算法复杂性大大增加。Raft 使用了一种更加简单的方法，它可以保证新 leader 在当选时就包含了之前所有任期中已经提交的日志条目，根本就不需要再传送这些日志条目给新的 leader。这就意味着<strong>日志条目的传送只有一个方向，那就是从 leader 到 follower，leader 从来不会覆盖本地日志中已有的日志。</strong></p><p>Raft 采用投票的方式来保证一个 candidate 只有拥有之前所有任期中已经提交的日志条目之后，才有可能赢得选举。一个 candidate 如果想要被选为 leader，那它就必须跟集群中超过半数的节点进行通信，这就意味这些节点中至少一个包含了所有已经提交的日志条目。如果 candidate 的日志至少跟过半的服务器节点一样新，那么它就一定包含了所有以及提交的日志条目，一旦有投票者自己的日志比 candidate 的还新，那么这个投票者就会拒绝该投票，该 candidate 也就不会赢得选举。</p><blockquote><p>所谓 “<strong>新</strong>” ：</p><p>Raft 通过比较两份日志中的最后一条日志条目的索引和任期号来定义谁的日志更新。</p><ul><li>如果两份日志最后条目的任期号不同，那么任期号大的日志更新</li><li>如果两份日志最后条目的任期号相同，那么谁的日志更长，谁就更新</li></ul></blockquote><h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><blockquote><p>译者注：注意！这一节「提交之前任期内的日志条目」这种操作 Raft 的不允许的！本小节只是用来举一种错误情况！</p></blockquote><p>如 5.3 节中提到的那样，一旦当前任期内的某个日志条目以及存储到过半的服务器节点上，leader 就知道该日志可以被提交了。如果这个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会尝试完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到了过半的服务器节点上了，新任期内的 leader 也无法立即断定该日志条目已经被提交了。图 8 展示了一种情况：一个已经被存储到过半节点的老日志条目，仍然有可能会被未来的 leader 覆盖掉。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse88t4iicj31wc0u0ts1.jpg" alt="image-20210712160506841"></p><blockquote><p>译者注：<strong>对图 8 的理解的补充</strong>。</p><p><font color="orange">参考：</font></p><ul><li><a href="https://zhuanlan.zhihu.com/p/369989974">知乎</a></li></ul><p><font color="orange">核心：</font></p><ul><li><strong>图 8 用来说明为什么 leader 不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</strong></li></ul><p><font color="orange">分析：</font></p><ol><li>先按错误的情况，也就是 leader 提交之前任期的日志，那么上述的流程：<ol><li>(a) S1 是任期 2 的 leader，日志已经复制给了 S2，此时还没过半；</li><li>(b) S1 崩溃，S5 获得了 S3、S4、S5 的投票成为  leader，然后写了一个日志条目（index&#x3D;2，term&#x3D;3）；</li><li>(c) S5 刚写完日志，还没来得及复制，就崩溃了，此时 S1 和 S2 都可能当选，加入 S1 当选（currentTerm&#x3D;4），此刻还没有新的请求进来，S1 将日志条目（index&#x3D;2，term&#x3D;2）复制给了 S3，多数派达成，S1 提交了这个日志条目（index&#x3D;2，term&#x3D;2）， <strong>注意，该日志不是当前任期内的日志，我们在讨论错误的情况！</strong> 然后请求进来，S1 写日志条目（index&#x3D;3，term&#x3D;4），然后 S1 崩溃。</li><li>情况一：(d) S5 重启，因为 S5 最后的日志条目的任期号比 S2、S3 大，所以 S5 可以赢得选举（currentTerm&#x3D;5），S5 将日志条目（index&#x3D;2，item&#x3D;3）复制给其他所有节点并提交， <strong>此时 index&#x3D;2 的日志条目被提交了两次！一次 term&#x3D;2，一次term&#x3D;3，这是不被允许的，因为已经提交的日志条目是不能被覆盖的！</strong> ✖️</li><li>情况二：(e) S1 在崩溃之前将自己的日志条目（index&#x3D;3，term&#x3D;4）复制到了过半节点上，这种情况下，S5 不可能选举成功。这是 S1 不发生故障，这是正确复制的情况。✔️</li></ol></li></ol><p>所以 <strong>「leader 可以提交之前任期的日志」</strong> 这种操作是不允许的，我们需要加上约束： <strong>「leader 只能提交自己任期的日志」</strong> 。</p><ol start="2"><li><p>加了约束之后，前面的 (a) 和 (b) 没有改变，从 (c) 开始：</p><ol><li><p>(c) S1 还是将日志条目（index&#x3D;2，term&#x3D;2）复制给其他节点，它复制给了 S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm&#x3D;4，所以 S1 还是不能提交该日志条目</strong>。如果 S1 将日志条目（index&#x3D;3，term&#x3D;4）也复制给了过半的节点，S1 是可以提交该日志条目的，那么这个时候，前面的日志条目（index&#x3D;2，term&#x3D;2）也会被间接提交，这就是 (e) 所展示的情况。</p></li><li><p>(d) S1 还是将日志条目（index&#x3D;2，term&#x3D;2）复制给其他节点，它复制给了 S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm&#x3D;4，所以 S1 还是不能提交该日志条目</strong>。但是这个时候，S1 只是日志条目（index&#x3D;3，term&#x3D;4）写入自己的日志，还没来得及复制就崩溃了。然后 S5 重启并赢得了选举（currentTerm&#x3D;5），然后将日志条目（index&#x3D;2，term&#x3D;3）复制给其他所有节点，现在 index&#x3D;2 的日志条目是没有提交过的，S5 能提交该日志吗？</p><p><strong>不能！因为 leader 不能提交之前任期的日志！只有等新的请求进来，超过半数节点复制了 1-3-5 之后，term&#x3D;3 的日志才能跟着 term&#x3D;5 的日志一起被提交。</strong></p></li></ol></li></ol><p><font color="orange">延伸：</font></p><p>加了上述约束后，就不会出现同一个 index 上的日志条目被重复提交的情况了，但是这又多出了另外一个问题了：<strong>如果一直没有新的请求进来，那么日志条目（index&#x3D;2，term&#x3D;3）岂不是就一直不能提交？那不就阻塞了吗？</strong></p><p>这里如果是 kv 数据库，问题就很明显了。假设 (c) 或 (d) 中的日志条目（index&#x3D;2）里的 Command 是 <code>Set(&quot;k&quot;, &quot;1&quot;)</code>，S5 当选 leader 后，客户端来查询 <code>Get(&quot;k&quot;)</code>，leader 查到日志有记录但又不能回复 1 给客户端（因为按照约束这条日志未提交），线性一致性要求不能返回陈旧的数据，leader 迫切地需要知道这条日志到底能不能提交。</p><p>所以 Raft 论文提高了引入 <strong>no-op 日志</strong>来解决这个问题，这个在 etcd 中有实现。</p><p><font color="orange">no-op 日志：</font></p><p>no-op 日志即只有 index 和 term 信息，command 信息为空。也是要写到磁盘存储的。</p><p>具体流程是<strong>在 leader 刚选举成功的时候，立即追加一条 no-op 日志，并立即复制到其它节点，no-op 日志一经提交，leader 前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了 no-op 日志之后，Leader 就能快速响应客户端查询了。</strong></p><p>本质上，no-op 日志使 leader 隐式地快速提交之前任期未提交的日志，确认当前 <code>commitIndex</code>，这样系统才会快速对外正常工作。</p></blockquote><p>为了解决图 8 中描述的问题，Raft 永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader 当期内的日志条目才通过计算副本数目的方式来提交。一旦当前任期内的某个日志条目以这种方式被提交（如图 8 中的 e），那么由于日志匹配特性（Log Matching），之前的所有日志条目也会被间接地提交。在某些情况下，leader 可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经被存储到每一个节点上了）。但是 Raft 为了简化问题，采取了上述描述的更加保守的方法。</p><p>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的共识算法中，如果一个新的 leader 要重新复制之前任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出日志条目，因为它们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p><h4 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h4><p>给出了完整的 Raft 算法后，我们现在可以更严格地来论证 leader 完整性特性（Leader Completeness Property）（这一讨论基于 9.2 节的安全性证明）。我们先假设 Leader Completeness Property 是不满足的，然后再推出矛盾来。</p><p><strong>假设：</strong></p><p>假设任期 T 的 leader<sub>T</sub> 在任期内提交了一个日志条目，但是该日志条目没有存在未来某些任期的 leader 中，假设 U 是大于 T 的没有存储该日志条目的最小任期号，处在任期 U 的 leader 称为 leader<sub>U</sub>。</p><p><strong>论证：</strong></p><ol><li><p>因为 leader 从来不删除或重写自己的日志条目，所以如果一个已提交的日志要做到不存在未来的 leader<sub>U</sub> 中的话，那么它只可能在 leader<sub>U</sub> 选举的过程中被丢失。</p></li><li><p>leader<sub>T</sub> 将该日志复制给了集群中过半的节点，leader<sub>U</sub> 从集群中过半的节点得到了投票。因此，至少有一个节点（这里称它为 voter）同时接收了来自 leader<sub>T</sub> 的日志条目并且给 leader<sub>U</sub> 投票了。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsfipd3u1tj322c0j2wju.jpg" alt="image-20210713185232381"></p></li><li><p>voter 必然在给 leader<sub>U</sub>  投票之前就已经接收了这个已经提交的日志条目了。否则，它就会拒绝来自 leader<sub>T</sub> 的 AppendEntries RPC 请求，因为如果它在给 leader<sub>U</sub> 投票之后再接收条目的话，那么它的当前任期号会比 T 大。</p><blockquote><p>译者注：因为要举行 Leader election 的话需要开一轮新的任期，这个时候前一轮任期已经结束了。我们这里假设了 T &lt; U，上述所说的已提交日志条目是在任期 T 中的，如果 voter 先投票的话，那么就说明它已经进入了任期 U 了，而 U &gt; T，voter 是不可能接受 leader<sub>T</sub> 的 AppendEntries 请求的。</p></blockquote></li><li><p>而且，voter 在给 leader<sub>U</sub> 投票的时候，它依旧保有该日志条目，因为任何 U、T 之间的 leader 都包含该日志条目（因为我们前面假设了 U 是大于 T 的没有存储该日志条目的最小任期号），而且 leader 从来不会删除条目，并且 follower 只有再跟 leader 冲突的时候才会删除条目。</p></li><li><p>该投票者把自己的选票投给 leader<sub>U</sub> 的时候，leader<sub>U</sub> 的日志至少跟 voter 一样新（可以更新），这就导致了以下的两个矛盾之一了。</p></li><li><p><strong>第一个矛盾：</strong></p><p><strong>如果 voter 和 leader<sub>U</sub> 最后一个日志条目的任期号相同的话，那么 leader<sub>U</sub> 的日志至少和 voter 的一样长，所以 leader<sub>U</sub> 的日志一定包含 voter 日志中的所有日志条目。 这是一个矛盾，因为 voter 包含了该已提交的日志条目，所以 leader<sub>U</sub> 必定也包含该日志条目，而前面我们假设了 leader<sub>U</sub> 是不包含的，这就产生了矛盾。</strong></p></li><li><p><strong>第二个矛盾：</strong></p><p><strong>如果不是上面描述的情况的话，那么 leader<sub>U</sub> 最后一个日志条目的任期号必然需要比 voter 的更大。此外，它还比 T 要大，因为 voter 拥有在任期号为 T 提交的日志条目，所以 voter 最后一个日志条目的任期号至少为 T。创建了 leader<sub>U</sub> 的最后一个日志条目的之前的 leader 一定已经包含了该已被提交的日志条目（因为我们上面假设了 leader<sub>U</sub> 是第一个没有该日志条目的 leader）。所以，根据日志匹配特性，leader<sub>U</sub> 一定也包含了该已被提交的日志条目，这样也产生了矛盾</strong>。</p></li><li><p>上述讨论就证明了假设是不成立的。因此，所有比 T 大的任期的 leader 一定包含了任期 T 中提交的所有日志条目。</p></li><li><p>日志匹配特性保证了未来的 leader 也会包含被间接提交的日志条目，如图 8 (d) 中的索引 2。</p></li></ol><p>通过 leader 的完整性特性，我们就可以证明图 3 中的状态机安全特性了，即如果某个节点已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的节点就不会在相同的索引处应用一个不同的日志条目。在一个节点应用一个日志条目到自己的状态机中时，它的日志和 leader 的日志从开始到该日志条目都是相同的，并且该日志条目必须被提交。现在考虑一个最小的任期号，在该任期中任意节点应用了一个给定的最小索引上面的日志条目，那么 Log 的完整性特性就会保证该任期之后的所有 leader 将存储相同的日志条目，因此在后面的任期中应用该索引上的日志条目的节点会应用相同的值。所以，状态机安全特性是可以得到保证的。</p><p>最后，因为 Raft 要求服务器节点按照日志索引顺序应用日志条目，再加上状态机安全特性，这样就意味着我们可以保证所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中了。</p><h3 id="5-5-follower-和-candidate-崩溃"><a href="#5-5-follower-和-candidate-崩溃" class="headerlink" title="5.5 follower 和 candidate 崩溃"></a>5.5 follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。follower 和 candidate 崩溃后的处理方式要比 leader 崩溃简单得多，而且它们的处理方式是相同的。如果一个 follower 或者 candidate 崩溃的话，后面发送给它们的 RequestVote 和 AppendEntries RPCs 都会失败。Raft 通过无限重试来处理这种失败。如果崩溃的节点重启了，那么这些 RPC 就会被成功地完成。如果一个节点在完成了一个 RPC，但是还没来得及响应就崩溃了的话，那么在它重启之后它会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以重复发送相同的 RPCs 不会对系统造成危害。实际情况下，一个 follower 如果接收了一个 AppendEntries 请求，但是这个请求里面的这些日志条目在它日志中已经有了，它就会直接忽略这个新的请求中的这些日志条目。</p><blockquote><p>译者注：<strong>幂等</strong></p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现。</p></blockquote><h3 id="5-6-时序和可用性"><a href="#5-6-时序和可用性" class="headerlink" title="5.6 时序和可用性"></a>5.6 时序和可用性</h3><p>Raft 中有一个要求就是 Raft 的安全性不能依赖于时序（timing）：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。然而，可用性（即系统能够及时响应客户端的请求）不可避免的要依赖于时序。比如说，如果信息交换的时间比一般服务器崩溃所持续的时间还要长的话，那么 candidate 可能等不到赢得选举了，而缺少了一个稳定的 leader，Raft 将无法工作。</p><p>Raft 中时序最关键的地方就是 Leader election。只要整个系统满足下面的时间要求，Raft 就可以选举并维持一个稳定的 leader：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是一个节点并行地发送 RPCs 给集群中其他所有的节点并得到响应的平均时间。选举超时时间就是在 5.2 节中介绍的选举超时时间。平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须选举超时时间小一个量级，这样 leader 才能够有效发送心跳信息来组织 follower 进入选举状态。再加上随机化选举超时时间的方法，这个不等式也使得无果选票（split vote）变得几乎不可能。而选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才可以稳定地运行。有了这个限制后，当 leader 崩溃后，整个系统会有一段大约选举超时时间的时长不可用，我们希望该情况在整个系统运行时间里只占一小部分。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们可以自定义的。Raft 的 RPCs 需要接收方将信息持久化地保存到稳定存储中，所以广播时间大约是 0.5ms ~ 20ms 之间，取决于存储的技术。因此，选举超时时间可能需要在 10ms ~ 500ms 之间。而大多数的服务器的平均故障间隔时间都在几个月甚至更长，所以很容易满足时间的要求。</p><h2 id="6-集群成员变更"><a href="#6-集群成员变更" class="headerlink" title="6. 集群成员变更"></a>6. 集群成员变更</h2><p>到目前为止，我们都假设集群的配置（参与共识算法的服务器节点集合）是固定不变的。但是在实际情况中，我们有时候是需要去改变集群配置的，比如说在服务器崩溃的时候去更换服务器或者是更改副本的数量。尽管可以通过下线整个集群，更新所有配置，然后重启整个集群的方式来实现这个需求，但是这会导致集群在更改过程中是不可用的。另外，如果这个过程中存在一些操作需要人工干预，那么就会有操作失误的风险。为了避免这些问题，我们决定将配置变更自动化并将其纳入到 Raft 的共识算法中来。</p><p>为了使配置变更机制足够安全，在配置变更过程中不能存在任何一个时刻使得同一任期中选出两个 leader。遗憾的是，任何服务器直接从旧的配置转换为新的配置的方案都是不安全的。一次性自动地转换所有服务器的配置的不可能的，所以在转换期间整个集群可能划分为两个独立的大多数（如图 10 所示）。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgq3skl4gj322c0nwaes.jpg" alt="image-20210714195412552"></p><blockquote><p>译者注：图 10 补充</p><p>上图中，在中间位置 Server1 可以通过自身和 Server2 的选票成为 leader（满足旧配置下收到大多数选票的原则）；Server3 可以通过自身和 Server4、Server5 的选票成为 leader（满足新配置线，即集群有 5 个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个 leader，这和 Raft 协议是违背的。</p></blockquote><p>为了保证安全性，配置变更必须采取一种两段式方法。目前有很多种两段式的实现。例如，有些系统（如 [22] ）在第一阶段停掉旧的配置，所以在这个阶段不能处理用户的请求，然后在第二阶段启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为 <strong>联合共识（joint consensus）</strong> 。一旦联合共识配置已经被提交了，系统就可以切换到新的配置上了。<strong>联合共识配置是新旧配置的并集</strong>：</p><ul><li>日志条目被复制给集群中处于新、老配置的所有节点</li><li>新、旧配置的节点都可能成为 leader</li><li>达成一致（针对选举和提交）需要分别得到在两种配置上过半的支持</li></ul><p>联合共识允许每一个节点在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合共识还允许在集群配置变更期间响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信。图 11 展示了配置变更的过程。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgpnv9f98j32060p6agz.jpg" alt="image-20210714193852320"></p><p>当 leader 接收到一个更新配置的请求的时候，它就创建一个联合共识日志条目 C<sub>old,new</sub>，并以前面描述的方式复制该条目。 <strong>一旦某个节点将该配置日志条目增加到自己的日志中。那么这个节点就会用该配置来做出未来的所有决策（一个节点总是使用日志中最新的配置，无论该日志是否已经被提交）。</strong> 这就意味着 leader 会使用 C<sub>old,new</sub> 的规则来判断 C<sub>old,new</sub> 日志条目是什么时候被提交的。如果 leader 崩溃了，新的 leader 有可能处于 C<sub>old</sub> 配置，也可能处于 C<sub>old,new</sub> 配置，这取决于赢得选举的 candidate 是否已经接收到了 C<sub>old,new</sub> 配置。在任何情况下，处于 C<sub>new</sub> 状态的节点在此期间都是不能单独做出决定的。</p><p>当 C<sub>old,new</sub> 被提交了，那么 C<sub>old</sub> 和 C<sub>new</sub> 都不能在没有得到对方认可的情况下做出决定，并且 Leade 完整特性（Leader Completeness Property）保证了只有拥有 C<sub>old,new</sub> 日志的 candidate 有可能被选为 leader。所以现在 leader 就可以安全地创建一个描述 C<sub>new</sub> 的日志条目并将其复制给集群中的其他节点了。一样的，新的配置被节点收到后就会立刻生效。当新的配置在 C<sub>new</sub> 的规则下被提交了之后，旧配置就变得无关紧要了，处于旧配置的节点也可以关闭了。如图 11 所示，没有任何一个时刻 C<sub>old</sub> 和 C<sub>new</sub> 是可以单独做决定的，这保证了安全性。</p><p>关于配置变更有三个问题需要解决：</p><ul><li><p>第一个问题：新的节点可能在一开始并没有存储任何的日志条目。当这些节点以这种状态加入到集群中的时候，它们需要一段时间来更新自己的日志，以便赶上其他节点，在这个时间段里面它们是不可能提交一个新的日志条目的。 <strong>为了避免因此造成的系统短时间的不可用，Raft 在配置变更前引入了一个额外的阶段。在该阶段中，新的节点以没有投票权身份加入到集群中来（leader 会把日志复制给它们，但是考虑过半的时候不需要考虑它们）。</strong> 一旦新节点的日志已经赶上了集群中的其他节点，那么配置变更就可以按照之前描述的方式进行了。</p></li><li><p>第二个问题：leader 有可能不是新配置中的一员（译者注：也就是说这个 leader 后面是需要被下线的）。在这种情况下，leader 一旦提交了 C<sub>new</sub> 日志条目，它就会退位为 follower（译者注：C<sub>old,new</sub> 状态下依旧可用）。这就意味着有这样一段时间（leader 提交 C<sub>new</sub> 期间）：leader 管理着一个不包括自己的集群，它会复制日志给其他节点，但是算副本数量的时候不会算上自己。leader 转换发生在 C<sub>new</sub> 被提交的时候，因为这是新配置可以独立运行的最早时刻（在这个时刻之后，一定是从 C<sub>new</sub> 中选出新的 leader）。在这个时间点之前，有可能只能从 C<sub>old</sub> 中选出 leader。</p></li><li><p>第三个问题：那么被移除的节点（不处于 C<sub>new</sub> 状态的节点）有可能会扰乱集群。这些节点将不会收到心跳信息，所以当选举超时时，它们就会进行新的选举过程。它们会发送带有新任期号的 RequestVote RPCs，这样会导致当前的 leader 回到 follower 状态，然后选出一个新的 leader。但是这些被移除的节点还是会收不到心跳，然后再次超时，再次循环这个过程，导致系统的可用性很差。</p><p>为了避免这个问题，当节点认为当前有 leader 存在时，节点会忽略 RequestVote RPCs。具体来说，当一个节点在最小选举超时时间内收到一个 RequestVote RPC，它不会更新它的任期或授予它的投票。这不会影响正常的选举，每个节点在开启一轮选举之前，它会至少等待一次最小选举超时时间。相反，这有利于避免被移除的节点的扰乱：如果一个 leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p></li></ul><blockquote><p>译者注：<strong>对配置变更的归纳</strong></p><ol><li><p>配置变更过程</p><ol><li><p>leader 在本地生成一个新的日志条目，其内容是 C<sub>old</sub> ∪ C<sub>new</sub>，代表当前时刻新旧成员配置共存，写入本地日志，称为 C<sub>old,new</sub>。后面 leader 就以该日志作为自己的配置了。同时将该日志条目复制集群中是所有节点中。在此之后新的日志同步需要保证得到 C<sub>old</sub> 和 C<sub>new</sub> 两个多数派的确认。</p><p>follower 收到 C<sub>old.new</sub> 的日志后更新本地日志，并且此时就以该配置作为自己的成员配置。</p><p>如果 C<sub>old</sub> 和 C<sub>new</sub> 中的两个多数派确认了 C<sub>old.new</sub> 这个日志条目，leader 就提交它。</p></li><li><p>接下来 leader 生成一条新的日志条目，其内容是新成员配置 C<sub>new</sub>，同样将该日志条目写入本地日志，同时复制给集群中其他节点。</p><p>follower 收到新成员配置 C<sub>new</sub> 后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在 C<sub>new</sub> 这个成员配置中会自动退出。</p><p>leader 收到 C<sub>new</sub> 的多数派确认后，表示成员变更成功，后续的日志只要得到 C<sub>new</sub> 多数派确认即可。</p></li></ol><p>完成上述两阶段后，leader 就可以给客户端回复配置变更执行成功。</p></li><li><p>如果当前的 leader 不在 C<sub>new</sub> 的配置中会怎么样？</p><p>因为当前 leader 不在 C<sub>new</sub> 配置中，所以当 C<sub>new</sub> 日志条目被提交的时候，leader 其实是要被下线的（比如说集群节点数从 5 缩容为 3，且刚好下线的节点中包含当前 leader）。那这样的话，在 C<sub>old,new</sub> 状态下，leader 还是可用的，但是一旦 C<sub>new</sub> 日志条目被提交了，leader 就需要下线了，这个时候不用当心，因为 C<sub>new</sub> 已经被复制过半了，重新选 leader 也一定是选有 C<sub>new</sub> 的。</p></li><li><p>如果在配置分发过程中 leader 崩溃了怎么办？</p><p>分两种情况：</p><ol><li><p>C<sub>new</sub> 已经分发过半</p><p>集群开始重新选举，此时在 C<sub>new</sub> 的规则下，不存在新配置中的节点不会赢得选举（因为他们要在C<sub>old,new</sub> 的情况下决定，但是拿不到 C<sub>new</sub> 的选票），只有拿到 C<sub>new</sub> 的节点可能成为 leader 并继续下发 C<sub>new</sub> 配置，流程恢复。</p></li><li><p>C<sub>new</sub> 没有分发过半</p><p>这种情况下，C<sub>old,new</sub> 和 C<sub>new</sub> 的节点都可以成为 leader，但是无所谓，因为无论谁成为 leader，都能根据当前的配置继续完成后续流程（如果是 C<sub>new</sub> 那么相当与完成了最终的配置，不在 C<sub>new</sub> 的节点会因为没有心跳数据而失效）。</p></li></ol></li><li><p>旧配置节点下线造成的问题</p><p>Raft 的处理方式：当节点确信有 leader 存在时，不会进行投票（在 leader 超时之前收到新的投票请求时不会提升任期号和做出投票）。且开始选举之前等待一个选举超时时间，这样在新 leader 正常工作的情况下，不会受到旧节点的影响。</p><p>旧配置节点在发起选举前需要等待一段时间，那么这段时间新 leader 可以发送心跳，这样就减少了影响。 对正常流程的影响不大。（leader 失效后要等一段时间，没有及时触发，然而本身这里就有一个判断失效的时间，好像影响不大；比如原先超时时间是 10s，那么如果设置成 5s，原策略下 10s 超时就是 10s 后开始选举，新策略下 5s 超时就是超时后再等 5s 再开始选举，影响就是超时时间变短）</p></li><li><p>无数据的新节点加入集群中的问题</p><p>新加入的节点需要时间复制数据，在这个过程完成之前，Raft 采用以下机制来保证可用性： 新加入节点没有投票权（ leader 复制日志给他们，但计算已复制日志条目的副本数的时候不考虑它们），直到这些节点的日志追上其他节点。</p></li><li><p>如果在配置变更过程中接收到用户请求的话，是用旧配置响应还是用新配置响应？</p><p><strong>按照笔者的理解，这个方面，对 Raft 协议的具体实现可以根据自身需求来自定义实现，Raft 的联合共识是为了避免同一时刻出现了 2 个 leader，避免了对客户端的一个请求同时有两个不同的响应出现。而在具体实现中，在某个阶段，究竟是采取新配置响应还是旧配置响应，可以再斟酌。</strong></p><p>比如说可以这样：</p><ol><li>C<sub>old</sub> 阶段：使用旧配置，需要过半旧配置节点确认</li><li>C<sub>new</sub> 已提交阶段：使用新配置，需要过半新配置节点确认</li><li>C<sub>old,new</sub> 阶段：配置信息中有节点数量（这样才可能判断是否过半），这个时候新旧配置都需要过半节点确认，而响应新配置执行的结果还是响应旧配置执行的结果，就看 old 多还是 new 多，谁多用谁。</li></ol></li><li><p>如果 leader 要下线，客户端发来的新的请求如何处理？</p><ol><li>如果是在 leader 复制 C<sub>new</sub> 之后，提交 C<sub>new</sub> 之前的话，leader 工作在新的集群配置下，所以会将日志复制到新集群的节点下，当收到新集群（不包含 leader 本身）超过半数节点确认后，就可以提交日志。</li><li>在其他阶段，leader 就是正常可用的。</li></ol></li><li><p>所谓 C<sub>new</sub> 和 C<sub>old,new</sub> 日志条目，里面没有数据，只有指令，里面的指令就是让节点执行对应的配置项。</p></li></ol></blockquote><h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7. 日志压缩"></a>7. 日志压缩</h2><p>在正常情况下，Raft 的日志会随着客户端请求的增加而不断增长。但在实际系统中，日志不可能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来重新执行日志中的日志条目。如果没有一定的机制来清除日志中积累的过期的信息，那么最终一定会影响系统的可用性。</p><p><strong>快照技术（snapshotting）</strong> 是日志压缩最简单的方法。在快照技术中，某个时间点下的前整个系统的状态都会以快照的形式持久化起来，然后该时间点之前的日志会被全部丢弃。快照技术呗使用在 Chubby 和 ZooKeeper 当中，接下来的章节会介绍 Raft 中的快照技术。</p><p><strong>增量压缩方法（Incremental approach to compaction）</strong>，例如<strong>日志清洗（log cleaning）</strong>[36] 和<strong>日志结构合并树（log-structured merge trees）</strong>[30, 5]，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，选择一个积累了大量被删除或被覆盖的对象的数据区域，然后重写该区域内还活着的对象，之后释放该区域。和快照技术相比，这需要大量额外的机制，并且增加了更多的复杂性，快照技术通过操作整个数据集来简化问题。虽然日志清理需要对 Raft 进行修改，但是状态机可以使用与快照技术相同的接口来实现 LSM（日志结构合并） 树。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshvublij8j321s0lsadj.jpg" alt="image-20210715195808192"></p><p>图 12 展示了 Raft 快照技术的基本思想。每一个节点独立地生成快照，快照中只包含自己日志中已经被提交的条目，这个过程主要的工作是状态机将自己的状态写入快照中。Raft 在快照中还保留了少量的元数据：</p><ul><li>last included index：指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目）</li><li>last included term：指的是该条目所处的任期号</li></ul><p>保留这些元数据是为了支持快照后第一个条目的 AppendEntries 一致性检查，因为该条目需要一个之前的日志索引和任期号。为了支持集群成员变更（第 6 节中讨论的），快照中还包含日志中到 last included index 为止的最新的配置。一旦节点完成了快照的写入，它可能就会删除 last included index 及之前的所有日志条目，以及之前的快照。</p><p>尽管通常情况下，节点都是独立生成快照的，但是 leader 不可避免偶尔需要发送快照给一些落后的 follower。这通常发生在 leader 已经丢弃了需要发给 follower 的下一条日志条目的时候。幸运的是，这种情况在正常操作中是不会出现的：一个与 leader 保持同步的 follower 通常都会拥有该日志条目。不过如果一个 follower 运行比较缓慢，或者是它刚加入集群，那么它就可能会没有该日志条目。这个时候 leader 会通过网络将该快照发送给该 follower，以使得该 follower 可以更新到最新的状态。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshxf2bjwej31gg0u0k01.jpg" alt="image-20210715205247442"></p><p>这个时候 leader 使用了一种新的 RPC 来发送快照给那些太落后的 followers，如图 13 所示，这种 RPC 叫做 <strong>InstallSnapshot</strong>。当一个 follower 通过这种 RPC 收到快照的时候，它必须决定如何处理当前已经存在的日志条目。通常情况下，这份快照会包含接受者日志者没有的信息。所以这种情况下 follower 会丢弃它的整个日志，它的日志会全部被快照取代，并且可能有与快照冲突的未提交的条目。相反，如果一个 follower 收到一个描述其日志前缀的快照（可能是由于重传或错误），则被快照覆盖的日志条目将被删除，但是快照之后的条目仍然有效，且必须要保留。</p><p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower 可能在不知道 leader 的情况下创建快照。但是我们认为这种违背是合乎情理的。leader 的存在，是为了防止在达成共识的时候产生冲突，但是在创建快照的时候，共识已经达成了，因此没有决策会出现冲突。这种情况下，数据还是跟之前一样，只能从 leader 流向 follower，只不过现在允许 follower 可以重新组织它们的数组而已。</p><p>我们曾经考虑过一种可替代的方案，那就是只有 leader 可以创建快照，然后由 leader 将这份快照发送给其他所有的 follower。但是，这种方案有两个缺点：</p><ol><li>发送快照给每个 follower 会浪费网络带宽和延缓了快照处理过程。实际上每一个 follower 已经拥有了创建自己快照所需要的全部信息了，所以很显然，follower 根据本地的状态创建快照要比通过网络来接收别人发过来的要更加实惠。</li><li>这会造成 leader 的实现更加复杂。比如说，leader 发送快照给 follower 的同时要能够做到并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求，这就复杂得多了。</li></ol><p>还有两个问题会影响快照的性能：</p><ol><li><p>每一个节点必须判断何时去生成快照。如果一个节点生成快照的频率太高，那么就会浪费大量的磁盘带宽和其他资源；如果一个节点生成快照的频率太低，那么就要承担耗尽存储容量的风险，同时也增加了重启时重新执行日志的时间。</p><p>一个简单的策略就是当日志大小达到一个固定的阈值的时候就生成一份快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽开销将较小。</p></li><li><p>第二个影响性能的就是写快照需要花费一定的时间，而我们又不希望它会影响到正常的操作。</p><p>解决方案就是使用 <strong>写时复制的技术（copy-on-write）</strong> ，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛型函数结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如 Linux 上的 fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p></li></ol><h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8. 客户端交互"></a>8. 客户端交互</h2><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft 是如何支持线性化语义的 [10]。这些问题对于所有的基于共识算法的系统都是存在的，Raft 的解决方案也跟其他的系统差不多。</p><p>Raft 的客户端们将所有的请求发送给 leader。当客户端第一次启动的时候，它会随机挑选一个节点来进行通信。如果客户端首选的不是 leader，那么被客户端选中的节点就会拒绝客户端的请求并且提供关于它最近收到的 leader 的信息（AppendEntries RPC 包含了 leader 的网络地址）。如果 leader 崩溃了，客户端请求就会超时，这个时候客户端需要随机选择一个节点来重试发送请求。</p><p>我们对 Raft 的期许是希望它可以实现线性化语义（即每次操作看起来似乎都是在调用和响应之间的某个点上即时执行一次）。但是，按照上面描述的，Raft 可能会对同一条指令执行多次。例如，如果 leader 在提交了某个日志条目后，在还没来得及响应客户端的时候就崩溃了，那么客户端会和新的 leader 重试该指令，这就造成了同一指令被执行了两次。解决方案是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的响应。如果状态机接收到了一条已经执行过的指令了，就立即作出响应，并且不会重复执行该指令。</p><p>只读操作（Read-Only）可以直接处理而不记录日志。但是，如果不采取任何措施的话，这可能会有返回过期数据（stale data）的风险。<strong>因为 leader 响应客户端请求的时候它可能已经被新的 leader 代替了，但是它还不知道自己已经不是最新的 leader 了。</strong></p><blockquote><p>译者补充：<strong>为什么一个 leader 好好的会有另外一个 leader 出现？</strong></p><p>参考：<a href="https://segmentfault.com/a/1190000039264427">https://segmentfault.com/a/1190000039264427</a></p><p>实际上，老的 leader 可能不会马上消失，例如：网络分区将 leader 与集群的其余部分分隔，其余部分选举出了一个新的 leader。然后老的 leader 崩溃后重新连接，可能会不知道新的 leader 已经被选出来了。</p></blockquote><p>线性化的操作肯定不会返回过期的数据。Raft 需要使用两个额外的预防措施来在不适用日志的时候保证这一点。</p><ol><li><p>leader 必须拥有那些已提交的日志条目的最新信息。Leader 完整性特性（Leader Completeness Property）保证了 leader 一定拥有所有已被提交的日志条目，但是在它任期刚开始的时候，它可能还不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。</p><p><strong>Raft 通过让 leader 在任期开始的时候提交一个空的日志条目到日志中来解决该问题</strong>。（译者注：这就是前面 5.4.2 节提到的 no-op 日志）</p></li><li><p>leader 在处理只读请求的时候必须检查自己是否已经被替代了（因为如果一个新 leader 被选出来了，那么这个旧 leader 的数据可能就过时了）。</p><p>Raft 通过让 leader 在响应只读请求之前，先和集群中过半的节点交换一次心跳信息来解决该问题。</p><p>另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式 [9]，但是这种方式的安全性需要依赖于时序（假设时间误差是有界的）。</p></li></ol><h2 id="9-算法实现与评估"><a href="#9-算法实现与评估" class="headerlink" title="9. 算法实现与评估"></a>9. 算法实现与评估</h2><p>我们已经实现了 Raft 作为复制状态机的一部分，该状态机存储了 RAMCloud [33] 的配置信息，并帮助 RAMCloud 协调器进行故障转移。这个 Raft 实现大概包含了 2000+ 行 C++ 代码，但是这里面没有包含测试、注释和空行。这些代码是开源的 [23]。同时也有大约 25 个其他独立的第三方、针对不同的开发场景、基于这篇论文草稿的开源实现。同时，很多公司已经部署了基于 Raft 算法的系统了。</p><p>本节剩下的篇幅将从三个方面来评估 Raft 算法：</p><ul><li>可理解性</li><li>正确性</li><li>性能</li></ul><h3 id="9-1-可理解性"><a href="#9-1-可理解性" class="headerlink" title="9.1 可理解性"></a>9.1 可理解性</h3><p>为了衡量 Raft 相对于 Paxos 的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一项实验研究。我们为 Raft 和 Paxos 分别录制了一个视频教程，并且准备了相应的小测验。其中 Raft 课程覆盖了本篇论文除了日志压缩之外的全部内容，而 Paxos 课程涵盖了创建一个与 Raft 等价的复制状态机的全部资料，包括 signle-decree Paxos、multi-decree Paxos、重新配置和一切实际系统需要的性能优化（比如 leader 选举）。这个小测验主要是测试一些对算法的理解和解释一些边缘情况。每个学生都是看完第一个视频，然后做对应的测验，然后再看第二个视频，再做第二份测验。为了解释个人表现与从第一部分研究中获得的经验差异的原因，大约有一半的学生先进行 Paxos 的部分，然后另一半学生先进行 Raft 的部分。我们通过计算参与人员的每一份测验的得分来看参与者是否更加容易理解 Raft 算法。</p><p>我们尽可能的使得在比较 Raft 和 Paxos 过程中是公平的。这个实验从两个方面偏向了 Paxos：</p><ol><li>43 个参与者中有 15 个人在之前有一些 Paxos 的经验</li><li>Paxos 视频教程的时长要长 14%</li></ol><p>如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏向。我们所有的材料都可供审查 [28, 31]。</p><table><thead><tr><th>关注点</th><th>缓和偏向采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr><td>相同的讲课质量</td><td>两份教程采用同一个讲师。Paxos 的教程是在现有的一些大学使用的材料基础上改进的。Paxos 的教程要长 14%。</td><td>视频</td></tr><tr><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评分细则</td></tr></tbody></table><center>表格1：考虑到潜在的实验偏向，我们对于每种情况的解决方法，以及相应的材料。</center><p>平均上看，参与者在 Raft 测验上的得分要比在 Paxos 测验上的得分高处 4.9 分（在 60 分中，Raft 的平均得分是 25.7 分，Paxos 的平均得分是 20.8 分）。图 14 展示了每个参与者的得分。配对 t 检验（paired t-test）表明，在 95% 的置信度下，Raft 分数的真实分布的平均值至少要比 Paxos 的大 2.5 分。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsixtffkroj32220my76y.jpg" alt="image-20210716175208106"></p><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，这个模型基于以下三点：</p><ol><li>他们使用的是哪个测验</li><li>之前对于 Paxos 的经验</li><li>学习算法的顺序</li></ol><p>该模型预测，对小测验的选择会产生 12.5 分的有利于 Raft 的差别，这很明显高于观察到的 4.9 分的分差。这是因为实际上许多的学生之前有学习过 Paxos，这对 Paxos 的有很大帮助的，但是对 Raft 的帮助就较小了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft 的得分低了 6.3 分。虽然我们不知道这是为什么，但是这似乎在统计上是有意义的。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsiz66oe4yj323m0jgdj0.jpg" alt="image-20210716183850084"></p><p>我们同时也在测验之后对参与者进行了调查，调查的内容是他们认为哪个算法更容易去实现或解释。这些调查结果展示在图 15。调查结果是碾压性的，结果表明 Raft 算法更加容易实现和解释（41 人中的 33 个）。然而，这种自我报告的感觉可能没有参与者的测试分数来得可靠，而且参与者可能由于我们假设 Raft 更容易理解而存在偏向。</p><p>在参考文献 [33] 中有一个关于 Raft 用户学习的更加详细的讨论。</p><h3 id="9-2-正确性"><a href="#9-2-正确性" class="headerlink" title="9.2 正确性"></a>9.2 正确性</h3><p>在第 5 节中，我们已经对共识机制制定了正式的规范并且对其安全性做了证明。这份正式的规范使用 TLA+ 规范语言 [17] 使图 2 中对算法的总结的信息非常清晰。它差不多有 400 行并且作为了我们要证明的核心。同时这份规范对于任何想实现 Raft 的人都是十分有用的。我们用 TLA 证明系统 [7] 机械地证明了日志完整性（Log Completeness Property）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范中的类型安全）。而且，我们已经编写了状态机安全特性的非正式证明 [31]，它是完整的（它仅依赖于规范）和相对精确的（大约 3500 字长）。</p><h3 id="9-3-性能"><a href="#9-3-性能" class="headerlink" title="9.3 性能"></a>9.3 性能</h3><p>Raft 的性能跟其他像 Paxos 的共识算法很接近。在性能方面，最重要的关注点就是，当一个 leader 被选举出来后，它要在什么时候复制新的日志条目。Raft 通过很少量的消息包（一轮从 leader 到集群中过半节点的的消息传递）就解决了这个问题。同时，进一步提升 Raft 的性能也是有可能的。比如说，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他共识算法已经提出过很多性能优化方案，其中很多都可以应用到 Raft 上，但是我们暂时把这些工作放到未来的工作中。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 的 leader election 算法的性能并且回答两个问题：</p><ol><li>leader 选举过程收敛是否足够快？</li><li>在 leader 崩溃之后，最小的系统崩溃时间是多久？</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsj0yuh34ej61km0u043r02.jpg" alt="image-20210716194110554"></p><p>为了衡量 leader election 的性能，我们反复使一个拥有 5 个节点的集群的 leader 宕机，并计算它检测崩溃和重新选一个新的 leader 所需的时间（见图 16）。为了构建一个最坏的情景，我们使各个节点中的日志长度都是不同的，这样某些 candidate 是无法成为  leader 的。而已，为了尽可能出现无结果的投票（split vote）情况，我们的测试脚本在终止 leader 的进程之前从 leader 那触发了一个同步的发送了一次心跳广播（类似于 leader 在崩溃前复制一个日志条目给其他节点）。leader 在其心跳间隔内均匀随机地崩溃，这个心跳间隔也是所有测试中最小选举超时时长的一半。因此，<strong>最小宕机时间大约就是最小选举超时时间的一半</strong>。</p><p>图 16 中上面的图表明，只需要在选举超时时间上使用很小的随机化就可以大大避免出现没有结果的投票的情况。在没有随机化的情况下（译者注：见图 16 中上面的图右边的橙色虚线），由于出现了很多没有结果的投票的情况，leader election 往往都需要花费超过 10s 的时间。仅仅加入 5ms 的随机化时间，就大大改善了选举过程，现在平均的宕机时间只有 287ms。继续增大随机性可以大大改善最坏的情况：通过增加 50ms 的随机化时间，最坏的完成情况（即完成 1000 次实验）只需要 513 ms。</p><p>图 16 中下面的图表明，通过减少选举超时时间可以禁烧系统的宕机时间。在选举超时时间为 12~24ms 的情况下，只需要平均 35ms 就可以选举出新的 leader（最长的一次花费了 152ms）。然而，进一步降低选举超时时间可能就会违反 Raft 不等式的要求。</p><blockquote><p>广播时间（broadcastTime） &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>因为这会使得在其他节点开启一轮新的选举之前，当前的 leader 要完成发送一次心跳广播变得很难。这会造成不必要的 leader 更换，从而降低了系统的可用性。我们推荐使用一个更为保守的选举超时时间，比如 150~300ms。这样的时间不大可能导致不必要的 leader 更换，同时还能提供不错的可用性。</p><h2 id="10-相关工作"><a href="#10-相关工作" class="headerlink" title="10. 相关工作"></a>10. 相关工作</h2><p>现在已经有很多关于共识算法相关的产物了，其中很多都属于以下类别之一：</p><ul><li>Lamport 对于 Paxos 的最初的描述 [15]，以及尝试将 Paxos 解释地更清晰的描述 [16, 20, 21 ]。</li><li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础 [26, 39, 13]。</li><li>实现共识算法的系统，例如 Chubby [2, 4]，ZooKeeper [11, 12] 和 Spanner [6]。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>对于 Paxos 的性能优化 [18, 19, 3, 25, 1, 27]。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述 [29] 和分布式传输协议耦合在了一起，但是核心的共识算法在最近更新的版本 [22] 里被分离了出来。VR 使用了一种基于 leader 的方法，和 Raft 有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同就在于 Raft 的<strong>强领导性（strong leadership）</strong>。Raft 将 leader election 作为共识协议中非常重要的一环，并且将尽可能多的功能集中到了 leader 身上。这种方法使得算法更加简单和更容易理解。比如说，在 Paxos 中，leader election 和基本的共识协议是正交的：它只是作为一种性能优化，而不是实现共识所必需的。然而，这带来了很多额外的机制：</p><ul><li>Paxos 中包含了一个两段式的基本共识协议</li><li>Paxos 中还包含了一个单独的 leader election 机制</li></ul><p>相比之下，Raft 将 leader election 直接纳入了共识算法并且将其作为共识两阶段中的第一个阶段，这使得 Raft 使用的机制要比 Paxos 少得多。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于 leader 的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制。因为 Raft 尽可能的减少了非 leader 者的功能。例如，Raft 中日志条目都遵循着从 leader 发送给 follower 这一个方向：AppendEntries RPCs 是向外发送的。在 VR 中，日志条目的流动是双向的（leader 人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p><p>跟我们上述提到的其他基于共识性的日志复制算法相比，Raft 的消息类型更少。例如，我们计算了一下 VR 和 ZooKeeper 用来实现基本功能和集群成员变更（不包括日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）所需要的消息类型。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型。相比之下，Raft 只有 4 种消息类型（两种 RPC Request 及其对应的两种 RPC Response）。Raft 的消息的消息量比其他算法的要大一点，但总的来说，它们更加简单。另外，VR 和 ZooKeeper 都在 leader 改变的时候传输了整个日志，所以这些算法为了能在实践中使用，就不得不增加额外的消息类型了。</p><p>Raft 的强 leader 模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有 leader 的情况下可以达到很高的性能 [27]。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p><p>一些集群成员变更的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论 [15]，VR [22] 和 SMART [24]。我们选择使用联合共识的方法是因为它利用了共识协议的其余部分，这样我们只需要很少的一些机制就可以实现成员变更。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有 leader 的情况下也可以达到共识性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行。相比之下，VR 在配置变更期间需要停止所有正常的处理过程，而 SMART 对未完成请求的数量实施了类似 α 方法的限制。另外，和 VR、SMART 相比，Raft 的方法也只需要增加更少的额外机制来实现。</p><h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11. 结论"></a>11. 结论</h2><p>算法的设计通常以正确性、效率和简洁性为主要目标。虽然这些都是有价值的目标，但我们相信可理解性同样重要。在开发人员将算法转化为实际实现之前，其他任何目标都不能实现，而实际实现将不可避免地偏离和扩展发布的形式。除非开发人员对算法有深刻的理解，并能对算法有直观的认识，否则他们很难在实现中保留算法理想的特性。</p><p>在本文中，我们讨论了分布式共识的问题，在这个问题上，一个被广泛接受但难以理解的算法：Paxos，多年来一直让学生和开发人员非常挣扎。我们开发了一种新的算法：Raft，我们已经证明它比 Paxos 更容易理解。我们也相信 Raft 会为系统建设提供更好的基础。将可理解性作为主要设计目标改变了我们处理 Raft 设计的方式。随着设计的进展，我们发现自己反复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了 Raft 的可理解性，而且使我们更容易证实它的正确性。</p><h2 id="12-致谢"><a href="#12-致谢" class="headerlink" title="12. 致谢"></a>12. 致谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie&#96;res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生，没有他们的大力支持，这项研究是不可能完成的。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., AND LI, P. Paxos replicated state machines as the basis of a high-performance data store. In <em>Proc. NSDI’11, USENIX Conference on Networked Systems Design and Implementation</em> (2011), USENIX, pp. 141–154.</p><p>[2]  BURROWS, M. The Chubby lock service for loosely- coupled distributed systems. In <em>Proc. OSDI’06, Sympo- sium on Operating Systems Design and Implementation</em> (2006), USENIX, pp. 335–350.</p><p>[3]  CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. Multicoordinated Paxos. In <em>Proc. PODC’07, ACM Sym- posium on Principles of Distributed Computing</em> (2007), ACM, pp. 316–317.</p><p>[4]  CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live: an engineering perspective. In <em>Proc. PODC’07, ACM Symposium on Principles of Distributed Computing</em> (2007), ACM, pp. 398–407.</p><p>[5]  CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A., BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: a distributed storage system for structured data. In <em>Proc. OSDI’06, USENIX Symposium on Operating Systems Design and Implementation</em> (2006), USENIX, pp. 205–218.</p><p>[6]  CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C., FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P., HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S., MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y., SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’s globally-distributed database. In <em>Proc. OSDI’12, USENIX Conference on Operating Systems Design and Implemen- tation</em> (2012), USENIX, pp. 251–264.</p><p>[7]  COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D., AND VANZETTO, H. TLA+ proofs. In <em>Proc. FM’12, Symposium on Formal Methods</em> (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of <em>Lec- ture Notes in Computer Science</em>, Springer, pp. 147–154.</p><p>[8]  GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In <em>Proc. SOSP’03, ACM Symposium on Operating Systems Principles</em> (2003), ACM, pp. 29–43.</p><p>[9]  GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanism for distributed file cache consistency. In <em>Proceedings of the 12th ACM Ssymposium on Operating Systems Principles</em> (1989), pp. 202–210.</p><p>[10]  HERLIHY, M. P., AND WING, J. M. Linearizability: a correctness condition for concurrent objects. <em>ACM Trans- actions on Programming Languages and Systems 12</em> (July 1990), 463–492.</p><p>[11]  HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B . ZooKeeper: wait-free coordination for internet-scale systems. In <em>Proc ATC’10, USENIX Annual Technical Con- ference</em> (2010), USENIX, pp. 145–158.</p><p>[12]  JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab: High-performance broadcast for primary-backup sys- tems. In <em>Proc. DSN’11, IEEE&#x2F;IFIP Int’l Conf. on Depend- able Systems &amp; Networks</em> (2011), IEEE Computer Society, pp. 245–256.</p><p>[13]  KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep. CNDS-2008-2, Johns Hopkins University, 2008.</p><p>[14]  L A M P O RT, L . Time, clocks, and the ordering of events in a distributed system. <em>Commununications of the ACM 21</em>, 7 (July 1978), 558–565.</p><p>[15]  L A M P O RT, L . The part-time parliament. <em>ACM Transac- tions on Computer Systems 16</em>, 2 (May 1998), 133–169.</p><p>[16]  LAMPORT, L. Paxos made simple. <em>ACM SIGACT News 32</em>, 4 (Dec. 2001), 18–25.</p><p>[17]  L A M P O RT, L . <em>Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers</em>. Addison- Wesley, 2002.</p><p>[18]  LAMPORT, L. Generalized consensus and Paxos. Tech. Rep. MSR-TR-2005-33, Microsoft Research, 2005.</p><p>[19] L A M P O RT, L . Fast paxos. (2006), 79–103.</p><p>[20]  LAMPSON, B. W. How to build a highly available system using consensus. In <em>Distributed Algorithms</em>, O. Baboaglu and K. Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</p><p>[21]  LAMPSON, B. W. The ABCD’s of Paxos. In <em>Proc. PODC’01, ACM Symposium on Principles of Distributed Computing</em> (2001), ACM, pp. 13–13.</p><p>[22]  LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited. Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</p><p>[23]  LogCabin source code. <a href="http://github.com/">http://github.com/</a> logcabin&#x2F;logcabin.</p><p>[24]  LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J. R., AND HOWELL, J. The SMART way to migrate replicated stateful services. In <em>Proc. Eu- roSys’06, ACM SIGOPS&#x2F;EuroSys European Conference on Computer Systems</em> (2006), ACM, pp. 103–115.</p><p>[25]  MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: building efficient replicated state machines for WANs. In <em>Proc. OSDI’08, USENIX Conference on Operating Systems Design and Implementation</em> (2008), USENIX, pp. 369–384.</p><p>[26] MAZIE&#96; RES, D. Paxos made practical. <a href="http://www.scs.stanford.edu/">http://www.scs.stanford.edu/</a> ̃dm&#x2F;home&#x2F; papers&#x2F;paxos.pdf, Jan. 2007.</p><p>[27]  MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is more consensus in egalitarian parliaments. In <em>Proc. SOSP’13, ACM Symposium on Operating System Principles</em> (2013), ACM.</p><p>[28]  Raft user study. <a href="http://ramcloud.stanford/">http://ramcloud.stanford</a>. edu&#x2F; ̃ongaro&#x2F;userstudy&#x2F;.</p><p>[29]  OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A new primary copy method to support highly-available distributed systems. In <em>Proc. PODC’88, ACM Symposium on Principles of Distributed Computing</em> (1988), ACM, pp. 8–17.</p><p>[30]  O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. The log-structured merge-tree (LSM-tree). <em>Acta Informat- ica 33</em>, 4 (1996), 351–385.</p><p>[31]  ONGARO, D. <em>Consensus: Bridging Theory and Practice</em>. PhD thesis, Stanford University, 2014 (work in progress). </p><p>[32]  ONGARO, D., AND OUSTERHOUT, J. In search of an understandable consensus algorithm. In <em>Proc ATC’14, USENIX Annual Technical Conference</em> (2014), USENIX.</p><p>[33]  OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C., LEVERICH, J., MAZIE&#96;RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D., PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN, R. The case for RAMCloud. <em>Com- munications of the ACM 54</em> (July 2011), 121–130.</p><p>[34]  Raft consensus algorithm website. <a href="http://raftconsensus.github.io/">http://raftconsensus.github.io</a>.</p><p>[35]  REED, B. Personal communications, May 17, 2013.</p><p>[36]  ROSENBLUM, M., AND OUSTERHOUT, J. K. The design and implementation of a log-structured file system. <em>ACM Trans. Comput. Syst. 10</em> (February 1992), 26–52.</p><p>[37]  S C H N E I D E R , F. B . Implementing fault-tolerant services using the state machine approach: a tutorial. <em>ACM Com- puting Surveys 22</em>, 4 (Dec. 1990), 299–319.</p><p>[38]  SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoop distributed file system. In <em>Proc. MSST’10, Symposium on Mass Storage Sys- tems and Technologies</em> (2010), IEEE Computer Society, pp. 1–10.</p><p>[39]  VAN RENESSE, R. Paxos made moderately complex. Tech. rep., Cornell University, 2012.</p>]]></content>
    
    
    <categories>
      
      <category>论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Raft</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
