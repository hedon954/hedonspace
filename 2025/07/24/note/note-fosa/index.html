
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>读书笔记丨《Fundamentals of Software Architecture》 - HedonWang</title>

  
    <meta name="description" content="基于《Fundamentals of Software Architecture》内容，梳理出六步架构设计方法论，从商业理解到组织成长形成闭环，探讨架构师如何在权衡取舍中做出&quot;最不差&quot;的决策，以及如何通过持续交付、监控验证和复盘演进构建可持续的架构能力。">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记丨《Fundamentals of Software Architecture》">
<meta property="og:url" content="https://hedon.top/2025/07/24/note/note-fosa/index.html">
<meta property="og:site_name" content="HedonWang">
<meta property="og:description" content="基于《Fundamentals of Software Architecture》内容，梳理出六步架构设计方法论，从商业理解到组织成长形成闭环，探讨架构师如何在权衡取舍中做出&quot;最不差&quot;的决策，以及如何通过持续交付、监控验证和复盘演进构建可持续的架构能力。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/layer.png">
<meta property="og:image" content="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/fosa-adr.png">
<meta property="article:published_time" content="2025-07-24T03:01:24.000Z">
<meta property="article:modified_time" content="2025-11-13T09:46:40.527Z">
<meta property="article:author" content="Hedon Wang">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="fosa">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/layer.png">
  
  
  
  <meta name="keywords" content="读书笔记,fosa">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="HedonWang" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">


  
    <link rel="shortcut icon" href="/assets/favicon.png">
  

  

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.png"><link rel="shortcut icon" href="/assets/favicon.png"><meta name="theme-color" content="#f8f8f8"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/markmap.css"><script src="https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18"></script>
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/assets/favicon.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main" ff="title">HedonWang</div><div class="sub cap">君子求诸己，律己则安。</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="专栏" href="/topic/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于我" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="思维导图" href="/html/mindmap.html" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/11/26/net-udp-tcp-kcp-quic/"><span class="title">从第一性原理掌握 UDP/TCP/KCP/QUIC</span></a><a class="item title" href="/2025/11/23/go/go-net/"><span class="title">Go 底层原理丨网络编程</span></a><a class="item title" href="/2025/11/21/go/go-lock/"><span class="title">Go 底层原理丨锁</span></a><a class="item title" href="/2025/11/22/go/go-channel/"><span class="title">Go 底层原理丨channel</span></a><a class="item title" href="/2025/11/25/clash-fake-ip/"><span class="title">traceroute 故障排查：Clash Fake IP 及其他 4 种常见原因</span></a><a class="item title" href="/2025/11/23/linux-io-epoll/"><span class="title">从第一性原理理解 epoll</span></a><a class="item title" href="/2025/06/08/rust-os-primitives/"><span class="title">Rust 原理丨操作系统并发原语</span></a><a class="item title" href="/2024/11/11/rust-memory-order/"><span class="title">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</span></a><a class="item title" href="/2025/11/19/go/go-gc-green-tea-gc/"><span class="title">Go 底层原理丨垃圾回收（green tea gc）</span></a><a class="item title" href="/2025/11/17/go/go-gc-tri-color-marking/"><span class="title">Go 底层原理丨垃圾回收（三色标记法）</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/banner/note-fosa.jpg">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-07-24T03:01:24.000Z">2025-07-24</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-11-13T09:46:40.527Z">2025-11-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>读书笔记丨《Fundamentals of Software Architecture》</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1
id="聊架构设计的时候我们在谈什么">聊架构设计的时候，我们在谈什么？</h1>
<p><strong>第一步：理解商业与组织上下文 (Understand Business &amp;
Organizational Context)</strong></p>
<ul>
<li><strong>利益相关方 (Stakeholders)</strong>:
他们的核心诉求和期望是什么？</li>
<li><strong>用户视角 (User Perspective)</strong>:
我们要为用户解决什么核心痛点？</li>
<li><strong>商业目标 (Business Goals)</strong>:
这个项目要达成什么商业指标？（例如：降低成本、提升转化率）</li>
<li><strong>组织能力 (Organizational Capabilities)</strong>:
<ul>
<li>公司文化 (Company Culture): 我们的文化是拥抱变化还是追求稳定？</li>
<li>团队现状 (Team Status): 团队的技术栈、技能水平和规模如何？</li>
</ul></li>
</ul>
<p><strong>第二步：定义架构特性与约束 (Define Architectural
Characteristics &amp; Constraints)</strong></p>
<p>这一步的目标是将第一步中模糊的需求，转化为具体、可度量的技术目标。</p>
<ul>
<li><strong>识别架构特性 (Identify Architectural Characteristics /
-ilities)</strong>:
<ul>
<li>从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计<strong>最关键</strong>的
3-5 个。</li>
<li><strong>对它们进行排序</strong>。例如，对于一个后台管理系统，“可维护性”的优先级可能就高于“性能”。</li>
</ul></li>
<li><strong>明确约束条件 (Define Constraints)</strong>:
<ul>
<li>有哪些不可逾越的红线？例如：预算上限、上线日期 (Time to
Market)、必须使用公司内某技术平台、法律合规要求等。</li>
</ul></li>
</ul>
<p><strong>第三步：探索方案与决策 (Explore Solutions &amp; Make
Decisions)</strong></p>
<p>有了第二步清晰的目标和边界，我们现在可以带着这些标准去评估方案。</p>
<ul>
<li><strong>探索可选方案 (Explore Options)</strong>: 至少寻找 2-3
个备选方案。</li>
<li><strong>进行权衡分析 (Analyze Trade-offs)</strong>:
基于第二步定义的<strong>架构特性优先级</strong>，系统地对比各方案的优劣。</li>
<li><strong>评估风险 (Assess Risks)</strong>:
每个方案可能引入哪些短期或长期的技术、成本、人员风险？</li>
<li><strong>记录决策 (Document Decisions)</strong>: 使用 ADR
(Architecture Decision Record) 记录最终选择和放弃的原因。</li>
</ul>
<p><strong>第四步：设计实施路径与验证机制 (Design Implementation Path
&amp; Verification)</strong></p>
<p>在真正开始大规模编码前，设计好如何走，以及如何验证我们走在正确的路上。</p>
<ul>
<li><strong>实施计划 (Implementation Plan)</strong>:
<ul>
<li>是否需要技术原型 (PoC) 来验证关键难点？</li>
<li>如何进行任务拆解和里程碑规划？</li>
</ul></li>
<li><strong>构建适应度函数 (Build Fitness Functions)</strong>:
<ul>
<li>针对第二步定义的关键架构特性，设计具体的“检验尺”。</li>
<li>例如：为保证“模块解耦”，设计一个静态代码检查规则，禁止模块间的非法调用。</li>
</ul></li>
<li><strong>知识沉淀 (Knowledge Sedimentation)</strong>:
准备好核心的架构图、设计文档等。</li>
</ul>
<p><strong>第五步：部署、观测与效果衡量 (Deploy, Observe &amp; Measure
Effectiveness)</strong></p>
<p>将架构推向真实世界，并通过数据验证其价值。</p>
<ul>
<li><strong>持续交付 (CI/CD)</strong>:
作为将设计快速、可靠地部署到生产环境的手段。</li>
<li><strong>系统监控 (System Monitoring)</strong>:
观测系统的健康状况（CPU、内存、延迟、错误率等）。</li>
<li><strong>业务指标验证 (Business Metrics Verification)</strong>:
<strong>（闭环关键）</strong>
验证是否达成了第一步定义的商业目标？例如，新架构上线后，用户转化率是否真的提升了？</li>
</ul>
<p><strong>第六步：复盘、沉淀与演进 (Retrospect, Internalize &amp;
Evolve)</strong></p>
<ul>
<li><strong>问题记录与根因分析 (Problem Record &amp; Root Cause
Analysis)</strong>: 发生了什么？为什么会发生？</li>
<li><strong>流程与原则改进 (Process &amp; Principle
Improvement)</strong>:
如何优化我们的设计流程、技术原则，避免未来再犯？</li>
<li><strong>人员与组织成长 (Personnel &amp; Organizational
Growth)</strong>: 团队通过这次项目学到了什么？需要组织哪些培训？</li>
</ul>
<h1 id="fundamentals-of-software-architectrue-笔记梳理">Fundamentals of
Software Architectrue 笔记梳理</h1>
<blockquote>
<p>本章笔者将打散 FOSA
书中的各个知识点，并将它们贯穿在我们上面提到的整个架构设计闭环中，同时会添加一些书中没有的内容进行补充扩展。</p>
</blockquote>
<h2 id="理解商业与组织上下文">1. 理解商业与组织上下文</h2>
<blockquote>
<p>利益相关方：他们的核心诉求和期望是什么？</p>
<p>用户视角：我们要为用户解决什么核心痛点？</p>
<p>商业目标：这个项目要达成什么商业指标？</p>
<p>组织能力：我们的文化是拥抱变化还是追求稳定？团队的技术栈、技能水平和规模如何？</p>
</blockquote>
<h3 id="谈判技巧">1.1 谈判技巧</h3>
<p>FOSA
指出，架构师必须理解并驾驭企业的<strong>政治环境</strong>。几乎每一个架构决策都会受到挑战，这可能来自产品负责人、项目经理、业务利益相关方（因为成本或时间增加），甚至是开发者（认为有更好的方法）。</p>
<p>因此，架构师需要具备卓越的<strong>谈判和引导技能</strong>
(Negotiation and
Facilitation)，以理解各方诉求，并在分歧出现时达成共识。</p>
<p>FOSA 给出了几种谈判思路：</p>
<ol type="1">
<li><strong>利用语法和流行语更好地理解情况。</strong>
软件架构师应注意业务利益相关者在沟通中使用的短语和流行语。例如，像“我们需要零停机时间”或“我昨天就需要这些功能”这样的表述，虽然可能不精确，但却能揭示出对可用性或上市时间等方面的真正关注。通过利用这些“废话语法”，架构师可以更好地理解对方真正的担忧和需求，从而在谈判中占据优势。</li>
<li><strong>在进入谈判之前收集尽可能多的信息。</strong>
在谈判之前，架构师应尽可能多地收集相关信息。例如，如果业务利益相关者坚持“五个九”的可用性（99.999%），架构师应提前研究这意味着什么，并将其转化为实际的停机时间（例如，每年约
31.5
秒的计划外停机时间）。充分掌握事实和数据有助于进行基于现实的讨论。</li>
<li><strong>当一切都失败时，说明成本和时间。</strong>
这是最后的谈判策略。尽管成本和时间（投入的工作量）是任何谈判中的关键因素，但应作为最后的手段使用。过早提及这些可能会使谈判陷入僵局，因为它们可能会被视为阻止或拒绝的借口。</li>
<li><strong>利用“分而治之”的原则来限定需求。</strong>
这一策略借鉴了孙子兵法中的思想，即“其力合者，离之”。当面临不合理或范围过大的要求时（例如，整个系统都需要“五个九”的可用性），架构师可以通过提问来缩小范围，确定哪些特定部分或功能真正需要这种高水平的特性。这样做可以减少困难且昂贵需求的范围，从而简化谈判。</li>
<li><strong>永远记住演示胜于讨论。</strong>
当与同事或开发人员在技术方法上存在分歧时，与其争论不休，不如通过实际的演示来证明你的观点。例如，如果你认为消息队列比
REST 更适合特定的服务间通信，可以在模拟生产环境中进行 A/B
测试，用数据和实际结果来说服对方。实际操作的证据通常比理论争论更有说服力。</li>
<li><strong>在谈判中避免过于争辩或让事情变得过于个人化——冷静的领导力结合清晰简洁的推理总能赢得谈判。</strong>在讨论中，如果气氛变得过于激烈或个人化，最好的做法是暂停谈判，待双方冷静后再重新进行。作为领导者，保持冷静和专业的态度，并用清晰、简洁的逻辑进行推理，往往能够有效化解冲突，促使对方退让，最终达成共识。</li>
<li><strong>在说服开发人员采纳架构决策或执行特定任务时，提供理由而不是“高高在上地发号施令”。</strong>
架构师不应凭借职位来命令开发人员，而应通过提供充分的理由来说明为什么需要某个架构决策或任务。例如，解释“所有数据库调用都需要通过业务层”是为了“更好地控制变更”，这比单纯命令“你必须通过业务层”更容易被接受。理解背后的原因能促使开发人员更积极地接受并实施决策。</li>
<li><strong>如果开发人员不同意某个决策，让他们自己找到解决方案。</strong>
当开发人员对某个技术决策有异议时，与其直接反驳，不如挑战他们，让他们自己去探索并证明他们的替代方案。例如，如果开发人员坚持使用某个框架但你认为它不符合安全要求，可以让他们自行研究并展示如何解决安全问题。这不仅能促进开发人员的学习和思考，也能让架构师在最终解决方案上获得团队的认可和支持，形成双赢局面。</li>
</ol>
<h3 id="业务理解">1.2 业务理解</h3>
<p>架构决策必须<strong>提供业务价值</strong>。如果一个架构决策没有业务价值，它可能就不是一个好的决策，需要重新考虑。</p>
<p>FOSA
强调，架构决策的<strong>商业合理性</strong>至关重要。常见的商业合理性包括：<strong>成本</strong>
(Cost)、<strong>上市时间</strong> (Time to
Market)、<strong>用户满意度</strong> (User Satisfaction)
和<strong>战略定位</strong> (Strategic
Positioning)。在与业务利益相关方谈判时，要重点关注他们最看重的指标。</p>
<p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种"语言"</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。所以架构师的职责就是需要将业务领域的关注点和架构特性进行对应。</p>
<p>比如：</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr>
<th>Domain Concern</th>
<th>Architecture characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mergers and acquisitions 合并与收购</td>
<td>互操作性 interoperability<br>可扩展性 scalability<br>适配性
adaptability<br>可扩展性 extensibility</td>
</tr>
<tr>
<td>Time to market 上市时间</td>
<td>灵活性 agility<br/>可测试性 testability<br/>可部署性
deployability</td>
</tr>
<tr>
<td>User satisfaction 用户满意度</td>
<td>性能 performance<br/>可用性 availability<br/>容错性 fault
tolerance<br/>可测试性 testability<br/>可部署性 deployability<br/>灵活性
agility<br/>安全性 security</td>
</tr>
<tr>
<td>Competitive advantage 竞争优势</td>
<td>灵活性 agility<br/>可测试性 testability<br/>可部署性
deployability<br/>可扩展性 scalability<br/>可用性
availability<br/>容错性 fault tolerance</td>
</tr>
<tr>
<td>Time and budget 时间和预算</td>
<td>简单性 simplicity<br/>可行性 feasibility</td>
</tr>
</tbody>
</table>
<p>另外，
随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变。</p>
<h2 id="定义架构特性与约束">2. 定义架构特性与约束</h2>
<blockquote>
<p>识别架构特性：从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计最关键的
3-5 个。</p>
<p>明确约束条件：有哪些不可逾越的红线？</p>
</blockquote>
<h3 id="架构特性定义">2.1 架构特性定义</h3>
<p>架构师的核心职责之一就是识别和定义系统的<strong>架构特性</strong>
(Architecture
Characteristics)。这些特性定义了系统的<strong>成功标准</strong>，并且通常与系统的<strong>功能性</strong>
(Functionality) 正交。</p>
<p>一个属性要成为架构特性（Architecture Characteristics），需至少满足 3
个条件：</p>
<ol type="1">
<li><strong>指定非领域设计考量</strong>：架构特性关注的是应用程序"如何"实现需求以及做出某些选择"为何"的原因，而不是应用程序"应该做什么"的业务需求。例如，性能水平通常不会出现在需求文档中，但却是重要的架构特性。</li>
<li><strong>影响设计的某个结构方面</strong>：如果一个架构特性需要特殊结构考虑才能成功，那么它就会上升到架构特性的层面。例如，一般的安全性对于几乎所有项目都是必需的，但当需要设计特定的模块、组件或服务来隔离关键安全问题时，安全才成为一个架构特性。</li>
<li><strong>对应用程序的成功至关重要</strong>：应用程序可以支持大量的架构特性，但并非所有都应该被支持。支持每个架构特性都会增加设计的复杂性，因此，架构师的关键任务是选择最少的、对应用程序成功至关重要或重要的架构特性，而不是尽可能多的。</li>
</ol>
<h3 id="架构特性类型">2.2 架构特性类型</h3>
<ul>
<li><strong>显性架构特性</strong>：是在需求规范中明确列出的，作为必要设计的一部分。它们通常直接出现在需求文档或其他具体说明中。</li>
<li><strong>隐性架构特性</strong>：很少出现在需求文档中，但它们对于项目的成功是必需的。架构师必须利用他们对问题领域的知识，在分析阶段发现这些特征。</li>
</ul>
<p>可进一步细分为：操作特性、结构特性和交叉特性。</p>
<p>操作性架构特性涵盖了系统的<strong>运行能力</strong>，例如性能、可伸缩性、弹性、可用性和可靠性等。这些特性通常与运营和
DevOps 关注点高度重叠。</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Availability</td>
<td>系统需要保持可用的时间长度；例如，如果需要 24/7
可用，则需要采取措施确保系统始终可用。它指的是软件可操作和可访问的程度。</td>
</tr>
<tr>
<td>Continuity</td>
<td>灾难恢复能力。</td>
</tr>
<tr>
<td>Performance</td>
<td>衡量应用程序请求和响应周期所需的时间。它包括压力测试、高峰分析、功能使用频率分析、所需容量和响应时间。它也可以是更具体的度量，例如首屏渲染时间，即网页首次可见的时间。</td>
</tr>
<tr>
<td>Recoverability</td>
<td>业务连续性要求（例如，发生灾难时，系统需要多快才能重新上线？）这将影响备份策略和对复制硬件的要求。它也指软件从故障中恢复的能力，通过恢复任何受影响的数据并重新建立系统的所需状态。</td>
</tr>
<tr>
<td>Reliability/Safety</td>
<td>评估系统是否需要具备故障安全能力，或者其任务关键性是否影响生命。如果系统发生故障，是否会给公司带来巨额损失。它指系统在指定条件下和指定时间内运行的程度。</td>
</tr>
<tr>
<td>Robustness</td>
<td>在互联网连接中断、断电或硬件故障时，处理错误和边界条件的能力。</td>
</tr>
<tr>
<td>Scalability</td>
<td>系统随着用户或请求数量的增加而执行和运行的能力。这意味着处理大量并发用户而不会出现严重的性能下降。</td>
</tr>
</tbody>
</table>
<p>结构性架构特性关注<strong>代码结构</strong>。在许多情况下，架构师对代码质量问题负有独立或共同的责任，例如良好的模块化、组件间的受控耦合、可读性强的代码以及其他内部质量评估。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Configurability</td>
<td>最终用户通过可用界面轻松更改软件配置方面的能力。</td>
</tr>
<tr>
<td>Extensibility</td>
<td>系统的可扩展性。</td>
</tr>
<tr>
<td>Installability</td>
<td>系统在所有必要平台上安装的便捷性。它指软件在指定环境中安装和/或卸载的程度。</td>
</tr>
<tr>
<td>Leverageability/Reuse</td>
<td>跨多个产品利用通用组件的能力。它指开发人员在多个系统或构建其他资产中重复使用资产的程度。</td>
</tr>
<tr>
<td>Maintainability</td>
<td>开发人员修改、纠正或使其适应环境和/或需求变化的有效性和效率程度。</td>
</tr>
<tr>
<td>Portability</td>
<td>系统是否需要在多个平台上运行。它指开发人员将系统、产品或组件从一个硬件、软件或其他操作或使用环境转移到另一个环境的程度。</td>
</tr>
<tr>
<td>Supportability</td>
<td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td>
</tr>
<tr>
<td>Upgradeability</td>
<td>从该应用程序/解决方案的旧版本轻松/快速升级到新版本的能力。</td>
</tr>
</tbody>
</table>
<p>交叉架构特性指的是那些难以归类或超出传统类别，但却形成重要设计约束和考虑的特性。</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accessibility</td>
<td>确保所有用户（包括色盲或听力障碍等残障用户）能够访问系统。它指使软件可供具有最广泛特征和能力的人使用。</td>
</tr>
<tr>
<td>Archivability</td>
<td>数据是否需要在一段时间后归档或删除。</td>
</tr>
<tr>
<td>Authentication</td>
<td>确保用户是其所声称的身份的安全要求。</td>
</tr>
<tr>
<td>Authorization</td>
<td>确保用户只能访问应用程序内特定功能（按用例、子系统、网页、业务规则、字段级别等）的安全要求。</td>
</tr>
<tr>
<td>Legal</td>
<td>系统在哪些法律约束下运行（数据保护、萨班斯-奥克斯利法案、GDPR
等）？公司需要哪些保留权利？关于应用程序构建或部署方式的任何规定。</td>
</tr>
<tr>
<td>Privacy</td>
<td>隐藏内部公司员工交易信息的能力（加密交易，甚至数据库管理员和网络架构师都无法查看）。</td>
</tr>
<tr>
<td>Security</td>
<td>数据是否需要在数据库中加密？内部系统之间网络通信是否需要加密？远程用户访问需要何种类型的认证？它指软件保护信息和数据的程度，以便人员或其他产品或系统具有与其授权类型和级别相称的数据访问程度。</td>
</tr>
<tr>
<td>Supportability</td>
<td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td>
</tr>
<tr>
<td>Usability/Achievability</td>
<td>用户使用应用程序/解决方案实现目标所需的培训水平。它指用户可以有效、高效、满意地使用系统达到预期目的。</td>
</tr>
</tbody>
</table>
<h3 id="架构特性选择">2.3 架构特性选择</h3>
<p>架构特性不是越多越好：</p>
<ul>
<li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li>
<li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li>
<li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li>
<li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li>
<li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li>
<li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li>
</ul>
<p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p>
<h2 id="探索方案与决策">3. 探索方案与决策</h2>
<blockquote>
<p>探索可选方案 ：至少寻找 2-3 个备选方案。</p>
<p>进行权衡分析：基于第二步定义的架构特性优先级，系统地对比各方案的优劣。</p>
<p>评估风险：每个方案可能引入哪些短期或长期的技术、成本、人员风险？</p>
<p>记录决策：使用 ADR (Architecture Decision Record)
记录最终选择和放弃的原因。</p>
</blockquote>
<h3 id="架构风格">3.1 架构风格</h3>
<h4 id="分层架构-layered-architecture">3.1.1 分层架构 Layered
Architecture</h4>
<figure>
<img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/layer.png"
alt="3.1.1 分层架构" />
<figcaption aria-hidden="true">3.1.1 分层架构</figcaption>
</figure>
<p>分层架构的<strong>核心驱动力</strong>是<strong>关注点分离（Separation
of
Concerns）</strong>。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</p>
<p>这些层之间存在一个至关重要的约束：<strong>依赖关系是单向的</strong>。通常来说，上层可以依赖下层，但下层绝对不能依赖上层。例如，表现层可以调用业务逻辑层，但业务逻辑层不应该知道任何关于表现层的具体实现细节。</p>
<p>优点：</p>
<ul>
<li><strong>简单性（Simplicity）和低成本（Cost）</strong>：分层架构模式非常成熟，广为人知，开发团队的学习成本极低。对于中小型项目、预算有限的初创公司或内部管理系统，它是一个"足够好"的、性价比极高的起点。</li>
<li><strong>可维护性（Maintainability）</strong>：如前所述，只要遵循了隔离层原则，系统的维护和迭代会非常清晰。对于那些业务逻辑相对稳定、变更不频繁的系统，这是一个巨大的优势。</li>
<li><strong>整体可部署性（Deployability）</strong>：分层架构天然倾向于构建<strong>单体应用（Monolith）</strong>。整个应用被打包成一个单元（例如一个
WAR
包或一个可执行文件）进行部署。这极大地简化了部署和运维的复杂度，尤其是在项目早期或运维能力有限的团队中。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>技术分区而非领域分区</strong>：分层架构是一种技术分区架构。这意味着它的组件是根据其在架构中的技术角色（如表示层、业务层、持久层），而不是根据业务领域（如客户、订单）进行分组的。这会导致任何特定的业务领域（例如“客户”领域）的逻辑都会分散在架构的所有层中。同时，当需要对特定业务领域的需求进行更改时，由于其逻辑分散在多个技术层中，开发人员必须在所有相关层中进行修改，这降低了开发的敏捷性。</li>
<li><strong>部署风险高</strong>：在分层架构中，即使是对少量代码的更改（例如，一个类文件中简单的三行更改），也需要重新部署整个部署单元。这种部署往往会捆绑数十个其他更改，从而显著增加了部署风险，且部署频率受到限制。</li>
<li><strong>测试范围大且不完整</strong>：由于整个应用程序是作为一个大型单体单元部署的，开发人员通常不会为简单的三行更改花费数小时执行完整的回归测试套件。这导致测试覆盖范围不完整，并且难以确保更改不会影响看似不相关的部分。</li>
</ul>
<h4 id="管道架构-pipeline-architecture">3.1.2 管道架构 Pipeline
Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250715105907327.png"
alt="3.1.2 管道架构" />
<figcaption aria-hidden="true">3.1.2 管道架构</figcaption>
</figure>
<p>管道架构，又称为管道与过滤器架构（Pipes and Filters
Architecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</p>
<p>要理解管道架构，首先要理解它的两个基本构件：</p>
<ul>
<li><strong>过滤器
(Filter)</strong>：它是一个独立的、可执行的处理单元，负责接收数据、执行单一任务（例如转换格式、过滤内容、扩充信息），然后将处理后的数据传递出去。关键在于，每个过滤器都是<strong>自包含（Self-Contained）</strong>和<strong>无状态（Stateless）</strong>的，它不关心上一个过滤器是谁，也不关心下一个过滤器是谁。</li>
<li><strong>管道
(Pipe)</strong>：代表流水线上的"传送带"。它是一个<strong>单向</strong>的数据通道，负责将一个过滤器处理完的数据传递给下一个过滤器。</li>
</ul>
<p>过滤器一般又分为 4 种：</p>
<ul>
<li><strong>生产者 (Producer /
Source)</strong>：作为整条管道的<strong>起点</strong>。它不接收来自管道的数据，而是负责创建数据，并将这些初始数据泵入管道。</li>
<li><strong>转换器
(Transformer)</strong>：它从上游管道接收数据，对其进行某种形式的<strong>修改或转换</strong>，然后将结果发送到下游管道。</li>
<li><strong>测试器
(Tester)</strong>：它接收数据，并根据一个或多个条件对数据进行<strong>检验</strong>。如果数据满足条件，就将其传递到下游管道；如果不满足，则数据流在此处被中断（或被导向另一条错误处理管道）。</li>
<li><strong>消费者 (Consumer /
Sink)</strong>：作为整条管道的<strong>终点</strong>。它从上游管道接收最终处理好的数据，并将其消费掉，通常不会再将数据传递出去。</li>
</ul>
<p>优点:</p>
<ul>
<li><strong>成本低且简单</strong>：作为一种单体架构，管道架构不具备分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li>
<li><strong>高模块化</strong>：通过不同过滤器类型之间关注点的分离，实现了架构的模块化。任何过滤器都可以修改或替换而不影响其他过滤器。</li>
<li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，部署性和可测试性略优于分层架构，但仍受单体应用固有的部署仪式、风险和测试完整性等因素的影响。</li>
</ul>
<p>缺点:</p>
<ul>
<li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它仍然是一种单体应用。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。例如，对任何更改都需要测试和部署整个单体应用。</li>
<li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，管道架构的弹性评级非常低（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术，而管道架构并不擅长此道。</li>
<li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也评级很低。应用程序的伸缩能力受限于单一系统量子。</li>
<li><strong>性能一般</strong>：管道架构不适合高性能系统，因为它缺乏并行处理能力、存在闭合分层（closed
layering）以及可能出现"架构下沉"（sinkhole anti-pattern）问题。</li>
</ul>
<h4 id="微核架构-microkernel-architecture">3.1.3 微核架构 Microkernel
Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250716105151041.png"
alt="3.1.3 微核架构" />
<figcaption aria-hidden="true">3.1.3 微核架构</figcaption>
</figure>
<p>微核架构，也被称为<strong>插件化架构（Plug-in
Architecture）</strong>，是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的<strong>核心系统（Core
System）</strong>和一个由独立<strong>插件组件（Plug-in
Components）</strong>构成的可扩展生态。</p>
<ul>
<li><strong>核心系统 (Core
System)</strong>：这是架构的"微核"。它的职责被严格限制在最小且必要的范围内，通常只包含：
<ol type="1">
<li>系统运行所必需的通用业务逻辑（例如，一个 IDE
的文件管理和基础编辑器）。</li>
<li>一个至关重要的<strong>插件管理机制</strong>，包括插件的注册、发现、生命周期管理等。这是连接核心与插件的桥梁。</li>
</ol></li>
<li><strong>插件组件 (Plug-in
Components)</strong>：这些是独立的、可插拔的模块，用于实现<strong>扩展功能或特定业务逻辑</strong>。每个插件都通过一个由核心系统定义的<strong>标准契约（Standard
Contract）</strong>来与核心交互。这个契约通常是一个接口或一组 API。</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>高模块化与扩展性</strong>：微内核架构通过插件组件实现了高度模块化和扩展性。应用程序逻辑被划分为核心系统和独立的插件组件，从而提供了可扩展性、适应性以及应用程序特性和自定义处理逻辑的隔离。任何插件都可以修改或替换而不影响其他组件，例如，添加一个新的电子设备评估逻辑只需添加一个新的插件组件并更新注册表。</li>
<li><strong>成本较低且相对简单</strong>：作为一种单体架构，微内核架构避免了分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li>
<li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，功能可以隔离到独立的插件组件中。如果做得好，这可以减少整体测试范围并降低部署风险，尤其是在运行时部署插件组件的情况下。因此，可部署性和可测试性略优于分层架构。</li>
<li><strong>领域与架构的同构性</strong>：微内核架构可以<strong>同时进行领域分区和技术分区</strong>。对于需要针对每个位置或客户端进行不同配置的问题，或者那些强调用户定制和功能扩展性的产品（例如
Jira 或Eclipse IDE），这种架构风格非常适用。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它<strong>仍然是一种单体应用</strong>。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。</li>
<li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，微内核架构的<strong>弹性评级非常低</strong>（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术。</li>
<li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也<strong>评级很低</strong>（一星）。所有请求都必须<strong>通过核心系统才能到达独立的插件组件</strong>。</li>
</ul>
<h4 id="基于服务的架构-service-based-architecture">3.1.4 基于服务的架构
Service-Based Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250717114456233.png"
alt="3.1.4 基于服务的架构 SBA" />
<figcaption aria-hidden="true">3.1.4 基于服务的架构 SBA</figcaption>
</figure>
<p>如果说单体（Monolith）和微服务（Microservices）是两个广为人知的端点，那么基于服务的架构（Service-Based
Architecture,
SBA）就是它们之间那个常常被忽略，却又极具现实意义的"务实中间派"。它既非庞大到笨拙，也非精细到繁杂，为许多成长中的系统提供了一条平滑的演进路径。</p>
<p>SBA
的本质是一种将一个大型的单体应用，<strong>分解为少数几个、逻辑独立的、可独立部署的"服务"</strong>
的架构风格。SBA 的服务数量通常不多，一般在 <strong>4 到 12
个</strong>之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照<strong>核心的业务领域（Domain）</strong>进行划分。</p>
<p>与微服务不同的是 SBA
的典型实现是，所有服务共享<strong>同一个数据库</strong>。这种设计的初衷是为了在享受独立部署带来的好处的同时，最大限度地<strong>降低数据层面的复杂性</strong>。共享数据库可以：</p>
<ul>
<li><strong>简化开发</strong>：开发者无需处理复杂的分布式事务和跨服务数据同步问题。</li>
<li><strong>保证数据一致性</strong>：传统的 ACID
事务可以在数据库层面轻松实现。</li>
<li><strong>降低技术门槛</strong>：团队无需掌握复杂的分布式数据管理技术。</li>
</ul>
<p>随着业务发展，共享数据库的弊端会逐渐显现。在以下情况下，拆分数据库就成了合理的选择：</p>
<ol type="1">
<li><strong>服务资源争用 (Service
Contention)</strong>：某个服务（如高流量的商品浏览服务）对数据库产生巨大压力，影响了其他关键服务（如订单服务）的性能。</li>
<li><strong>数据隔离与安全 (Data Isolation and
Security)</strong>：某个服务处理的数据高度敏感（如支付服务中的金融信息），需要从主数据库中物理隔离出来，以满足合规性或安全要求。</li>
<li><strong>技术栈不匹配 (Technology
Mismatch)</strong>：某个服务有特殊的数据存储需求。例如，搜索服务最适合使用
Elasticsearch，而核心业务数据则存储在关系型数据库中。</li>
</ol>
<p>当这些情况发生时，SBA
允许你"渐进式"地将某个服务连同其数据一起剥离出去，赋予它独立的数据库。</p>
<p>优点：</p>
<ul>
<li><strong>可部署性
(Deployability)</strong>：这是最大的优势之一。每个服务都可以独立部署，使得发布更加频繁、风险更低。</li>
<li><strong>模块化
(Modularity)</strong>：通过按领域划分服务，实现了清晰的业务模块边界。</li>
<li><strong>可维护性
(Maintainability)</strong>：每个服务的代码库规模远小于整个单体，更易于理解、修改和维护。</li>
<li><strong>容错性 (Fault
Tolerance)</strong>：一个服务的崩溃不会导致整个应用程序宕机（尽管共享数据库可能成为共同的故障点）。</li>
<li><strong>保留ACID事务</strong>：这是其相对于其他细粒度分布式架构（如微服务）的一大优势。由于领域服务是粗粒度的，事务通常限制在一个服务内部，可以利用传统的
ACID 事务来保证<strong>数据完整性和一致性</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>弹性低</strong>：尽管可以在单体内部实现某些功能的伸缩，但由于其单体部署和缺乏架构模块化，弹性评级仍然较低。</li>
<li><strong>可伸缩性受限</strong>：虽然可以扩展，但由于服务粒度较粗，与微服务等细粒度服务相比，在机器资源方面效率不高，成本效益也较低。</li>
<li><strong>部署风险</strong>：虽然比传统单体应用有所改进，但由于部署的代码量仍然较大，其<strong>部署风险</strong>仍然高于微服务架构。</li>
</ul>
<h4 id="事件驱动架构-event-driven-architecture">3.1.5 事件驱动架构
Event-Driven Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718110824820.png"
alt="3.1.5 事件驱动架构" />
<figcaption aria-hidden="true">3.1.5 事件驱动架构</figcaption>
</figure>
<p>在传统的<strong>请求驱动模型</strong>中，系统接收请求后会确定性地、同步地将请求路由到各个请求处理器来处理数据。而事件驱动模型则不同，它<strong>对特定情况做出反应，并根据该事件采取行动</strong>。</p>
<p>EDA 的力量源泉来自于异步通信，它有以下优点：</p>
<ol type="1">
<li><strong>极高的系统韧性与可用性 (Resiliency and
Availability)</strong>：在同步调用中，如果服务 B 宕机，服务 A
的调用会立刻失败，导致整个链路中断。但在异步模式下，服务 A
将事件发送给一个中间人（消息代理），然后就可继续自己的工作。即使服务 B
此时宕机，事件也会被安全地存放在代理中，待 B
恢复后再进行处理。这使得系统能够优雅地处理局部故障，整体可用性大大提高。</li>
<li><strong>卓越的可伸缩性与弹性 (Scalability and
Elasticity)</strong>：生产者和消费者被完全解耦，可以独立进行伸缩。如果事件产生的速度突然加快，我们只需要增加消费者实例的数量即可，而无需对生产者做任何改动。这种按需、独立伸缩的能力是构建高弹性系统的关键。</li>
</ol>
<p>典型的 EDA 有 2
种拓扑，分别为代理模式（broker）和中介者模式（mediator），二者最大的区别在于后者具有一个统一的协调者，这会对异常处理、全局统筹有很好的管控手段，当同时也牺牲了系统的解耦程度、灵活度和性能。</p>
<p>在 EDA 中，有几个典型的问题需要关注：</p>
<ul>
<li><p><strong>异常处理</strong>：可采用 workflow event pattern
工作流事件模式。事件处理后，如果失败了，就告知
<code>workflow process</code>。<code>workflow processor</code>
识别错误，如果能自动处理，就自动处理，并丢回原始队列中，重新执行。如果不能处理，就放到
dashbord 上，人工检查、校正或重试。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163511396.png"
alt="workflow event pattern 工作流事件模式" />
<figcaption aria-hidden="true">workflow event pattern
工作流事件模式</figcaption>
</figure></li>
<li><p><strong>数据丢失</strong>：发送事件到 channel 的路上、channel
转发事件到处理器的路上和处理器处理完持久化到 db
的路上都有可能发生数据的丢失。可以通过同步发送、持久化队列、ACK
机制和事务型 DB 来解决这个问题。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163644273.png"
alt="防止 EDA 数据丢失的思路" />
<figcaption aria-hidden="true">防止 EDA 数据丢失的思路</figcaption>
</figure></li>
<li><p><strong>返回响应</strong>：如果希望在事件驱动架构中实现请求-响应的能力，可以消息的两个元数据字段：<strong>回复地址
(Reply-To)</strong> 和 <strong>关联标识 (Correlation ID)</strong>
来通过回传通道返回响应数据。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718132839093.png"
alt="EDA 返回响应数据的处理思路" />
<figcaption aria-hidden="true">EDA 返回响应数据的处理思路</figcaption>
</figure></li>
</ul>
<p>优点：</p>
<ul>
<li><strong>可伸缩性与弹性 (Scalability &amp;
Elasticity)</strong>：独立伸缩组件的能力是其核心优势。</li>
<li><strong>可扩展性
(Extensibility)</strong>：系统极易扩展。当需要增加新功能时，只需开发一个新的服务来订阅感兴趣的现有事件即可，完全无需改动已有服务。</li>
<li><strong>响应性
(Responsiveness)</strong>：对于需要快速响应用户的系统，可以将耗时任务异步化。例如，用户提交视频后，系统立即返回"上传成功，正在处理中"，然后通过事件驱动后台的转码、审核等一系列复杂流程。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>简单性 (Simplicity)</strong>：EDA
显著增加了系统的复杂性。你需要管理消息代理，处理异步编程的挑战（如调试、错误处理），并应对最终一致性带来的心智负担。</li>
<li><strong>事务性
(Transactional)</strong>：实现跨多个服务的原子性操作（即分布式事务）变得异常困难。虽然可以通过
Saga
等模式来模拟长事务，但其实现复杂，且只能保证最终一致性而非强一致性。</li>
<li><strong>工作流的可观测性 (Observability of
Workflow)</strong>：尤其是在代理拓扑中，业务流程被分散到各个独立的处理器中，没有一个集中的地方可以让你直观地看到一个完整的业务流程是如何执行的，这给监控和排错带来了巨大挑战。</li>
</ul>
<h4 id="空间架构-space-based-architecture">3.1.6 空间架构 Space-Based
Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250721175147426.png"
alt="3.1.6 空间架构" />
<figcaption aria-hidden="true">3.1.6 空间架构</figcaption>
</figure>
<p>传统三层 Web 拓扑在用户量剧增时呈倒三角：Web
层易横向扩容，数据库层最难扩容，最终成为性能上限。为削弱数据库瓶颈，业界先用本地缓存，再出现集中式分布式缓存，但网络跳转仍是热点。把数据直接放到每个处理节点的
<strong>复制型内存网格</strong>
并实时同步，才真正让数据库从"同步路径"上消失，空间架构由此成形。</p>
<p>空间架构的名称来源于<strong>元组空间（Tuple
Space）</strong>多个并行处理器通过共享内存进行通信。SBA
的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（Processing
Units）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</p>
<p>空间架构由以下几个部分组成：</p>
<ul>
<li><p><strong>处理单元 Processing Unit：</strong></p>
<ul>
<li><p>处理单元包含了<strong>应用逻辑</strong>（包括基于 Web
的组件和后端业务逻辑）。</p></li>
<li><p>它还包含一个<strong>内存数据网格</strong>和<strong>复制引擎</strong>，通常由
Hazelcast、Apache Ignite 或 Oracle Coherence 等产品实现。</p></li>
<li><p>处理单元可以包含小型、单一用途的服务，类似于微服务</p></li>
</ul></li>
<li><p><strong>虚拟化中间件 Virtualized
Middleware：</strong>虚拟化中间件负责处理架构中的基础设施问题，控制数据同步和请求处理。它由以下四个关键组件组成：</p>
<ul>
<li><p><strong>消息网格（Messaging
Grid）</strong>：它负责将请求转发到任何可用的处理单元。</p></li>
<li><p><strong>数据网格（Data Grid）</strong>：它是 SBA
中最重要和关键的组件，通常在处理单元内部以复制缓存的形式实现。它确保每个处理单元都包含完全相同的数据，数据复制是异步且快速的。</p></li>
<li><p><strong>处理网格（Processing
Grid）</strong>：这是一个可选组件，用于管理<strong>协调请求处理</strong>，当一个业务请求涉及多个处理单元时，它会协调这些处理单元之间的请求。</p></li>
<li><p><strong>部署管理器（Deployment
Manager）</strong>：该组件根据负载条件管理处理单元实例的<strong>动态启动和关闭</strong>，对于实现应用的弹性伸缩至关重要。</p></li>
</ul></li>
<li><p><strong>数据泵 Data
Pumps：</strong>数据泵是<strong>将数据发送到另一个处理器，然后该处理器更新数据库</strong>的方式。它们总是<strong>异步</strong>的，提供内存缓存与数据库之间的<strong>最终一致性（Eventual
Consistency）</strong>。消息机制是数据泵的常用实现方式，因为它支持异步通信、保证消息传递和维护消息顺序。</p></li>
<li><p><strong>数据写入器 Data Writers：</strong>数据写入器（Data
Writers）负责接收来自数据泵的消息，并用消息中包含的信息更新数据库。它们可以是服务、应用或数据中心（如
Ab
Initio）。写入器的粒度可以根据数据泵和处理单元的范围而变化，例如，领域驱动的数据写入器可以处理特定领域（如客户）内的所有更新。</p></li>
<li><p><strong>数据读取器 Data
Readers：</strong>负责从数据库读取数据，并通过反向数据泵将其发送到处理单元。服务需要通过数据读取器访问数据的情况有三种：</p>
<ol type="1">
<li>所有相同命名缓存的处理单元实例都崩溃时。</li>
<li>所有相同命名缓存的处理单元需要重新部署时。</li>
<li>需要检索复制缓存中不包含的归档数据时。</li>
</ol></li>
</ul>
<p>空间架构最大的一个问题就是<strong>数据冲突</strong>，不同的
processing unit
处理同一个业务逻辑相关的数据时，由于数据同步存在时序问题，所以很容易出现数据不一致的情况。</p>
<p>可以从以下几个因素进行冲突概率的评估：</p>
<ul>
<li>N：处理相同缓存的 processing unit 的数量</li>
<li>UR：缓存更新频率</li>
<li>S：缓存大小</li>
<li>RL：缓存复制的延迟</li>
</ul>
<blockquote>
<p>CollisitionRate = N × (UR<sup>2</sup>/S) × RL</p>
</blockquote>
<p>如果估算出来的冲突概率无法接受，或者需要缓存在内存中的业务数据过多而超过单机负载时，也可以使用<strong>分布式缓存</strong>来替代复制缓存。</p>
<p>优点：</p>
<ul>
<li><strong>弹性（Elasticity）</strong>：处理单元可以根据负载动态启停，实现高度弹性。</li>
<li><strong>伸缩性（Scalability）</strong>：通过内存数据缓存和移除数据库约束，支持处理数百万并发用户。</li>
<li><strong>性能（Performance）</strong>：移除了数据库瓶颈，提供了极高的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>简洁性（Simplicity）</strong>：SBA
是一种<strong>非常复杂的架构风格</strong>，因为它涉及到缓存、最终一致性以及众多动态组件。</li>
<li><strong>可测试性（Testability）</strong>：由于需要模拟极高的伸缩性和弹性负载，<strong>测试复杂且成本高昂</strong>，许多高负载测试甚至需要在生产环境中进行，带来巨大风险。</li>
<li><strong>成本（Cost）</strong>：由于缓存产品许可费和高资源利用率，SBA
通常相对昂贵。</li>
</ul>
<h4
id="面向服务架构-orchestration-driven-service-oriented-architecture">3.1.7
面向服务架构 Orchestration-Driven Service-Oriented Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250722110031795.png"
alt="3.1.7 面向服务架构" />
<figcaption aria-hidden="true">3.1.7 面向服务架构</figcaption>
</figure>
<p>编排驱动的面向服务架构（Orchestration-Driven Service-Oriented
Architecture，简称
SOA）是一种在特定时代背景下演变而来的软件架构风格。它在 20 世纪 90
年代末企业快速扩张、需要更复杂的 IT 系统来适应增长的背景下出现。</p>
<ul>
<li><strong>资源稀缺性</strong>：在开源操作系统尚未被认为足够可靠用于严肃工作之前，操作系统和商业数据库服务器的许可费用昂贵且按机器收费。这导致架构师们被要求尽可能地实现<strong>重用</strong>，以优化成本。</li>
<li><strong>企业级重用</strong>：SOA
的一个主要目标是实现服务层面的重用，即逐步构建可随时间增量重用的业务行为。大型公司厌倦了重复编写软件，因此采取了逐步解决这个问题的策略。</li>
<li><strong>技术分层</strong>：这种架构风格也将<strong>技术分层</strong>理念推向了极致。其驱动哲学围绕着企业级的重用展开。</li>
</ul>
<p>这个架构在历史进程中是一个反面教材，它的核心思想就俩字：<strong>复用</strong>！</p>
<p>失败的最核心原因：过度重视技术，以技术为导向进行模块划分和复用尝试，而业务是不断演进变化的，最终技术与业务之间的隔阂无法弥补，功亏一篑。</p>
<p>其他原因还有：</p>
<ul>
<li>过度追求复用导致的高度耦合</li>
<li>编排引擎成为巨大的耦合点和瓶颈</li>
<li>技术分区带来的业务流程碎片化</li>
</ul>
<h4 id="微服务架构-microservice-architecture">3.1.8 微服务架构
Microservice Architecture</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111539943.png"
alt="3.1.8 微服务架构" />
<figcaption aria-hidden="true">3.1.8 微服务架构</figcaption>
</figure>
<p>微服务架构的核心在于<strong>高度解耦</strong>。它<strong>倾向于复制而非耦合</strong>。这意味着，如果架构师的目标是高度解耦，那么他们会选择复制而不是重用。微服务通过物理上建模限界上下文（Bounded
Context）的逻辑概念来实现高度解耦。</p>
<p>限界上下文（Bounded
Context）是微服务设计理念的核心驱动力。这是一个源于领域驱动设计（DDD）的概念。限界上下文代表了一种<strong>解耦</strong>风格。在限界上下文内，与特定领域相关的所有内部组件（如代码和数据库模式）都是紧密耦合的，但它们与外部限界上下文的任何内容（如其他数据库或类定义）是<strong>解耦</strong>的。</p>
<p>这种隔离使得每个服务可以<strong>独立演进</strong>，定义其自身所需的一切，而不必适应其他部分的约束。它<strong>避免了传统单体架构中常见的共享类和数据库作为集成点导致的紧密耦合问题</strong>。</p>
<p>所以微服务也是一个典型的领域分区架构，并且它倾向于将领域分区推到极致。</p>
<p>在划分微服务粒度时，以下三个方面是需要重点考虑的：</p>
<ol type="1">
<li><strong>目的（Purpose）</strong>：微服务的首要目的应该是<strong>捕获一个领域或工作流</strong>。理想情况下，每个微服务都应该具有<strong>极高的功能内聚性</strong>，为整个应用程序贡献一个<strong>重要的行为</strong>。这意味着，服务应该专注于一个单一的、明确的业务功能。</li>
<li><strong>事务（Transactions）</strong>：限界上下文是业务工作流，通常需要<strong>在事务中协作的实体</strong>可以为服务边界提供良好的指示。由于分布式事务在分布式架构中会带来复杂性，架构师应尽量设计系统以<strong>避免跨服务的事务</strong>。如果需要跨服务事务，这可能表明服务粒度过细。事务边界通常是服务粒度的常见指标。</li>
<li><strong>通信（Communication）</strong>：如果一组服务为了完成功能而需要<strong>大量通信</strong>，那么将这些服务捆绑成一个更大的服务可能有助于<strong>避免过度的通信开销</strong>。换句话说，如果服务变得过于“多话”（chatty），频繁地相互调用，那么它们的边界可能需要重新评估，以减少不必要的<strong>全局复杂性</strong>。</li>
</ol>
<p>此外，业界也有一些其他的常用的判断方法：</p>
<ol type="1">
<li><strong>变更频率</strong>：把一起变更/部署的东西放在一个服务，频率不同的拆开。</li>
<li><strong>耦合指标</strong>：如果拆分后跨服务调用暴增，说明拆太细；反之，如果内部复杂度过高且团队协作困难，可能太粗。</li>
<li><strong>认知负荷</strong>：一个团队能完全理解并独立维护的范围通常就是一个合理服务边界。</li>
</ol>
<p>在微服务架构中，有几个典型的问题需要关注：</p>
<ul>
<li><p><strong>基础设施复用</strong>：虽然微服务倾向于复制而非耦合，不过这更多是在业务层面，对于运维层面的基础设施，包括但不限于：<strong>监控（Monitoring）</strong>、<strong>日志记录（Logging）</strong>、<strong>断路器（Circuit
Breakers）</strong>和<strong>服务发现（Service
Discovery）</strong>，微服务是主张进行统一建设和复用的。</p></li>
<li><p><strong>服务协作方式</strong>：一般有编舞和编排 2
种协作方式：</p>
<ul>
<li><strong>编舞（Choreography）</strong>：是指多个服务<strong>相互之间直接通信</strong>，而<strong>没有中央协调器</strong>。服务（如同舞者）根据彼此发出的事件或信息自主响应和行动。</li>
<li><strong>编排（Orchestration）</strong>：是指通过一个<strong>单独的协调器服务</strong>来管理和控制工作流中多个服务的协调。协调器（如同乐队指挥）负责指导每个服务的执行顺序，并处理整个业务流程的状态和错误。在微服务中，架构师可以创建<strong>局部化的协调器服务</strong>来处理复杂的业务流程。</li>
</ul>
<p>微服务两者都支持。
不过编舞方式更符合微服务的高度解耦哲学，因为它不依赖于中央协调器，而是通过解耦的事件来实现通信，使用起来更简便。当然，在复杂的业务流程中，<strong>编舞环境下的错误处理和协调会变得更加复杂</strong>。如果业务流程<strong>本质上是耦合的</strong>，此时编排可能更为适合。</p></li>
<li><p><strong>数据一致性：</strong>微服务主张尽可能避免分布式事务的问题，如果多个服务经常需要处理分布式事务问题，那最好将它们合而为一，直接在一个
ACID 事务中完成。在万不得已的时候，也可以采用如 saga
和最终一致性、人工补偿等方式来缓解数据一致性问题。</p></li>
</ul>
<p>优点：</p>
<ul>
<li><strong>高度解耦与小部署单元</strong>：微服务架构极力推崇<strong>高度解耦</strong>。每个服务都是<strong>极小的部署单元</strong>，且具备<strong>高度的独立性</strong>。这种解耦使得团队可以独立地开发、测试和部署服务，大大减少了对其他服务的依赖，从而提高了敏捷性。</li>
<li><strong>DevOps 革命与自动化</strong>：微服务架构的成功离不开
<strong>DevOps
革命和对操作关注点的自动化</strong>。自动化部署、自动化测试等现代工程实践是微服务存在的基础，它们极大地提高了部署频率、降低了部署风险，并保证了测试的完整性。</li>
<li><strong>更快的变更响应速度</strong>：由于服务范围小且高度解耦，当业务需求发生变化时，团队只需修改受影响的少量服务，而不是整个大型单体。这种<strong>增量式的演进</strong>能力使得组织能够<strong>更快地响应市场变化，提高时间到市场（time-to-market）的速度</strong>。</li>
<li><strong>单一职责与清晰边界</strong>：每个微服务都专注于一个<strong>单一的业务功能或领域</strong>。这种清晰的职责边界使得开发人员更容易理解、测试和维护代码，因为他们不必处理与服务无关的复杂性</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>网络调用开销（Network Call
Overhead）</strong>：微服务是分布式架构。这意味着服务之间（乃至用户界面与服务之间）的通信需要通过网络进行。网络调用比本地方法调用耗时更长。当一个业务请求需要链式调用多个微服务时，累积的网络延迟会显著影响整体响应时间。</li>
<li><strong>安全验证开销（Security Verification
Overhead）</strong>：在微服务架构中，由于每个服务都是独立的部署单元，因此每个服务端点都需要进行安全验证。这增加了额外的处理时间。这种“在每个入口处进行安全检查”的模式进一步降低了同步、高度分布式架构（如微服务）的性能。</li>
<li><strong>高复杂性（Complexity）</strong>：作为一种分布式架构，微服务固有的缺点在于运行时连接各个部分所带来的复杂性，为了解决由此带来了一系列问题，需要学习、使用甚至开发一系列的组件，会给团队带来更大的心智负担和运维难度。</li>
<li><strong>数据一致性（Data
Consistency）</strong>：如上所述，但无法避免分布式事务时，为了处理数据一致性问题，会引入很大的非业务复杂性。</li>
</ul>
<h3 id="架构选择">3.2 架构选择</h3>
<p>软件架构第一原理：<font color="red"><strong>一切都是权衡</strong></font>。</p>
<p>软件架构第二原理：<font color="red"><strong>为什么比如何更重要</strong></font>。</p>
<p>在选择架构时，最典型的 3 个问题：</p>
<ol type="1">
<li>单体还是分布式架构？</li>
<li>数据存在哪里？</li>
<li>异步还是同步通信？</li>
</ol>
<h4 id="单体-vs-分布式">3.2.1 单体 vs 分布式</h4>
<p>当团队规模有限、需求节奏温和，而且必须尽快交付可用版本时，单体依旧是上市速度最快且认知成本最低的形态：所有模块共用同一进程，Debug、部署、回滚都异常直接。</p>
<p>然而，随着业务子域越来越多、发布节奏愈发碎片化，巨石应用往往演变成"所有人都必须一起上线或一起停机"的瓶颈。此时把系统拆成若干服务，允许各自独立发布，能显著缓解排期冲突；同时也可以针对流量热点的子域单独扩容，而非整包扩容。</p>
<p>带来的复杂度在于网络调用、链路追踪、容错和 DevOps
自动化，一旦这些配套不到位，分布式的优势就会被运维复杂度和认知成本抵消。换言之，拆分前要先确认组织是否具备持续交付、自动化监控、故障演练等能力，否则分布式只会把"技术债"换成"组织债"。</p>
<h4 id="数据存储">3.2.2 数据存储</h4>
<p>如果系统只处理核心交易并且对强一致性要求极高，一体化的关系数据库依旧能提供最成熟、最易掌控的事务保障。随着并发数和存储量攀升，分库分表成为横向扩展的常规做法，但需要额外的分布式事务模式或
Saga 来保证业务完整性。</p>
<p>如果读写模式呈现极强的峰谷或结构多变，就非常适合引入键值、文档、列式乃至时序、图数据库等多模型共存策略。这样做的关键在于为每一类数据访问场景挑选最经济的存储形式，同时在数据治理层面清晰定义数据主权、法务合规和生命周期。</p>
<h4 id="同步-vs-异步">3.2.3 同步 vs 异步</h4>
<blockquote>
<p><strong>一般原则：优先使用同步通信，必要时使用异步通信。</strong></p>
</blockquote>
<p><strong>同步调用</strong>（如 REST 或
gRPC）带来的是即时反馈和易于调试的调用链，适用于用户交互需要立刻响应的场合。然而它也拉高了两个服务在时间维度上的耦合：只要任意环节超时或故障，整个链路都会受影响。</p>
<p><strong>异步消息</strong>则通过中间件把调用方与被调用方解耦，让系统可以削峰填谷并获得天然的弹性缓冲区；代价是业务体验不再“即时”，而且需要额外处理幂等、重复消费、消息顺序、死信等问题。通常情况下，读取或修改单一资源这一类“命令/查询”仍倾向同步；任务排队、事件通知、工作流编排与数据集成则更适合异步。若核心场景必须保证强一致性，仍可采用同步事务或锁；而能够容忍短暂的不一致时，则转而采用事件驱动的最终一致模式。</p>
<h3 id="风险评估">3.3 风险评估</h3>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725170843538.png"
alt="架构风险评估矩阵" />
<figcaption aria-hidden="true">架构风险评估矩阵</figcaption>
</figure>
<p><strong>风险的影响面（Impact）</strong>：这个维度主要评估一旦风险发生，会对系统、业务、用户产生多大程度的负面影响。</p>
<ul>
<li><strong>低影响（Low）：</strong>
影响范围小，可控性强。例如，某个非核心模块的性能略有下降，只影响少量用户，且有明确的降级方案。或者，故障恢复时间短，对整体业务影响微乎其微。</li>
<li><strong>中影响（Medium）：</strong>
影响范围较大，但可控。例如，系统某个核心功能出现短暂不可用，影响部分用户，但可以通过人工干预或备用方案快速恢复。业务运营会受到一定影响，但不会造成灾难性的损失。</li>
<li><strong>高影响（High）：</strong>
影响范围广，失控性强。例如，系统核心服务大面积宕机，导致业务全面停止。或者，数据出现严重损坏，造成不可挽回的损失。</li>
</ul>
<p><strong>风险出现的可能性（Likelihood）</strong>：这个维度主要评估风险发生的概率。</p>
<ul>
<li><strong>低可能性（Low）：</strong>
发生概率很小。例如，系统依赖的某个成熟、稳定的第三方服务，过去几年从未出现过故障。或者，经过充分的测试和验证，某个技术方案的潜在问题已经被基本排除。</li>
<li><strong>中可能性（Medium）：</strong>
发生概率一般。例如，某个新技术或新组件，虽然经过了小规模测试，但在大规模生产环境下的表现还未得到充分验证。或者，架构依赖的某个外部系统，其
SLA（服务等级协议）历史记录显示偶尔会出现短暂的抖动。</li>
<li><strong>高可能性（High）：</strong>
发生概率很高。例如，在高峰期对数据库进行无主键大批量更新操作，必然会导致锁表和性能问题。或者，系统设计存在明显的单点故障，一旦该节点出现问题，整个系统就会瘫痪。</li>
</ul>
<p>在分析时，不要企图一次性对所有的架构特性进行分析，拆开了，逐一击破，避免一次性关注点太多，从而不知所向。</p>
<h3 id="架构决策">3.4 架构决策</h3>
<h4 id="anti-pattern1-covering-your-assets">3.4.1 Anti-Pattern1:
Covering Your Assets</h4>
<blockquote>
<p>害怕承担责任，总是希望有更高级别的人来拍板。决策过程变得极其缓慢，甚至为了规避风险而选择最保守、最平庸的技术方案，而不是最合适的方案。</p>
</blockquote>
<p>应对方案：</p>
<ul>
<li><strong>Fact（事实）:</strong>
聚焦于客观事实和数据。在做技术选型或架构决策时，不要只凭感觉或经验，而是要基于事实，如性能测试报告、技术预研结果、业界最佳实践、开源社区活跃度等。当所有人都基于事实说话时，决策的对错就更容易被评估和追溯，而非个人责任。</li>
<li><strong>Options（可选方案）:</strong>
明确列出所有可行的备选方案，并分析它们的优缺点、成本、风险和收益。当一个决策有多个清晰的选项时，团队可以共同讨论和权衡，而不是只盯着一个保守方案不放。</li>
</ul>
<p>实践建议：</p>
<ul>
<li><strong>建立决策评审机制：</strong> 明确谁是最终的决策者（DRI -
Directly Responsible
Individual），并设立评审环节。评审会上，每个人都应基于数据和事实来论证自己的观点。</li>
<li><strong>鼓励小步快跑和 PoC：</strong>
对于有争议的技术方案，可以先用小规模的
PoC（概念验证）项目来验证其可行性。用实际结果说话，而不是让大家停留在理论争辩。</li>
</ul>
<h4 id="anti-pattern2-groundhog-day">3.4.2 Anti-Pattern2: Groundhog
Day</h4>
<blockquote>
<p>团队成员在每次会议上都重复同样的讨论，无法达成共识。由于没有明确的决策记录或决策依据，导致下一次讨论又回到原点。</p>
</blockquote>
<p>应对方案：</p>
<ul>
<li><strong>Subject（主题）:</strong>
在每次讨论前，都必须有一个明确的、聚焦的
<strong>Subject</strong>。这次会议要讨论什么？目标是什么？是决定数据库选型？还是讨论消息队列的方案？有了明确的主题，才能避免讨论跑偏。</li>
<li><strong>Decision（决策）:</strong> 讨论结束后，必须得出一个明确的
<strong>Decision</strong>。决策是什么？为什么做出这个决策？这个决策有哪些局限性？明确记录下来，并让所有人都知晓。</li>
</ul>
<p>实践建议：</p>
<ul>
<li><strong>会议纪要：</strong>
每次关键的架构讨论后，都必须有正式的会议纪要。纪要中要包含：<strong>讨论主题、所有备选方案、最终决策、决策依据以及未被采纳方案的理由</strong>。</li>
<li><strong>设立时间限制：</strong>
在讨论时，可以为每个议题设定一个时间限制。如果超过时间仍无法达成一致，可以先暂停，让大家会后去搜集更多数据，再进行下一轮讨论。</li>
</ul>
<h4 id="anti-pattern3-email-driven-architecture">3.4.3 Anti-Pattern3:
Email-Driven Architecture</h4>
<blockquote>
<p>重要的架构决策都散落在团队成员的邮件、聊天记录或者 Wiki
的各个角落，没有一个集中的、可检索的知识库。当新成员加入或需要回顾历史决策时，很难找到完整的信息。</p>
</blockquote>
<p>应对方案：</p>
<ul>
<li><strong>Subject（主题） 和 Decision（决策）:</strong>
这两个元素是解决这个问题的核心。架构决策不应该只是一个口头或邮件的结论，而是一个完整的
<strong>ADR（Architecture Decision Record）</strong>。ADR
本身就是一个以主题和决策为核心的文档。</li>
</ul>
<p>实践建议：</p>
<ul>
<li><strong>建立 ADR 制度：</strong> 强烈建议引入 ADR 机制。</li>
<li><strong>使用统一的知识管理平台：</strong> 将所有 ADR
存放在一个统一的、可检索的知识管理平台（如飞书文档, Wiki 或
Git）。这样，团队成员可以轻松地查阅历史决策，新成员也能快速理解系统的演进过程。</li>
</ul>
<h4 id="架构决策记录-adr">3.4.4 架构决策记录 ADR</h4>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/fosa-adr.png" alt="架构决策记录 ADR" style="zoom:33%;" /></p>
<p><strong>TITLE（标题）</strong></p>
<ul>
<li><strong>解释：</strong> 标题应该简短、清晰地描述这个 ADR
的核心决策是什么。</li>
<li><strong>示例：</strong> "使用 RabbitMQ 替代 Kafka 作为消息队列" 或
"将数据库从 MySQL 切换到 PostgreSQL"。</li>
<li><strong>作用：</strong>
让读者一眼就能明白这份文档的主题。一个好的标题本身就包含了
<strong>Subject</strong>。</li>
</ul>
<p><strong>STATUS（状态）</strong></p>
<ul>
<li><strong>解释：</strong> ADR 的生命周期状态。通常包括以下几种：
<ul>
<li><strong>Proposed（提案中）：</strong>
决策还在讨论阶段，尚未被团队接受。</li>
<li><strong>Accepted（已接受）：</strong>
决策已经通过，可以开始实施。</li>
<li><strong>Superseded（已废弃）：</strong> 这个决策已经被新的 ADR
替代。这对于追踪架构演变历史非常重要。这样要<u><strong>链接到新的
ADR</strong></u>，方便追溯！</li>
</ul></li>
<li><strong>作用：</strong>
帮助团队成员了解该决策的当前状态，避免对过时或仍在讨论中的方案产生误解。</li>
</ul>
<p><strong>CONTEXT（背景）</strong></p>
<ul>
<li><strong>解释：</strong>
为什么要做出这个决策？它试图解决什么问题？这里应该详细描述问题的来龙去脉、约束条件以及技术或业务驱动因素。</li>
<li><strong>示例：</strong> "我们现有的系统在处理高并发订单时，MySQL
数据库的写入性能出现了瓶颈，导致订单处理延迟。"</li>
<li><strong>作用：</strong> 提供决策的
<strong>Fact</strong>（事实），让读者理解决策背后的原因，而不是孤立地看待决策本身。</li>
</ul>
<p><strong>DECISION（决策）</strong></p>
<ul>
<li><strong>解释：</strong>
明确描述最终的决策是什么，并给出相应的理由。这个部分是整个 ADR
的核心。</li>
<li><strong>示例：</strong>
"我们决定将订单处理服务从同步调用改为异步消息队列。备选方案是采用
Kafka，但我们最终选择了 RabbitMQ，原因是 RabbitMQ
具有更完善的路由机制和更稳定的交付保障，更适合我们对消息可靠性的高要求。"</li>
<li><strong>作用：</strong> 记录决策的 <strong>Decision</strong> 和
<strong>Options</strong>。它清晰地表明我们做了什么选择，以及为什么没有选择其他方案。</li>
</ul>
<p><strong>CONSEQUENCES（影响）</strong></p>
<ul>
<li><strong>解释：</strong>
这个决策会带来什么后果？包括积极的和消极的。</li>
<li><strong>示例：</strong>
<ul>
<li><strong>积极影响：</strong>
"订单处理性能将得到显著提升，系统的可扩展性增强。"</li>
<li><strong>消极影响：</strong> "引入 RabbitMQ
会增加运维复杂性，团队需要学习新的技术栈。需要额外投入人力进行开发和部署。"</li>
</ul></li>
<li><strong>作用：</strong>
帮助团队全面评估决策的利弊，提前预见潜在的风险和挑战。这与我们之前讨论的风险评估中的「风险的影响面」有异曲同工之妙。</li>
</ul>
<p><strong>COMPLIANCE（遵循）</strong></p>
<ul>
<li><strong>解释：</strong>
如何确保团队会遵循这个决策？这个部分更多是关于实践和治理。</li>
<li><strong>示例：</strong> "新开发的订单服务必须通过 RabbitMQ
进行异步通信。代码评审时，需要检查是否遵守此规范。运维团队需要负责
RabbitMQ 集群的部署和监控。"</li>
<li><strong>作用：</strong>
将抽象的决策转化为具体的行动和规范，确保决策能够真正落地。</li>
</ul>
<p><strong>NOTES（备注）</strong></p>
<ul>
<li><strong>解释：</strong>
用于记录一些额外的元数据，例如：文档的作者、创建日期、链接到相关的 Jira
工单或会议记录等。</li>
<li><strong>作用：</strong> 便于管理和追溯文档。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"><span class="strong">**ADR #001 - 使用 RabbitMQ 替代 Kafka 作为消息队列**</span></span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="strong">**TITLE（标题）**</span></span><br><span class="line"></span><br><span class="line">将消息队列从 Kafka 切换至 RabbitMQ</span><br><span class="line"></span><br><span class="line"><span class="strong">**STATUS（状态）**</span></span><br><span class="line"></span><br><span class="line">Accepted（已接受）</span><br><span class="line"></span><br><span class="line"><span class="strong">**CONTEXT（背景）**</span></span><br><span class="line"></span><br><span class="line">我们现有的订单服务在业务高峰期时，订单创建和扣减库存的同步处理流程出现了严重的性能瓶颈。MySQL 数据库的写入操作成为单点瓶颈，导致订单处理延迟增加，甚至出现超时。为了解决这一问题，我们决定引入消息队列，将订单创建的后续流程（如库存扣减、积分发放）改为异步处理。</span><br><span class="line"></span><br><span class="line">在技术选型阶段，团队提出了两个主要的备选方案：Kafka 和 RabbitMQ。我们希望找到一个能满足以下需求的消息队列：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  <span class="strong">**高可靠性：**</span> 消息不能丢失，即使在消费者故障或重启时。</span><br><span class="line"><span class="bullet">2.</span>  <span class="strong">**消息时效性：**</span> 消息需要被及时处理，不接受长时间的延迟。</span><br><span class="line"><span class="bullet">3.</span>  <span class="strong">**灵活的路由：**</span> 能够根据不同的业务场景，将消息发送到不同的消费者。</span><br><span class="line"><span class="bullet">4.</span>  <span class="strong">**易于运维：**</span> 团队需要能快速上手，运维成本不能过高。</span><br><span class="line"></span><br><span class="line"><span class="strong">**DECISION（决策）**</span></span><br><span class="line"></span><br><span class="line">我们决定采用 <span class="strong">**RabbitMQ**</span> 作为新的消息队列，用于实现订单处理流程的异步化。</span><br><span class="line"></span><br><span class="line"><span class="strong">**核心理由：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消息路由的灵活性：**</span> RabbitMQ 提供了多种 exchange 类型（如 direct, fanout, topic），可以实现非常灵活的消息路由。这使得我们可以轻松地根据不同的订单类型或业务事件（例如，秒杀订单、普通订单）将消息发送到不同的消费者队列，满足未来的业务扩展需求。</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消息的可靠性：**</span> RabbitMQ 提供了成熟的持久化机制（Durable Queues）和消息确认机制（Publisher Confirms），能确保即使在 RabbitMQ 本身或消费者故障时，消息也不会丢失。这对订单处理这种核心业务至关重要。</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**团队学习曲线：**</span> 团队成员在内部技术分享中对 RabbitMQ 的概念（exchange, queue, binding）有了一定的了解，学习成本相对可控。</span><br><span class="line"></span><br><span class="line"><span class="strong">**备选方案的局限性：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**Kafka：**</span> Kafka 的核心设计思想是基于日志和分区，其路由能力相对较弱，主要通过 topic 和分区来实现消息分发。虽然可以通过消费者组来实现负载均衡，但在某些复杂路由场景下，需要额外的开发工作来适配。同时，Kafka 在保证单条消息的精确可靠投递方面，实现起来比 RabbitMQ 复杂一些，而这正是我们当前业务最关注的点。</span><br><span class="line"></span><br><span class="line"><span class="strong">**CONSEQUENCES（影响）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**积极影响：**</span></span><br><span class="line"><span class="bullet">    *</span> 显著提升订单处理的并发能力和吞吐量，缓解数据库写入瓶颈。</span><br><span class="line"><span class="bullet">    *</span> 提升系统的可扩展性，未来可以方便地增加更多异步消费者服务。</span><br><span class="line"><span class="bullet">    *</span> 系统的响应时间将大大缩短，提升用户体验。</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消极影响：**</span></span><br><span class="line"><span class="bullet">    *</span> 引入 RabbitMQ 会增加系统的运维复杂性，需要额外的监控和维护工作。</span><br><span class="line"><span class="bullet">    *</span> 团队需要投入时间学习和掌握 RabbitMQ 的相关知识，尤其是如何处理消费者故障、消息死信等问题。</span><br><span class="line"><span class="bullet">    *</span> 系统架构复杂度增加，需要重新设计和实现订单服务与消息队列的集成部分。</span><br><span class="line"></span><br><span class="line"><span class="strong">**COMPLIANCE（遵循）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 所有与订单相关的异步化处理流程，必须通过 RabbitMQ 进行通信。</span><br><span class="line"><span class="bullet">*</span> 新的服务代码必须严格遵循消息持久化和确认机制，以确保消息不丢失。</span><br><span class="line"><span class="bullet">*</span> 运维团队负责 RabbitMQ 集群的部署、监控和维护，并确保其高可用性。</span><br><span class="line"><span class="bullet">*</span> 在代码评审时，需要确保新引入的异步化服务遵循此 ADR 的设计规范。</span><br><span class="line"></span><br><span class="line"><span class="strong">**NOTES（备注）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**作者：**</span> Gemini AI</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**创建日期：**</span> 2025-07-26</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**关联工单：**</span> PROJECT-1234 - 订单服务高并发性能优化</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**相关会议记录：**</span> 架构评审会议 [2025-07-25]</span><br></pre></td></tr></table></figure>
<h2 id="设计实施路径与验证机制">4. 设计实施路径与验证机制</h2>
<blockquote>
<p>实施计划：是否需要技术原型 (PoC)
来验证关键难点？如何进行任务拆解和里程碑规划？</p>
<p>构建适用度函数：针对第二步定义的关键架构特性，设计具体的检验尺。</p>
<p>知识沉淀：准备好核心的架构图、设计文档等。</p>
</blockquote>
<h3 id="实施计划">4.1 实施计划</h3>
<p><strong>技术原型 (PoC)
来验证关键难点</strong>：架构师应频繁进行概念验证
(PoC)，以验证架构决策的可行性，并深入了解实施细节。PoC有助于比较不同解决方案，并评估性能、可伸缩性等架构特性。建议架构师在进行PoC时编写生产质量的代码，这是架构师可以用于保持编码手感的有效手段，同时一次性的
PoC 代码往往会成为团队的参考架构。</p>
<p><strong>任务拆解和里程碑规划</strong>：组件识别和架构设计是一个迭代过程，通过反馈不断优化。<strong>敏捷方法论</strong>支持迭代开发和快速反馈，有助于架构师在实践中调整决策。架构师还需要平衡架构工作和实际编码，通过<strong>委派核心路径代码</strong>，避免成为团队瓶颈。</p>
<h3 id="适应度函数">4.2 适应度函数</h3>
<p><strong>适应度函数是架构治理的核心工具</strong>。它是一种<strong>客观的函数</strong>，用于衡量代码复杂度和架构特性，并<strong>自动化验证</strong>开发团队是否遵循了架构决策和设计原则。适应度函数应<strong>集成到
CI/CD
流程中</strong>，在代码集成时自动检查合规性，从而避免问题积累。</p>
<ul>
<li><strong>检测循环依赖</strong>：可编写适应度函数来检测并防止组件之间的循环依赖，因为这会损害模块化（例如，使用
<strong>JDepend</strong>
工具）。这有助于维护架构中“重要但不紧急”的实践。</li>
<li><strong>分层架构合规性</strong>：利用<strong>ArchUnit</strong>（Java）或<strong>NetArchTest</strong>（.NET）等工具，可以确保分层架构中各层之间的访问限制被遵守。例如，限制表现层不能直接访问数据库，而必须通过业务层和持久层。</li>
<li><strong>验证距主序列距离</strong>：通过适应度函数验证代码抽象性与不稳定性之间的平衡。</li>
<li><strong>自动化编码标准合规性</strong>：例如，检查特定类是否包含必需的注解。</li>
</ul>
<h3 id="知识沉淀">4.3 知识沉淀</h3>
<ul>
<li><strong>ADR</strong>：将每一次关键决策及其动机、权衡、后果记录下来，形成可检索的决策日志。</li>
<li><strong><a target="_blank" rel="noopener" href="https://c4model.com/">C4
架构图</a></strong>：在每个里程碑输出更新后的系统上下文、容器、组件图，配合
ADR 链接。</li>
</ul>
<h3 id="管理松紧度">4.4 管理松紧度</h3>
<p>架构师需要根据团队实际情况采用恰到好处的管理松紧度，才能发挥团队的最大潜力。</p>
<p>采取哪种管理松紧度，可以从几个方面进行考量：</p>
<ul>
<li><strong>team
familiarity</strong>：团队内部的熟悉程度，越不熟悉，越需要更多投入。</li>
<li><strong>team size</strong>：团队大小，团队越大， 越需要投入。</li>
<li><strong>overall
experience</strong>：团队经验，新人越多，越需要投入。</li>
<li><strong>project complexity</strong>：项目越复杂，越需要投入。</li>
<li><strong>project
duration</strong>：项目周期，周期越长，越需要投入。</li>
</ul>
<p>按照这 5 个方面，极限 tight 是 20 分，极限 loose 是 -20
分，进行综合评价，看看自己是应该扮演什么角色。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250727144525753.png"
alt="管理松紧度计算表盘" />
<figcaption aria-hidden="true">管理松紧度计算表盘</figcaption>
</figure>
<h2 id="部署观测与效果衡量">5. 部署、观测与效果衡量</h2>
<blockquote>
<p>持续交付：作为将设计快速、可靠地部署到生产环境的手段。</p>
<p>系统监控：观测系统的健康状况（CPU、内存、延迟、错误率等）。</p>
<p>业务指标验证：验证是否达成了第一步定义的商业目标？例如，新架构上线后，用户转化率是否真的提升了？</p>
</blockquote>
<h3 id="持续交付与部署自动化">5.1 持续交付与部署自动化</h3>
<p>持续交付 (CI/CD) 是架构落地的关键环节。FOSA
强调，现代软件架构的成功离不开 DevOps
革命和对操作关注点的自动化。持续交付不仅仅是技术实践，更是组织文化的体现。</p>
<p>核心要素：</p>
<ul>
<li><p>自动化构建与测试：每次代码提交都触发自动化的构建、单元测试、集成测试流程，确保代码质量。</p></li>
<li><p>环境一致性：通过容器化技术（如
Docker）和基础设施即代码（IaC）确保开发、测试、生产环境的一致性。</p></li>
<li><p>渐进式部署：采用蓝绿部署、金丝雀发布等策略，降低部署风险，实现零停机时间。</p></li>
<li><p>快速回滚机制：当新版本出现问题时，能够快速回滚到上一个稳定版本。</p></li>
</ul>
<p>架构师职责：</p>
<ul>
<li><p>设计适合团队规模的 CI/CD 流水线</p></li>
<li><p>确保架构决策能够通过自动化流程得到验证</p></li>
<li><p>平衡部署频率与系统稳定性</p></li>
</ul>
<h3 id="系统监控与可观测性">5.2 系统监控与可观测性</h3>
<p>可观测性 (Observability) 是现代分布式系统的生命线。FOSA
指出，在分布式架构中，一个请求可能会流经数十个甚至上百个服务，要诊断一个问题，需要建立复杂的可观测性体系。</p>
<p>三大支柱：</p>
<ol type="1">
<li><p>指标 (Metrics)：量化系统性能的关键指标</p>
<ul>
<li><p>RED
方法：Rate（请求率）、Error（错误率）、Duration（延迟）</p></li>
<li><p>USE
方法：Utilization（利用率）、Saturation（饱和度）、Errors（错误）</p></li>
<li><p>业务指标：用户转化率、订单成功率、收入增长率</p></li>
</ul></li>
<li><p>日志 (Logs)：记录系统运行时的详细信息</p>
<ul>
<li><p>结构化日志：使用 JSON 格式，便于机器解析</p></li>
<li><p>日志聚合：集中收集、存储和分析日志</p></li>
<li><p>日志级别：根据重要性设置不同的日志级别</p></li>
</ul></li>
<li><p>追踪 (Tracing)：追踪请求在分布式系统中的完整路径</p>
<ul>
<li><p>分布式追踪：为每个请求分配唯一
ID，追踪其在整个调用链中的路径</p></li>
<li><p>链路追踪：记录服务间的调用关系和耗时</p></li>
<li><p>性能分析：识别系统瓶颈和性能热点</p></li>
</ul></li>
</ol>
<p>监控策略：</p>
<ul>
<li><p>分层监控：从基础设施层到应用层，建立完整的监控体系</p></li>
<li><p>告警策略：设置合理的告警阈值，避免告警疲劳</p></li>
<li><p>可视化仪表板：为不同角色提供定制化的监控视图</p></li>
</ul>
<h3 id="业务指标验证与闭环反馈">5.3 业务指标验证与闭环反馈</h3>
<p>业务指标验证是架构设计的闭环关键。FOSA
强调，技术架构的最终目标是服务于业务价值，因此必须验证是否达成了第一步定义的商业目标。</p>
<p>验证流程：</p>
<ol type="1">
<li>建立基线：在架构变更前，记录关键业务指标的当前状态</li>
<li>设定目标：基于第一步的商业目标，设定具体的量化指标</li>
<li>持续监控：在架构部署后，持续跟踪业务指标的变化</li>
<li>效果评估：定期评估架构变更对业务指标的实际影响</li>
</ol>
<p>常见业务指标：</p>
<ul>
<li><p>用户相关：日活跃用户数、用户留存率、用户满意度</p></li>
<li><p>业务相关：订单转化率、客单价、复购率</p></li>
<li><p>技术相关：系统可用性、响应时间、错误率</p></li>
</ul>
<p>A/B 测试策略：</p>
<ul>
<li><p>在架构变更时，可以考虑 A/B 测试来验证效果</p></li>
<li><p>对比新旧架构在相同条件下的业务表现</p></li>
<li><p>基于数据做出是否全面推广的决策</p></li>
</ul>
<h3 id="性能监控与容量规划">5.4 性能监控与容量规划</h3>
<p>性能监控是架构健康度的重要指标。FOSA
指出，架构师需要持续监控系统的性能表现，并基于趋势进行容量规划。</p>
<p>关键性能指标：</p>
<ul>
<li><p>响应时间：P50、P95、P99 延迟</p></li>
<li><p>吞吐量：每秒处理的请求数</p></li>
<li><p>资源利用率：CPU、内存、磁盘、网络使用率</p></li>
<li><p>错误率：4xx、5xx 错误的比例</p></li>
</ul>
<p>容量规划方法：</p>
<ul>
<li><p>趋势分析：基于历史数据预测未来需求</p></li>
<li><p>压力测试：通过模拟高负载验证系统极限</p></li>
<li><p>弹性规划：设计自动扩缩容机制应对流量波动</p></li>
</ul>
<h2 id="复盘沉淀与演进">6. 复盘、沉淀与演进</h2>
<blockquote>
<p>问题记录与根因分析：发生了什么？为什么会发生？</p>
<p>流程与原则改进：如何优化我们的设计流程、技术原则，避免未来再犯？</p>
<p>人员与组织成长：团队通过这次项目学到了什么？需要组织哪些培训？</p>
</blockquote>
<h3 id="问题记录与根因分析">6.1 问题记录与根因分析</h3>
<p>根因分析 (Root Cause Analysis, RCA) 是架构演进的基础。FOSA
强调，架构师需要建立系统性的问题记录和分析机制，避免同样的问题重复发生。</p>
<p>分析框架：</p>
<ol type="1">
<li><p>5W1H 分析法</p>
<ul>
<li><p>What：发生了什么问题？</p></li>
<li><p>When：什么时候发生的？</p></li>
<li><p>Where：在哪个组件/服务中发生的？</p></li>
<li><p>Who：谁发现了这个问题？</p></li>
<li><p>Why：为什么会发生？</p></li>
<li><p>How：如何避免再次发生？</p></li>
</ul></li>
<li><p>鱼骨图分析</p>
<ul>
<li><p>人员因素：技能不足、沟通不畅</p></li>
<li><p>流程因素：流程缺陷、决策不当</p></li>
<li><p>技术因素：架构设计问题、技术选型错误</p></li>
<li><p>环境因素：基础设施问题、外部依赖故障</p></li>
</ul></li>
<li><p>时间线分析</p>
<ul>
<li><p>按时间顺序记录事件发展过程</p></li>
<li><p>识别关键决策点和转折点</p></li>
<li><p>分析因果关系链</p></li>
</ul></li>
</ol>
<p>问题分类：</p>
<ul>
<li><p>架构设计问题：组件划分不当、接口设计不合理</p></li>
<li><p>技术选型问题：技术栈不匹配、性能瓶颈</p></li>
<li><p>流程管理问题：决策流程不清晰、沟通机制缺失</p></li>
<li><p>人员技能问题：团队技能不足、知识传递不畅</p></li>
</ul>
<h3 id="流程与原则改进">6.2 流程与原则改进</h3>
<p>持续改进是架构师的核心职责。FOSA
指出，架构师需要基于实践经验，不断优化设计流程和技术原则。</p>
<p>流程改进方法：</p>
<ol type="1">
<li><p>回顾会议 (Retrospective)</p>
<ul>
<li><p>定期组织团队回顾会议</p></li>
<li><p>识别流程中的痛点和改进机会</p></li>
<li><p>制定具体的改进行动计划</p></li>
</ul></li>
<li><p>架构评审机制</p>
<ul>
<li><p>建立正式的架构评审流程</p></li>
<li><p>邀请相关方参与评审</p></li>
<li><p>记录评审决策和后续行动</p></li>
</ul></li>
<li><p>决策记录 (ADR) 更新</p>
<ul>
<li><p>定期回顾和更新 ADR</p></li>
<li><p>记录决策的后续影响和教训</p></li>
<li><p>为未来类似决策提供参考</p></li>
</ul></li>
</ol>
<p>原则演进：</p>
<ul>
<li><p>技术原则：基于实践经验更新技术选型原则</p></li>
<li><p>设计原则：优化组件划分和接口设计原则</p></li>
<li><p>流程原则：改进决策流程和沟通机制</p></li>
<li><p>质量原则：更新代码质量和测试策略</p></li>
</ul>
<h3 id="持续学习与团队领导">6.3 持续学习与团队领导</h3>
<p>组织学习是架构成功的关键。FOSA
强调，架构师不仅要关注技术架构，更要关注团队和组织的成长。优秀的架构师通过培养团队能力和建立学习型组织，实现技术债务的持续偿还和架构能力的持续提升。</p>
<h4 id="分钟法则">6.3.1 20 分钟法则</h4>
<p>架构师需要持续学习以保持技术广度。FOSA
指出，技术发展日新月异，架构师必须建立系统化的学习机制，避免技术视野的固化。</p>
<p><strong>20分钟法则</strong>：建议每天至少投入20分钟学习新知识或深入特定主题，以系统化地拓展技术广度。这种持续的小剂量学习比偶尔的集中学习更有效，能够保持技术敏锐度。</p>
<p>学习策略：</p>
<ul>
<li><p>技术深度与广度平衡：在保持一个技术领域的深度基础上，系统性地拓展技术广度</p></li>
<li><p>问题驱动学习：将实际工作中遇到的问题作为学习的起点</p></li>
<li><p>理论与实践结合：通过概念验证（PoC）验证新技术的适用性</p></li>
<li><p>跨领域学习：不仅学习技术，还要了解业务、管理、心理学等相关领域</p></li>
</ul>
<h4 id="个人技术雷达">6.3.2 个人技术雷达</h4>
<p>建立"个人雷达"可以帮助架构师系统化地评估和追踪新兴技术和实践，类似于
ThoughtWorks 的技术雷达。</p>
<p>雷达分类：</p>
<ul>
<li><p>采用 (Adopt)：经过验证的技术，可以安全地在生产环境中使用</p></li>
<li><p>试用 (Trial)：有前景的技术，可以在非关键项目中尝试</p></li>
<li><p>评估 (Assess)：值得关注的技术，需要进一步研究和评估</p></li>
<li><p>保持 (Hold)：暂时不推荐使用的技术，但保持关注</p></li>
</ul>
<p>雷达维护：</p>
<ul>
<li><p>定期更新：每季度更新一次技术雷达</p></li>
<li><p>团队共享：与团队分享技术雷达，促进集体学习</p></li>
<li><p>决策参考：将技术雷达作为技术选型的重要参考</p></li>
</ul>
<h4 id="知识分享">6.3.3 知识分享</h4>
<p>架构师应通过以身作则而非仅仅凭借头衔来领导团队。他们可以通过主持"午餐分享会"
(brown-bag lunches)
来分享技术知识和经验，从而提升在团队中的领导力和影响力。</p>
<h4 id="团队健康监控与预警">6.3.4 团队健康监控与预警</h4>
<p>当出现以下 3
个问题时，意味着团队已经开始进入不健康状态了，作为架构师，需要及时发现和解决团队协作中的问题。</p>
<p><strong>Process
Loss（过程损失）</strong>：随着人数的增加，团队效率却在降低。</p>
<ul>
<li><p>表现：团队规模扩大后，沟通成本激增，决策效率下降</p></li>
<li><p>原因：信息传递链条过长，协调成本超过协作收益</p></li>
<li><p>解决方案：</p>
<ul>
<li><p>建立清晰的信息传递机制</p></li>
<li><p>采用敏捷方法，保持小团队结构</p></li>
<li><p>定期评估团队规模与效率的关系</p></li>
</ul></li>
</ul>
<p><strong>Pluralistic
Ignorance（多元无知）</strong>：当团队成员因为觉得自己没掌握某些信息的时候，对提出的方案不好提出拒绝，而只能在表面进行同意。</p>
<ul>
<li><p>表现：会议上大家都点头同意，但会后执行时遇到各种问题</p></li>
<li><p>原因：团队成员缺乏安全感，不敢提出质疑</p></li>
<li><p>解决方案：</p>
<ul>
<li><p>营造安全的讨论环境，鼓励质疑和提问</p></li>
<li><p>建立"魔鬼代言人"机制，专门负责提出反对意见</p></li>
<li><p>定期进行匿名反馈收集</p></li>
</ul></li>
</ul>
<p><strong>Diffusion of
Responsibility（责任扩散）</strong>：职责混乱，大家不知道谁应该为哪些东西负责任。</p>
<ul>
<li><p>表现：任务推诿，问题无人负责，决策无人执行</p></li>
<li><p>原因：角色定义不清晰，责任边界模糊</p></li>
<li><p>解决方案：</p>
<ul>
<li><p>建立明确的 RACI 矩阵（Responsible, Accountable, Consulted,
Informed）</p></li>
<li><p>定期回顾和更新团队职责分工</p></li>
<li><p>建立问责机制，确保每个决策都有明确的责任人</p></li>
</ul></li>
</ul>
<h2 id="总结">总结</h2>
<p>架构设计一个系统性的六步工程过程，从商业理解到组织成长形成闭环。它强调"为什么"比"怎么做"更重要，要求架构师在理解利益相关方诉求和用户痛点的基础上，将模糊需求转化为可度量的技术目标，通过多方案权衡分析选择"最不差"而非"最佳"的架构方案，并建立持续交付、监控验证和复盘演进的机制，最终实现技术债务的持续偿还和团队能力的持续提升。整个方法论的核心是权衡取舍的艺术，以及架构师在技术决策中始终提供技术和业务双重理由的能力。</p>

<div class="article-footer fs14">
    <section id="references">
      <div class="header"><span>参考资料</span></div>
      <div class="body">
        <ul>
        <li class="post-title">
          <p><a
target="_blank" rel="noopener" href="https://fundamentalsofsoftwarearchitecture.com/">Fundamentals of
Software Architecture</a></p>

        </li>
        </ul>
      </div>
    </section>
    
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享
4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://hedon.top/2025/07/24/note/note-fosa/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://hedon.top/2025/07/24/note/note-fosa/&title=读书笔记丨《Fundamentals of Software Architecture》 - HedonWang&pics=/banner/note-fosa.jpg&summary=基于《Fundamentals of Software Architecture》内容，梳理出六步架构设计方法论，从商业理解到组织成长形成闭环，探讨架构师如何在权衡取舍中做出"最不差"的决策，以及如何通过持续交付、监控验证和复盘演进构..."><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=读书笔记丨《Fundamentals of Software Architecture》 - HedonWang&amp;body=https://hedon.top/2025/07/24/note/note-fosa/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://hedon.top/2025/07/24/note/note-fosa/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/07/27/llm/back-propagation/">大白话解释反向传播算法</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/07/23/fosa/fosa-ch17/">FOSA丨17丨微服务架构</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="hedon954/hedonspace" data-repo-id="R_kgDOKt17sQ" data-category="Q&A" data-category-id="DIC_kwDOKt17sc4CbAt-" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Hedon Wang</a> 使用 <a
target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar
1.29.1</a> 主题创建。 本博客所有文章除特别声明外，均采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA
4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%8A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88"><span class="toc-text">聊架构设计的时候，我们在谈什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fundamentals-of-software-architectrue-%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86"><span class="toc-text">Fundamentals of
Software Architectrue 笔记梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%95%86%E4%B8%9A%E4%B8%8E%E7%BB%84%E7%BB%87%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">1. 理解商业与组织上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E5%88%A4%E6%8A%80%E5%B7%A7"><span class="toc-text">1.1 谈判技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%90%86%E8%A7%A3"><span class="toc-text">1.2 业务理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7%E4%B8%8E%E7%BA%A6%E6%9D%9F"><span class="toc-text">2. 定义架构特性与约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 架构特性定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 架构特性类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7%E9%80%89%E6%8B%A9"><span class="toc-text">2.3 架构特性选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A2%E7%B4%A2%E6%96%B9%E6%A1%88%E4%B8%8E%E5%86%B3%E7%AD%96"><span class="toc-text">3. 探索方案与决策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-text">3.1 架构风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84-layered-architecture"><span class="toc-text">3.1.1 分层架构 Layered
Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%9E%B6%E6%9E%84-pipeline-architecture"><span class="toc-text">3.1.2 管道架构 Pipeline
Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%A0%B8%E6%9E%B6%E6%9E%84-microkernel-architecture"><span class="toc-text">3.1.3 微核架构 Microkernel
Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84-service-based-architecture"><span class="toc-text">3.1.4 基于服务的架构
Service-Based Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84-event-driven-architecture"><span class="toc-text">3.1.5 事件驱动架构
Event-Driven Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%9E%B6%E6%9E%84-space-based-architecture"><span class="toc-text">3.1.6 空间架构 Space-Based
Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-orchestration-driven-service-oriented-architecture"><span class="toc-text">3.1.7
面向服务架构 Orchestration-Driven Service-Oriented Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-microservice-architecture"><span class="toc-text">3.1.8 微服务架构
Microservice Architecture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9"><span class="toc-text">3.2 架构选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%93-vs-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-text">3.2.1 单体 vs 分布式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-text">3.2.2 数据存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5"><span class="toc-text">3.2.3 同步 vs 异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0"><span class="toc-text">3.3 风险评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96"><span class="toc-text">3.4 架构决策</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#anti-pattern1-covering-your-assets"><span class="toc-text">3.4.1 Anti-Pattern1:
Covering Your Assets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#anti-pattern2-groundhog-day"><span class="toc-text">3.4.2 Anti-Pattern2: Groundhog
Day</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#anti-pattern3-email-driven-architecture"><span class="toc-text">3.4.3 Anti-Pattern3:
Email-Driven Architecture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96%E8%AE%B0%E5%BD%95-adr"><span class="toc-text">3.4.4 架构决策记录 ADR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%96%BD%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-text">4. 设计实施路径与验证机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%96%BD%E8%AE%A1%E5%88%92"><span class="toc-text">4.1 实施计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">4.2 适应度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80"><span class="toc-text">4.3 知识沉淀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%9D%BE%E7%B4%A7%E5%BA%A6"><span class="toc-text">4.4 管理松紧度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E8%A7%82%E6%B5%8B%E4%B8%8E%E6%95%88%E6%9E%9C%E8%A1%A1%E9%87%8F"><span class="toc-text">5. 部署、观测与效果衡量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E4%B8%8E%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-text">5.1 持续交付与部署自动化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-text">5.2 系统监控与可观测性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%8C%87%E6%A0%87%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%97%AD%E7%8E%AF%E5%8F%8D%E9%A6%88"><span class="toc-text">5.3 业务指标验证与闭环反馈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92"><span class="toc-text">5.4 性能监控与容量规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%9B%98%E6%B2%89%E6%B7%80%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="toc-text">6. 复盘、沉淀与演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">6.1 问题记录与根因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B"><span class="toc-text">6.2 流程与原则改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%9B%A2%E9%98%9F%E9%A2%86%E5%AF%BC"><span class="toc-text">6.3 持续学习与团队领导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%92%9F%E6%B3%95%E5%88%99"><span class="toc-text">6.3.1 20 分钟法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E9%9B%B7%E8%BE%BE"><span class="toc-text">6.3.2 个人技术雷达</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB"><span class="toc-text">6.3.3 知识分享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A2%E9%98%9F%E5%81%A5%E5%BA%B7%E7%9B%91%E6%8E%A7%E4%B8%8E%E9%A2%84%E8%AD%A6"><span class="toc-text">6.3.4 团队健康监控与预警</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":"https://site-info-api-hedon.vercel.app/api/v1?url={href}"},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img, .md-text img:not([class]), .md-text .image img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
