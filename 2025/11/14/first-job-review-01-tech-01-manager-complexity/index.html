
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度 - HedonWang</title>

  
    <meta name="description" content="三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度">
<meta property="og:url" content="https://hedon.top/2025/11/14/first-job-review-01-tech-01-manager-complexity/index.html">
<meta property="og:site_name" content="HedonWang">
<meta property="og:description" content="三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-14T13:00:00.000Z">
<meta property="article:modified_time" content="2025-11-14T14:12:46.807Z">
<meta property="article:author" content="Hedon Wang">
<meta property="article:tag" content="三年工作复盘">
<meta property="article:tag" content="技术篇">
<meta property="article:tag" content="软件工程">
<meta property="article:tag" content="管理复杂度">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <meta name="keywords" content="三年工作复盘,技术篇,软件工程,管理复杂度">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="HedonWang" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">


  
    <link rel="shortcut icon" href="/assets/favicon.png">
  

  

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.png"><link rel="shortcut icon" href="/assets/favicon.png"><meta name="theme-color" content="#f8f8f8"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/markmap.css"><script src="https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18"></script>
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/assets/favicon.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main" ff="title">HedonWang</div><div class="sub cap">君子求诸己，律己则安。</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="专栏" href="/topic/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于我" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="思维导图" href="/html/mindmap.html" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/04/09/note/note-unit-testing/"><span class="title">读书笔记丨《Unit Testing Principles, Practices, and Patterns》</span></a><a class="item title" href="/2025/11/17/go/go-interface/"><span class="title">Go 底层原理丨interface</span></a><a class="item title" href="/2025/11/16/go/go-slice/"><span class="title">Go 底层原理丨slice 从第一性原理到实现细节</span></a><a class="item title" href="/2025/11/23/go/go-net/"><span class="title">Go 底层原理丨网络编程</span></a><a class="item title" href="/2025/11/17/go/go-memory-model/"><span class="title">Go 底层原理丨内存模型</span></a><a class="item title" href="/2025/11/16/go/go-map-swiss/"><span class="title">Go 底层原理丨map（Swiss Table 版本）</span></a><a class="item title" href="/2025/11/16/go/go-map-no-swiss/"><span class="title">Go 底层原理丨map（非 swiss 版本）</span></a><a class="item title" href="/2025/11/21/go/go-lock/"><span class="title">Go 底层原理丨锁</span></a><a class="item title" href="/2025/11/17/go/go-gc-tri-color-marking/"><span class="title">Go 底层原理丨垃圾回收（三色标记法）</span></a><a class="item title" href="/2025/11/19/go/go-gc-green-tea-gc/"><span class="title">Go 底层原理丨垃圾回收（green tea gc）</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/banner/first-job-review-01-tech-01-manager-complexity.jpg">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E4%B8%89%E5%B9%B4%E5%B7%A5%E4%BD%9C%E5%A4%8D%E7%9B%98/">三年工作复盘</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-11-14T13:00:00.000Z">2025-11-14</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-11-14T14:12:46.807Z">2025-11-14</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>我觉得可以用<strong>道法术器</strong>来对复杂度管理进行一个重点概述：</p>
<ul>
<li><strong>道（目标）</strong>：管理复杂度</li>
<li><strong>法（基石）</strong>：抽象、分治、分层、模块化</li>
<li><strong>术（方法）</strong>：SOLID
原则、设计模式、架构模式、领域驱动设计（DDD）</li>
<li><strong>器（工具）</strong>：单元测试、可观测性</li>
</ul>
<h1
id="道管理复杂度是我们的终极目标">道：管理复杂度是我们的终极目标</h1>
<p>"道"是我们的终极目标，是我们实施软件工程一切的 WHY，</p>
<p>在三年的工作经历中，我对"屎山"的理解太深刻了。我亲手维护了大量前人留下的屎山代码，不做分层设计、模块划分不恰当、全局变量到处飞、命名随便起、概念不明晰。我也亲眼见证我由我经手的代码是如何一步步变成屎山的，需求的随意修改、为了应付
deadline
而习惯成自然的"龙卷风战术"、迭代时对现有字段的概念胡乱扩充、解决问题不处理根源而为了炫技在外面包装一层，金玉其外败絮其中。</p>
<p>这些技术债，使得代码阅读难度飙升，功能迭代负担巨大，重构风险难以估量，对新人很不友好。随着破窗效应的不断扩大，为了快速应付哪些莫须有的
deadline
和"紧急"需求，领导们和底层员工都习惯于采取"龙卷风战术"来快速完全需求，加剧了恶性循环。截止到我离职之前，这些技术债已经对业务发展的技术支持度、研发效率和产品质量造成了严重影响了。</p>
<p>我也试图做过一些努力，亲自全力推进了<strong>代码质量建设</strong>和<strong>服务监控建设</strong>两大专项，对于我个人来说改变是巨大的，我从工程认知、编码思维、业务理解等多方面都有巨大的突破。坦白说，从另一个层面来说，我庆幸过这些"屎山"的存在，我也很庆幸自己在职业初期就打下了坚实的基础，也认定了要成为一位优秀的软件工程师的目标。只不过，在历史长河中，我这两大专项对于团队的影响，却是杯水车薪，聊胜于无罢了。</p>
<p>我一直在思考，为什么？为什么复杂度就像"熵增"一样不可避免？我们程序员的宿命，难道就是不断地在屎山上雕花吗？若将来我有机会成为一位领导者，我如何避免上述问题的发生？</p>
<p>Fred Brooks
在《人月神话》中早已断言：软件的困难，在于其<strong>固有的复杂度
(Essential Complexity)</strong>。</p>
<ul>
<li><strong>复杂度不是难</strong>：不是指"这个算法很难"，而是指"<strong>系统中组件间依赖关系的数量</strong>"。</li>
<li><strong>复杂度是非线性增长的</strong>：一个 100
个模块的系统，其潜在的"依赖"和"状态组合"是天文数字。当认知负荷超过人脑（或团队）的上限时，系统就失控了。</li>
<li><strong>复杂度是万恶之源</strong>：
<ul>
<li>你修复一个 Bug，却引发了三个新 Bug？——
<strong>复杂度失控</strong>。</li>
<li>你无法安全地添加一个新功能？—— <strong>复杂度失控</strong>。</li>
<li>你不敢重构？—— <strong>复杂度失控</strong>。</li>
</ul></li>
</ul>
<p>所以我觉得不管是什么样的技术栈、设计原则、编程思维、架构模式，或是那么多的软件工程管理方法论，比如敏捷开发、极限编程，或是现在的终极大杀器领域驱动设计，都是为了管理复杂度。因此，本篇后续的所有内容都是为了服务于"<strong>管理复杂度</strong>"这唯一且根本的道。</p>
<h1 id="法管理复杂度的四大核心原则">法：管理复杂度的四大核心原则</h1>
<p>既然我们无法消灭复杂度，我们就只能<strong>管理</strong>它。在众多编程思想、设计模式、架构模式中，我觉得其中最最最根本、生命力最最持久、最有可能以不变应万变的是以下
4 点：</p>
<ul>
<li><strong>抽象</strong>：隐藏实现细节，只暴露意图契约。</li>
<li><strong>分治</strong>：将一个大问题，拆解为一堆可独立解决的小问题。</li>
<li><strong>分层</strong>：规定模块间的依赖关系，且依赖必须是单向的。</li>
<li><strong>模块化</strong>：高内聚 (High Cohesion)，低耦合 (Low
Coupling)。</li>
</ul>
<h2 id="抽象">抽象</h2>
<h3 id="抽象的作用">抽象的作用</h3>
<p>我发现！抽象这个词是真的抽象！我们经常在聊抽象，当发现原有代码不好迭代的时候，我们会说"这个抽象得不够好"，当看到代码比较混乱、重复较多时，我们会说"这个有空可以抽象一下"，当然有时候也会吐槽"这个代码写得真抽象"，或者"这有点过度抽象了"。</p>
<p>我时常想不明白当我们在谈抽象的时候，我们到底在说些什么？什么是抽象？怎么判断要不要抽象？怎么做抽象？要抽象的东西到底是什么？抽象到什么程度是恰当的？怎么评判一个抽象行为的好坏？如何避免过度抽象？如何在不断变化的业务需求中做一个稳定的抽象？</p>
<p>用一句话形容就是：<font color="orange"><u>我们经常在谈抽象，它在软件工程中无处不在，但又极其"主观"和"暧昧"。</u></font></p>
<p>为了更靠近上述问题的答案，或许我们应该退一步，回归它的第一性原理：<strong>它不是一种代码技巧，而是一种管理复杂度的核心战略。</strong></p>
<p>本篇我们在谈管理复杂度的问题，但是人脑的认知负荷是有限的（米勒定律说我们只能同时处理
7±2 个信息块）。一个拥有 100
个模块的系统，其潜在的依赖关系和状态组合是天文数字，远超人脑上限。</p>
<p>而抽象是我们对抗认知负荷的第一武器。既然我们没法同时处理那么多的信息块，那就想办法让自己只需要同时处理少数信息块。所以抽象的本质是就是<strong>信息隐藏</strong>。它将一个复杂系统，拆分为两部分：</p>
<ul>
<li><strong>契约或 API：</strong>这是
<strong>What</strong>，即它能做什么。它是简单的、稳定的、易于理解的。</li>
<li><strong>实现：</strong> 这是
<strong>How</strong>，即它如何做的。它是复杂的、易变的、被隐藏的。</li>
</ul>
<p>因此，一个好的抽象，就是一套<strong>简单易懂的契约</strong>；而一个坏的抽象，就是一套<strong>让人猜不透的契约</strong>。</p>
<h3 id="抽象的难点">抽象的难点</h3>
<p>在实际编码过程中，最常见的抽象行为就是定义接口。但是我们经常会发现很多接口的定义是毫无意义甚至是负作用的。我总结了过去
3 年工作中存在的关于接口定义问题最大的 3 个点：</p>
<ol type="1">
<li><strong>毫无接口定义</strong>：起初在我们的 Web
服务中，没有任何的接口定义，甚至都只有两层架构，只能面向实现编程，各个模块耦合严重，写代码牵一发而动全身，在代码理解、模块划分、职责明晰、组件升级、代码复用、架构重构、单元测试、问题排查和业务迭代等各个方面都带来了层层阻力。</li>
<li><strong>单一实现大接口</strong>：在我们的老匹配服中，倒是定义了一些接口，但是这些接口都非常大，动辄三四十个方法，而且都只有一种实现。这种接口定义，除了给阅读代码带来多一层跳转的心智负担之外，毫无意义。</li>
<li><strong>接口繁多且职责不匹配</strong>：在我们的新匹配服中，倒是吸取了过往不少的教训，但是过犹不及。我们定义了一大堆接口，引入了一堆的设计模式和编码技巧，使得代码极其抽象，阅读难度很高，经常为了理清一个逻辑要跳转十几次，看了后面忘了前面。而且很多接口定义的方法和接口本身该有的职责是不匹配的，这带来了非常大的困扰。这种我统一称为炫技。比如所以外表虽然看起来牛逼，但实际上代码可读性极差。</li>
</ol>
<p>至今我依然觉得做好接口定义真是一件不容易的事情，而且想一次定义一个好的接口，也几乎是不现实的。不过至少现在我们可以得出一个结论：</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>抽象是有<strong>成本</strong>的：它增加了<strong>间接性</strong>，代码不再是平铺直叙的，需要多一次跳转，这本身也会增加认知负荷。</p>
<p><strong>如果收益 &lt;
成本，这就是过度抽象。</strong>过度抽象的本质是：<strong>你为你"猜想"的、但"永远不会发生"的"变化"，提前支付了"抽象的成本"。</strong></p>
</blockquote>
<h3 id="抽象的本质">抽象的本质</h3>
<p>现在需要回到一个最关键的问题，当我们在谈抽象的时候，我们究竟在"抽"什么？如果不知道"抽"什么，我们就会"瞎抽"。</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>答案是：<font color="red"><u>我们抽象的不是"代码"，我们抽象的是"变化"。</u></font>软件的宿命就是不断变化。而抽象的<strong>目的</strong>，就是<strong>隔离变化</strong>——把系统中<strong>易变的部分</strong>和<strong>不变的部分</strong>隔离开，在它们之间建立一道防火墙。</p>
</blockquote>
<p>关于变化，我觉得可以从 2 个方面进行思考：</p>
<ul>
<li><strong>技术抽象</strong>：是<strong>不变的业务</strong> vs
<strong>易变的技术</strong>。</li>
<li><strong>业务抽象</strong>：是<strong>不变的业务本质</strong> vs
<strong>易变的业务流程</strong>。</li>
</ul>
<h3 id="技术层面的抽象">技术层面的抽象</h3>
<p>这里我想以业务逻辑层（Service）和持久化层（Repository）之间的交互来展开谈一谈。</p>
<p>比如说我们有一个订单服务
OrderService，这个时候很多的教学视频都会说，那我们要给持久化层定义一个
OrderRepository，这样后面我们不管是使用 MySQL、还是换成 Mongo、Oracle
都不会影响到 Service
层的逻辑。我个人觉得如果是以这样的目的去做的接口定义，离真正的抽象还是有不少距离的。事实上，在一个系统中，你几乎不会更换数据库的类型，因为它的影响面和风险实在太大了，即便有，频率也是极低的，为了一个极大概率不发生的"变化"提前支付了长时间的"抽象成本"，是不划算的。</p>
<p>那还有没有必要定义 Repository
接口呢？当然是有必要的，不过它的出发点应该是为了应付那些日常研发过程中经常会碰到的"变化"，比如：</p>
<ul>
<li><strong>为了可测试性</strong>：如果你不为 Repository
层定义接口，那你测试 Service
层的时候，就不得不连接到数据库，可测试性极差。</li>
<li><strong>为了不污染核心业务</strong>：数据库不常变，但是访问数据库的方式却是有可能变化的，Repository
可以为 Service 提供一个干净稳定的数据访问契约，屏蔽掉易变化的细节。</li>
<li><strong>为了可控的外部依赖</strong>：如果我们依赖的不是数据库，而是第三方服务，比如说短信
API
服务，那修改第三方服务的可能性也就大大提升了，不同厂商或是同一厂商的不同版本
API 所需要的参数、返回值都可能是不一样的。</li>
</ul>
<p>接下来我们举 3 个例子来分别阐述一下。</p>
<p>首先是为了可测试性而抽象，这是抽象在工程实践中<strong>最刚需、最不可辩驳</strong>的理由。假如说我们接口了一个
OrderService，它没有任何的抽象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：没有抽象，&quot;业务逻辑&quot; 和 &quot;技术实现&quot; 焊死</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 没有接口，直接依赖 &quot;具体的&quot; 数据库连接</span></span><br><span class="line">    db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CreateOrder(order *Order) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 核心业务逻辑 (比如检查库存、计算价格)</span></span><br><span class="line">    <span class="keyword">if</span> order.Price &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;价格错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 技术实现逻辑 (硬编码)</span></span><br><span class="line">    <span class="comment">// 业务逻辑和 GORM 的 API &quot;焊死&quot; 在一起</span></span><br><span class="line">    <span class="keyword">if</span> err := s.db.Create(order).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根本无法为 <code>CreateOrder</code>
方法写单元测试。你写的任何测试，都会<strong>真的</strong>去
<code>s.db.Create</code>，它会<strong>真的</strong>尝试连接
MySQL。这是一个集成测试，它慢、依赖环境、而且极其脆弱。你也无法单独测试
<code>if order.Price &lt; 0</code> 这行核心业务逻辑。</p>
<p>针对这种情况，我们做的抽象，就是要把那个易变的 <code>s.db</code>
从具体实现<strong>抽象</strong>为契约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：抽象出 &quot;Repository&quot; 契约</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 &quot;契约&quot; (What)</span></span><br><span class="line"><span class="keyword">type</span> OrderRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">    Save(order *Order) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &quot;不变&quot; 的业务逻辑</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">    repo OrderRepository <span class="comment">// &lt;-- 依赖 &quot;契约&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CreateOrder(order *Order) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 核心业务逻辑 (100% 纯粹)</span></span><br><span class="line">    <span class="keyword">if</span> order.Price &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;价格错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用 &quot;契约&quot;，不关心 &quot;实现&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s.repo.Save(order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们的收益是 100% 可以兑现的，即 <code>OrderService</code>
现在<strong>100% 可被单元测试</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// order_service_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateOrder_PriceError</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 准备一个 &quot;假的实现&quot; (Mock)</span></span><br><span class="line">    mockRepo := <span class="built_in">new</span>(MockOrderRepo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注入 &quot;假的实现&quot;</span></span><br><span class="line">    service := &amp;OrderService&#123;repo: mockRepo&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 100% 独立地测试 &quot;业务逻辑&quot;</span></span><br><span class="line">    err := service.CreateOrder(&amp;Order&#123;Price: <span class="number">-100</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 断言</span></span><br><span class="line">    assert.Error(t, err, <span class="string">&quot;价格错误&quot;</span>)</span><br><span class="line">    <span class="comment">// (mockRepo 的 Save 方法根本不会被调用)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是为了不污染核心业务而抽象，假如我们的
<code>OrderService</code> V1 运行良好。老板说：V1
太慢了，给创建订单加一层 Redis 缓存！</p>
<p>如果没有抽象，那你会被迫入侵 <code>OrderService</code>
的实现细节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：业务逻辑被 &quot;基础设施&quot; 污染</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">    db    *gorm.DB</span><br><span class="line">    redis *redis.Client <span class="comment">// &lt;-- 引入新的 &quot;实现&quot; 依赖</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CreateOrder(order *Order) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> order.Price &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;价格错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;业务逻辑&quot; 和 &quot;基础设施逻辑&quot; 像意大利面一样 &quot;耦合&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err := s.db.Create(order).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;脏活累活&quot; 混了进来</span></span><br><span class="line">    s.redis.Set(<span class="string">&quot;cache_key_for_orders&quot;</span>, order)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>噩梦是什么：</p>
<ol type="1">
<li><strong>职责混乱：</strong> <code>OrderService</code>
不再纯粹，它现在<strong>同时</strong>关心"业务规则"、"MySQL
写入"和"Redis 缓存"。</li>
<li><strong>测试灾难：</strong>
你的单元测试（如果有的话）现在<strong>又</strong>需要 Mock
<code>redis.Client</code> 了。</li>
<li><strong>下一个噩梦：</strong> 下周老板说再加一个 Kafka
消息，通知履约’中台，你是不是要在这个函数里再加
<code>kafka.Producer</code>？</li>
</ol>
<p>我们的解决方案是 <code>OrderService</code>
<strong>一行代码都不用改</strong>。它只认识 <code>OrderRepository</code>
这个契约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：我们 &quot;实现&quot; 一个新的 &quot;How&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 新的 &quot;实现&quot;，它 &quot;组合&quot; 了老的 &quot;实现&quot;</span></span><br><span class="line"><span class="keyword">type</span> CachedOrderRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">    nextRepo OrderRepository <span class="comment">// &quot;下一层&quot; (e.g., MySQLRepo)</span></span><br><span class="line">    redis    *redis.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. CachedOrderRepo 同样实现了 &quot;契约&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CachedOrderRepo)</span></span> Save(order *Order) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;脏活累活&quot; (基础设施逻辑) 被 &quot;封装&quot; 在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先调用 &quot;下一层&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err := c.nextRepo.Save(order); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 再处理缓存</span></span><br><span class="line">    c.redis.Set(<span class="string">&quot;cache_key_for_orders&quot;</span>, order)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只需要初始化的时候，做出以下修改，OrderService
完全不用动，我们就可以享受到扩展时不污染核心业务的收益，这种收益，是时常会发生的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1</span></span><br><span class="line">repo := &amp;MySQLOrderRepo&#123;db: db&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line">mysqlRepo := &amp;MySQLOrderRepo&#123;db: db&#125;</span><br><span class="line">repo := &amp;CachedOrderRepo&#123;nextRepo: mysqlRepo, redis: redisClient&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个例子是为了可控的外部依赖而抽象。假如说我们有个用户注册服务，需要调用腾讯云短信
API 发送验证码。如果没有抽象，那就会在 <code>UserService</code>
中硬编码了腾讯云的 SDK。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：焊死 &quot;外部依赖&quot;</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    db    *gorm.DB</span><br><span class="line">    <span class="comment">// 直接依赖 &quot;具体的&quot; SDK</span></span><br><span class="line">    txSmsClient *tx_sms.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span></span> Register(phone <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// &quot;业务&quot; 和 &quot;外部 SDK&quot; 焊死</span></span><br><span class="line">    code := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    err := s.txSmsClient.Send(phone, code)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>噩梦是什么：</p>
<ul>
<li><strong>测试地狱：</strong> 你每跑一次 <code>Register</code>
的测试，就<strong>真的</strong>给手机发了一条短信！测试成本高昂，且依赖网络。</li>
<li><strong>SLA 绑架：</strong> 腾讯云短信 API
挂了（这<strong>经常</strong>发生），你的注册服务<strong>跟着一起挂</strong>。</li>
<li><strong>迁移灾难：</strong>
老板说腾讯云太贵，换成阿里云。你<strong>必须</strong>入侵
<code>UserService</code> 内部，把 <code>tx_sms.Client</code> 的所有 API
调用，<strong>逐行</strong>改成 <code>ali_sms.Client</code> 的
API。</li>
</ul>
<p>我们的解决方案是：定义一个你自己的<strong>防腐层</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：抽象 &quot;短信服务&quot; 契约</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 &quot;契约&quot; (What)</span></span><br><span class="line"><span class="keyword">type</span> SMSService <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(phone, code <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &quot;业务&quot; 只依赖 &quot;契约&quot;</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    db    *gorm.DB</span><br><span class="line">    sms   SMSService <span class="comment">// &lt;-- 依赖 &quot;契约&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span></span> Register(phone <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    code := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    err := s.sms.Send(phone, code) <span class="comment">// &lt;-- 调用 &quot;契约&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. &quot;实现&quot; (How)</span></span><br><span class="line"><span class="keyword">type</span> TencentSMSService <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TencentSMSService)</span></span> Send(...) <span class="type">error</span> &#123; <span class="comment">/* ... 腾讯 SDK ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliyunSMSService <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AliyunSMSService)</span></span> Send(...) <span class="type">error</span> &#123; <span class="comment">/* ... 阿里 SDK ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点：用于 &quot;测试&quot; 和 &quot;开发&quot; 的 &quot;实现&quot;</span></span><br><span class="line"><span class="keyword">type</span> LogSMSService <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSMSService)</span></span> Send(phone, code <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;[Mock SMS] Send to %s, code: %s&quot;</span>, phone, code)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收益是什么：</p>
<ul>
<li><strong>可测试性：</strong> 单元测试时，你注入
<code>MockSMSService</code>。</li>
<li><strong>环境隔离：</strong> 开发/测试环境时，你注入
<code>LogSMSService</code>（它只打印日志不发短信）。</li>
<li><strong>可迁移性：</strong> 从腾讯换阿里，<code>UserService</code>
<strong>一行不用改</strong>，你只需要在 <code>main.go</code>
替换实现类。</li>
<li><strong>健壮性：</strong> 你甚至可以实现一个
<code>FailoverSMSService</code>
高可用实现，它内部尝试先用腾讯、失败后自动降级到阿里。而
<code>UserService</code> <strong>毫不知情</strong>。</li>
</ul>
<p>这种收益在实际业务开发过程中，也是时常会发生的。</p>
<h3 id="业务层面的抽象">业务层面的抽象</h3>
<p>前面提到的 3
个技术层面的例子，难度小、代价低、收益高、可复制性强，所以我觉得任何时候我们工程师都要尽力把这些方面做好。</p>
<p>但是业务层面的抽象就不一样了，我们工程师的噩梦，就是业务方（PM）每天都在改需求，我们被<strong>易变的流程</strong>牵着鼻子走，导致核心代码日益腐化。所以业务抽象的<strong>唯一目的</strong>，就是<strong>在易变的业务规则（流程）中，保护不变的业务本质</strong>。</p>
<p>这里我想引用《服务端开发·技术、方法与实用解决方案》一书中的一个例子，这也是我在
2024
年年中绩效总结时对前司部门提出的一个建议（虽然事实上并没起到什么作用）。书中提出了一个疑问：</p>
<blockquote>
<p>[!WARNING]</p>
<p>产品需求退化的根本原因是什么？</p>
<p>—— 是缺乏抽象</p>
</blockquote>
<p>通过抽象可以理清业务的核心问题并设计体系化的方案予以解决，而缺乏抽象则只能通过具体的、复杂的描述来反映事务的表面特征。</p>
<p>比如有以下需求：</p>
<blockquote>
<p>"优惠立减"活动上线后，在 App
主页，如果用户是在活动开始后首次进入，则弹出一个提示窗口，展示"优惠立减"活动信息，吸引用户参与；如果用户点击弹窗信息，则跳转进入到对应的活动页面，之后在
App 主页不再弹窗提示，避免打扰用户；如果用户不点击弹窗信息，则弹窗 5s
后自动关闭，之后用户若再进入 App 主页，则以每周弹窗 3
次的频率提醒用户，直到用户点击弹窗信息为止。</p>
</blockquote>
<p>如果我们完全按照这个需求方案来进行编码，那估计又是一个函数里面硬编码了很多的逻辑，那势必会在需求的每日变化中不断腐化。那这个业务的本质是什么呢：</p>
<blockquote>
<p>这是一个"控制疲劳度"（疲劳频次）的问题，即"业务场景 S 对应 F 次/周期
Q"。</p>
<ul>
<li>S：任意场景</li>
<li>F：整数</li>
<li>Q：时间单位， 天、周、月、年、终身等</li>
</ul>
</blockquote>
<p>不过我觉得，策划和运营团队，对于"运营活动"的模型理解跟技术团队是有区别的，技术团队面对的是具体到一个个细节、完整的需求，而在策划和运营团队那，可能有一套不一样的底层逻辑。技术团队要做到抽象，只能是在接触了多个明显相似的需求后，才有可能进行抽象提取，哪怕是这个时候，跟业务方的理解也可能有偏差。所以如果可以从业务方源头就做好抽象，那真是可以起到四两拨千斤的作用。</p>
<hr />
<p>接下来我们来看两个研发过程中最常见的业务痛点（变化点）：规则和流程。</p>
<p><strong>痛点一：If-Else 怪物 —— 业务规则的腐化</strong></p>
<p>现在有一个计算订单价格的服务
<code>OrderService.CalculatePrice()</code>，它经历了以下几个版本：</p>
<ul>
<li><strong>V1（上线）：</strong>
逻辑很简单：<code>price = product.Price * quantity</code></li>
<li><strong>V2（双十一）：</strong> PM
跑来说：加个双十一规则，所有商品打 8 折！
<ul>
<li>你入侵了
<code>CalculatePrice</code>：<code>if (isDoubleEleven) &#123; price = price * 0.8 &#125;</code></li>
</ul></li>
<li><strong>V3（拉新）：</strong> PM 又来说：新用户第一单，再打 9 折！
<ul>
<li>你再次入侵：<code>if (isNewUser) &#123; price = price * 0.9 &#125; else if (isDoubleEleven) &#123; ... &#125;</code></li>
</ul></li>
<li><strong>V4（VIP 会员）：</strong> PM：VIP 用户，折上再打 95 折！
<ul>
<li>你：<code>if (isVIP) &#123; ... &#125; else if (isNewUser) &#123; ... &#125; else if ...</code></li>
</ul></li>
</ul>
<p><code>CalculatePrice</code> 方法变成了 500 行的 if-else
怪物。它腐化了。</p>
<ul>
<li><strong>认知负荷</strong>：没人（包括你自己）能说清一个价格到底是怎么算出来的。</li>
<li><strong>测试灾难</strong>：你需要 <code>2*2*2=8</code>
种，甚至更多的组合来测试所有规则。</li>
<li><strong>维护地狱</strong>：PM 让你去掉双十一，保留
VIP，你得小心翼翼地去<strong>修改</strong> <code>CalculatePrice</code>
这个函数，删多删少咱也就不好说了。</li>
</ul>
<p>我们的解决方案是：<strong>策略模式 (Strategy Pattern)</strong></p>
<ul>
<li><strong>不变的本质是什么？</strong>
订单价格需要被<strong>一系列规则</strong>所计算。</li>
<li><strong>易变的是什么？</strong> 规则本身（今天双十一，明天
618）。</li>
</ul>
<p>我们要抽象的，就是<strong>规则</strong>这个<strong>易变</strong>的东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. &quot;抽象&quot; 出 &quot;契约&quot;：一个 &quot;促销规则&quot; (What)</span></span><br><span class="line"><span class="keyword">type</span> PromotionPolicy <span class="keyword">interface</span> &#123;</span><br><span class="line">    Apply(order *Order) *AppliedDiscount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &quot;不变的本质&quot; (OrderService)</span></span><br><span class="line"><span class="comment">// 它 &quot;不知道&quot; 任何具体规则，它只 &quot;认识&quot; 契约</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 它只 &quot;聚合&quot; 了一个 &quot;规则列表&quot;</span></span><br><span class="line">    policies []PromotionPolicy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CalculatePrice(order *Order) &#123;</span><br><span class="line">    <span class="comment">// 业务核心：&quot;循环&quot; 应用所有规则</span></span><br><span class="line">    <span class="keyword">for</span> _, policy := <span class="keyword">range</span> s.policies &#123;</span><br><span class="line">        discount := policy.Apply(order)</span><br><span class="line">        order.ApplyDiscount(discount)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. &quot;易变的实现&quot; (How)</span></span><br><span class="line"><span class="comment">// 每一个 &quot;规则&quot; 都是一个 &quot;独立的实现&quot;</span></span><br><span class="line"><span class="keyword">type</span> DoubleElevenPolicy <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *DoubleElevenPolicy)</span></span> Apply(order *Order) *AppliedDiscount &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDoubleEleven) &#123; <span class="comment">/* ... 8折逻辑 ... */</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewUserPolicy <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *NewUserPolicy)</span></span> Apply(order *Order) *AppliedDiscount &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNewUser) &#123; <span class="comment">/* ... 9折逻辑 ... */</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... VIPPolicy, SixEighteenPolicy ...</span></span><br></pre></td></tr></table></figure>
<p>收益是什么：</p>
<ul>
<li><strong>腐化被阻止了：</strong> 你的 <code>OrderService</code>
不会再变了。它变得<strong>极其稳定、干净、且纯粹</strong>。</li>
<li><strong>开闭原则的实现：</strong>
<ul>
<li>PM 让你去掉双十一？你只需要在 <code>policies</code>
列表里，<strong>删除</strong> <code>DoubleElevenPolicy</code>
即可。<strong>核心业务代码 0 修改</strong>。</li>
<li>PM 让你新增 618？你只需要<strong>新建</strong>一个
<code>SixEighteenPolicy.go</code>
文件，然后加到列表里。<strong>核心业务代码 0 修改</strong>。</li>
</ul></li>
</ul>
<p>这就是业务抽象的第一个巨大价值：<strong>用组合 (Composition) 代替修改
(Modification)，隔离核心与规则。</strong></p>
<hr />
<p><strong>痛点二：上帝服务 —— 业务流程的膨胀</strong></p>
<p>还是 <code>OrderService</code>。</p>
<ul>
<li><strong>V1（上线）：</strong> <code>CreateOrder</code>
逻辑很简单：<code>repo.Save(order)</code>。</li>
<li><strong>V2（“通知”）：</strong> PM
跑来说：订单创建后，要给用户发个短信！
<ul>
<li>你入侵了
<code>CreateOrder</code>：<code>repo.Save(order); sms.Send(...)</code></li>
</ul></li>
<li><strong>V3（加积分）：</strong> PM
又来说：发短信后，顺便给用户加个积分！
<ul>
<li>你再次入侵：<code>...; sms.Send(...); loyalty.AddPoints(...)</code></li>
</ul></li>
<li><strong>V4（通知履约）：</strong>
PM：加完积分，还要通知一下履约中台（WMS）！”
<ul>
<li>你：<code>...; loyalty.AddPoints(...); wms.Notify(...)</code></li>
</ul></li>
</ul>
<p><code>CreateOrder</code> 方法变成了上帝方法。它什么都干。</p>
<ul>
<li><strong>职责膨胀：</strong> <code>OrderService</code>
不仅要管"订单"，它现在还被迫认识了"短信"、"积分"和"履约"。<strong>它高耦合了</strong>。</li>
<li><strong>事务地狱：</strong> "积分"挂了，<code>CreateOrder</code>
事务要不要回滚？"短信"超时了，要不要让用户多等 30 秒？</li>
<li><strong>测试灾难：</strong>
为了测试"创建订单"，你<strong>被迫</strong>要 Mock <code>sms</code>,
<code>loyalty</code>, <code>wms</code> 三个外部依赖。</li>
</ul>
<p>我们的解决方案是：<strong>领域事件 (Domain Events)</strong></p>
<ul>
<li><strong>不变的本质是什么？</strong> <code>OrderService</code>
的<strong>核心职责</strong>
只有一个：<strong>创建订单</strong>（即，保证"订单"这个聚合根的状态一致性）。</li>
<li><strong>易变的是什么？</strong>
订单创建后引发的下游副作用（短信、积分、履约...）。</li>
</ul>
<p>我们要抽象的，就是<strong>副作用</strong>这个<strong>易变</strong>的东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. &quot;抽象&quot; 出 &quot;契约&quot;：一个 &quot;事件&quot; (What)</span></span><br><span class="line"><span class="keyword">type</span> OrderCreatedEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">    OrderID <span class="type">string</span></span><br><span class="line">    UserID  <span class="type">string</span></span><br><span class="line">    Time    time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &quot;不变的本质&quot; (OrderService)</span></span><br><span class="line"><span class="comment">// 它 &quot;不认识&quot; 任何下游，它只 &quot;认识&quot; 事件</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">    repo      OrderRepository</span><br><span class="line">    publisher EventPublisher <span class="comment">// &lt;-- 抽象的 &quot;事件发布器&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CreateOrder(order *Order) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 核心职责：保证状态一致性</span></span><br><span class="line">    <span class="keyword">if</span> err := s.repo.Save(order); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 核心职责：发布 &quot;已发生&quot; 的 &quot;事实&quot;</span></span><br><span class="line">    event := &amp;OrderCreatedEvent&#123;OrderID: order.ID, ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. &quot;异步&quot; 发布，与 &quot;下游&quot; 解耦</span></span><br><span class="line">    <span class="comment">// (它可以是 Kafka, 也可以是 RabbitMQ, 甚至是内存 channel)</span></span><br><span class="line">    s.publisher.Publish(event)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CreateOrder 的 &quot;职责&quot; 到此 &quot;结束&quot;！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. &quot;易变的实现&quot; (How)</span></span><br><span class="line"><span class="comment">// 每一个 &quot;副作用&quot; 都是一个 &quot;独立的订阅者&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;短信&quot; 服务 (一个独立的微服务，或独立的 goroutine)</span></span><br><span class="line"><span class="keyword">type</span> SMSSubscriber <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SMSSubscriber)</span></span> OnOrderCreated(event *OrderCreatedEvent) &#123;</span><br><span class="line">    <span class="comment">// ... sms.Send(...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;积分&quot; 服务</span></span><br><span class="line"><span class="keyword">type</span> LoyaltySubscriber <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *LoyaltySubscriber)</span></span> OnOrderCreated(event *OrderCreatedEvent) &#123;</span><br><span class="line">    <span class="comment">// ... loyalty.AddPoints(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收益是什么：</p>
<ul>
<li><strong>上帝服务被拆解了：</strong> <code>OrderService</code>
的职责被<strong>净化</strong>了。它回到了它不变的本质——只管"订单"。</li>
<li><strong>高内聚、低耦合的实现：</strong>
<ul>
<li>PM 让你<strong>去掉</strong>短信通知？你只需要<strong>下线</strong>
<code>SMSSubscriber</code> 即可。<code>OrderService</code>
<strong>毫不知情</strong>。</li>
<li>PM
让你<strong>新增</strong>财务对账通知？你只需要<strong>新建</strong>一个
<code>FinanceSubscriber</code> 即可。<code>OrderService</code>
<strong>毫不知情</strong>。</li>
</ul></li>
</ul>
<hr />
<p>我们总结一下，技术抽象是在实现（How）层面做<strong>替换</strong>（<code>MockRepo</code>
替换
<code>MySQLRepo</code>）。而业务抽象是在逻辑（What）层面做<strong>组合</strong>和<strong>解耦</strong>，这里我给出了
2 个思路：</p>
<ul>
<li><strong>策略模式（应对规则）：</strong> 当 <code>if-else</code>
开始腐化你的<strong>核心算法</strong>时，把<strong>规则
(Rules)</strong>抽象成<strong>策略</strong>，用<strong>组合</strong>代替<strong>修改</strong>。</li>
<li><strong>领域事件（应对流程）：</strong>
当下游开始污染你的<strong>核心职责</strong>时，把<strong>副作用 (Side
Effects)</strong>抽象成<strong>事件</strong>，用<strong>发布/订阅</strong>代替<strong>直接调用</strong>。</li>
</ul>
<h3 id="接口定义在哪">接口定义在哪</h3>
<p>这里我想再多谈一下接口定义在哪里的问题，这会涉及到一组概念：<strong>需求方接口</strong>和<strong>提供方接口</strong>。这也是我在阅读了《软件设计·从专业到卓越》一书后，觉得收获非常大的地方，从那之后，这组概念一直是指导我进行业务抽象和接口定义的核心思想武器。</p>
<p>前面我们提到了要为 <code>OrderService</code> 配一个
<code>OrderRepository</code>
接口，以实现可测试性、扩展时不污染业务和可控的外部依赖。这里我想提出一个问题：<font color="red"><code>OrderRepository</code>
是定义在 service 层还是定义在 repository 层？</font></p>
<p>答案是应该定义在 service 层！这可能会有一点反直觉！</p>
<p>如果定义在了 repository，那就说明 service 依赖了
repository，不管你依赖的是接口，还是具体的实现，都是依赖，在 Go
语言里面的体现就是你需要在 service package 中 import 关于 repository
的东西。</p>
<p>但是如果定义在 service 层，那 service package 中将不会存在任何关于
repository 的引用的，你只需要在依赖注入的时候去 repository 层找到能实现
service 要求的接口实现即可，这个时候反而是 repository 依赖了
service（的要求），也就是所谓的<strong>依赖倒置原则 (DIP)</strong>！</p>
<p>那为什么要这样呢？我们前面提到了接口抽象就是定义契约，那这个契约由谁来定呢？应该由需求方来定义，因为只有需求方，才知道自己需要什么东西。<code>OrderService</code>
需要一个 <code>Save(order)</code> 的方法。它不需要（也不应该）关心
<code>MySQLOrderRepo</code> 还提供了（或被迫实现了）其他 10
个它用不到的方法（比如 <code>GetConnectionPoolStats</code>）。</p>
<p>关于需求方接口和提供方接口的更进一步阐述，感兴趣的读者可以阅读我之前整理的笔记：<a
target="_blank" rel="noopener" href="https://www.notion.so/vs-f7b7f03169f14ce39c1b1e3aaf64cf6f?pvs=74">需求方接口
vs. 提供方接口</a>，这里就不赘述了。</p>
<h3 id="抽象的时机">抽象的时机</h3>
<p>前面我们总结了抽象的作用、难点和核心，也在技术和业务两个层面进行了展开并给出了一些切实有效的实施建议。我们已经知道"抽"什么（变化），但什么时候"抽"呢？那最后我们就来谈一谈抽象的时机，即如何尽可能减少过早或过度抽象？</p>
<p>我觉得可以遵循一个原则（<strong>收益 &gt;
付出</strong>）两个策略：</p>
<ul>
<li><strong>策略一：为测试而抽象。</strong>这是刚需，当你的判断出一个业务逻辑值得撰写单元测试的时候，你为了让它（<code>OrderService</code>）可被单元测试，你必须能够替换它的依赖（<code>OrderRepository</code>）。</li>
<li><strong>策略二：事不过三原则。</strong>这是对抗过度抽象的最佳启发式规则。
<ul>
<li><strong>第一次</strong>：你写了一个功能，<strong>不要抽象</strong>。就写具体实现。坚守
<strong>YAGNI</strong> (You Ain't Gonna Need It) 原则。</li>
<li><strong>第二次</strong>：你写一个类似功能，你可能会复制-粘贴-修改。<strong>忍住，还是不要抽象</strong>。但你要开始警惕了。</li>
<li><strong>第三次</strong>：当你复制-粘贴第三次时，说明<strong>变化的模式</strong>已经稳定出现。此时，你不再是猜测变化，你是在响应已经发生的变化。<strong>这是抽象的最佳时机。</strong>
从具体的代码中提炼出抽象的接口，远比凭空设计一个抽象要靠谱得多。</li>
</ul></li>
</ul>
<h2 id="分治">分治</h2>
<p>分治 (Decomposition)
的第一性原理是将一个大规模的、难以直接处理的大问题，拆解为一系列可独立解决的小问题，然后通过组合这些小问题的解，来得到大问题的解。</p>
<p>这个道理我们都懂，因为人脑的认知负荷有限。一个庞大且 All-in-One
的系统，其内部状态和依赖关系的组合呈指数级增长，很快会超过任何工程师（或团队）的处理上限。</p>
<p>在我的三年经验里，我最恐惧的，莫过于在 💩
代码中，一头扎进一个几千行的函数中：</p>
<ul>
<li>你根本不知道它的<strong>主线</strong>是什么，因为
<code>if-else</code>
的<strong>支线</strong>已经把它变成了意大利面条。</li>
<li>你不敢<strong>重构</strong>，因为你根本不知道你手里这个小问题，是多少个大问题共享的<strong>内脏</strong>，负负得正你受得了吗？</li>
<li>你无法<strong>测试</strong>，因为你连<strong>单元</strong>的边界都找不到。</li>
</ul>
<h3 id="分治的本质">分治的本质</h3>
<p>在我看来，分治的本质在于治，而不在于分。<strong>分（divide）只是手段，而治（Conquer）才是目的</strong>。</p>
<p>"分"（Divide）是为了什么？</p>
<ul>
<li><p>降低认知负荷</p></li>
<li><p>隔离变化</p></li>
<li><p>提高可测试性</p></li>
<li><p>实现复用</p></li>
</ul>
<p>但这些都是为了"治"（Conquer）服务的：</p>
<ul>
<li><p>能够独立理解每个部分</p></li>
<li><p>能够独立开发每个部分</p></li>
<li><p>能够独立测试每个部分</p></li>
<li><p>能够独立修改每个部分</p></li>
<li><p>最终能够有效地控制复杂度</p></li>
</ul>
<p>如果只"分"不"治"，就会出现：</p>
<ul>
<li><p>过度拆分，反而增加复杂度</p></li>
<li><p>形式上分离，但依赖关系混乱</p></li>
<li><p>看起来模块化，但实际上改一处牵一发而动全身</p></li>
</ul>
<h3 id="分治的边界">分治的边界</h3>
<p><strong>分治最大的风险，是错误的边界划分。</strong>一个错误的分治，即将一个本应内聚的整体强行拆开，这非但不能降低复杂度，反而会因为引入高耦合和通信开销（如不必要的网络调用），而增加了系统的意外复杂度。</p>
<p>关于分的边界，我个人觉得可以从两个层级进行考虑：</p>
<ul>
<li>代码层级：单一职责（SRP）</li>
<li>系统层级：限界上下文（Bounded Context）</li>
</ul>
<hr />
<p>在代码级别，我们面对的问题是什么？是<strong>变更</strong>。一个软件的生命周期中，最大的成本是维护，而维护的核心就是应对变更需求。</p>
<blockquote>
<p>A class should have only one reason to change. —— Robert C. Martin
(Uncle Bob)</p>
<p>一个类应该只有一个变更的理由。</p>
</blockquote>
<ul>
<li><strong>分 (Divide)：</strong> 如何分？SRP
告诉我们，<strong>变更的理由 (Reason to Change)
就是你分的边界。</strong>
<ul>
<li><strong>问题：</strong> 假设一个 <code>Employee</code>
类，它既负责计算薪酬 (A 理由：财务规则变更)，又负责保存数据到数据库 (B
理由：DBA 变更表结构)，还负责生成报表 (C 理由：HR 变更报表格式)。</li>
<li><strong>复杂度：</strong> 这 3 个理由（A, B,
C）被耦合在同一个类里。A 的变更可能会破坏 B 的功能；B 的变更又可能影响
C。这就是 <span class="math inline">\(N^2\)</span> 复杂度的雏形。</li>
</ul></li>
<li><strong>治 (Conquer)：</strong> 我们将这个大问题分解。
<ul>
<li><code>PayrollCalculator</code> （只因 A 而变）</li>
<li><code>EmployeeRepository</code> （只因 B 而变）</li>
<li><code>EmployeeReporter</code> （只因 C 而变）</li>
</ul></li>
<li><strong>合 (Combine)：</strong>
通过清晰的接口将它们组合起来，完成完整的业务。</li>
</ul>
<p>所以在代码级别，<strong>SRP
就是分治思想在管理变更复杂度这个特定场景下的应用。</strong>
它的分是<strong>以"变更的理由"为边界</strong>，把不同变更轴心上的逻辑（职责）隔离开，从而实现高内聚、低耦合，降低代码的认知和耦合复杂度。</p>
<hr />
<p>在系统级别（特别是大型企业应用），我们面对的问题是什么？是<strong>业务的规模和语义的模糊性</strong>。当一个系统大到需要几十上百人协作时，最大的问题不再是"变更理由"，而是"我们说的'客户'是同一个东西吗？"</p>
<ul>
<li>销售团队的客户 (Customer)：有购买意向的潜在个体。</li>
<li>客服团队的客户 (Customer)：有服务工单的已注册用户。</li>
<li>财务团队的客户 (Customer)：有付款记录的法律实体。</li>
</ul>
<p>如果试图建立一个统一的 God Model
来满足所有人，这个模型将变得无比复杂、充满
<code>if-else</code>，并且对所有人来说都是错的。</p>
<blockquote>
<p>领域驱动设计（DDD）提出的限界上下文（Bounded
Context）就是来解决这个问题的。</p>
</blockquote>
<p><strong>分 (Divide)：</strong> 如何分？BC
告诉我们，<strong>业务的领域边界和团队的组织边界就是你分的边界。</strong></p>
<ul>
<li><strong>问题：</strong> 试图用一个统一模型描述整个企业的业务。</li>
<li><strong>复杂度：</strong> 语义冲突（Semantic
Conflict）和组织沟通的开销（<span class="math inline">\(N^2\)</span>
沟通路径）。</li>
</ul>
<p><strong>治 (Conquer)：</strong>
我们将这个大领域分解为多个子领域。</p>
<ul>
<li><strong>销售上下文 (Sales Context)：</strong>
在这个边界内，客户模型只包含销售所需的属性。</li>
<li><strong>客服上下文 (Support Context)：</strong>
在这个边界内，客户模型只包含服务所需的属性。</li>
<li><strong>财务上下文 (Billing Context)：</strong>
在这个边界内，客户模型只包含账务所需的属性。</li>
</ul>
<p><strong>合 (Combine)：</strong> 通过明确的上下文映射图（Context
Map），比如防腐层（ACL）或开放主机服务（OHS），来定义这些上下文之间的关系。</p>
<p>在系统级别，<strong>BC
就是分治思想在管理业务和语义复杂度这个特定场景下的应用。</strong>
它的分是<strong>以"语义一致性"为边界</strong>，把庞大的、模糊的业务领域分解为多个边界清晰、语义明确的子域，从而让每个子域（微服务）内部实现高内聚、低耦合。</p>
<h3 id="真正的分治">真正的分治</h3>
<p>坦白说，目前我在系统级别层面的分治能力还较为欠缺，这方面还需要更多的沉淀和学习，所以现在我还无法做更进一步的阐述。但是这里我想通过我过去工作中的一个例子，来尝试阐述一下我所认为的真正的分治。</p>
<p>在我所负责的游戏业务中，我们有一个接口负责游戏结算的，它所包含的需求（部分）功能大概如下：</p>
<blockquote>
<p>它要负责多款联机游戏模式的结算逻辑，即要计算成绩、保存成绩、更新历史荣誉，还要涉及师徒系统、任务系统的各个加成、奖励和活跃度更新，有时候还要涉及各种运营活动的发奖逻辑（而且它们发的奖励要在结算接口返回给客户端，不能纯异步）。</p>
</blockquote>
<p>HTTP 层简化的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Api)</span></span> Settle(c *gin.Context) &#123;</span><br><span class="line">	<span class="comment">// 参数解析</span></span><br><span class="line">  <span class="keyword">var</span> ps <span class="keyword">struct</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;ps); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化成绩</span></span><br><span class="line">	roomScorePtr, err := api.parseUploadScoreParam(&amp;ps)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理不同的游戏模式</span></span><br><span class="line">	<span class="keyword">if</span> mode == GameMode1 &#123;</span><br><span class="line">		<span class="comment">// 游戏模式1处理逻辑</span></span><br><span class="line">		result = api.processGameMode1(ctx, roomScorePtr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 游戏模式2处理逻辑</span></span><br><span class="line">		result = api.processGameMode2(ctx, roomScorePtr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">		eventbus.AsyncPublish(<span class="string">&quot;settle_game_mode_1&quot;</span>, roomScorePtr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务通知</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光这一层就存在了非常多的问题，具体来说：</p>
<ol type="1">
<li><p>混杂了三个抽象层次</p>
<ul>
<li><p>HTTP 层：参数绑定、响应构建</p></li>
<li><p>业务编排层：模式判断、流程控制</p></li>
<li><p>业务执行层：计分逻辑、事件发布、任务检查</p></li>
</ul></li>
<li><p>职责过载（至少 5 个职责）</p>
<ul>
<li><p>HTTP 请求处理</p></li>
<li><p>参数验证和解析</p></li>
<li><p>业务模式路由</p></li>
<li><p>副作用管理（事件发布、任务通知）</p></li>
<li><p>响应构建</p></li>
</ul></li>
</ol>
<p>业务逻辑层就更夸张了，几百行的意大利面条代码，这里我就不贴了，你可以想想得到，里面就是平铺直叙写把业务要的逻辑一行行实现起来。你可以会说，我把他们都抽成一个个函数，这样不就可以了吗？比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Api)</span></span> processGameMode1(ctx context.Context, score *Score) <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// 原来 500 行代码，现在拆成这样：</span></span><br><span class="line">  result1 := step1(ctx, score)</span><br><span class="line">  result2 := step2(ctx, score, result1)</span><br><span class="line">  result3 := step3(ctx, score, result2)</span><br><span class="line">  result4 := step4(ctx, score, result3)</span><br><span class="line">  result  := step5(ctx, score, result4)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来"分"了，但这种拆分没有实现"治理"，只是把混乱从一个地方搬到了五个地方。</p>
<p>❌ 无法独立理解：必须看完整流程才能理解每个函数</p>
<p>❌ 无法独立测试：每个函数都依赖上下文</p>
<p>❌ 无法独立修改：改一个函数会影响其他函数</p>
<p>❌ 无法独立复用：函数与特定流程强耦合</p>
<p>那怎样才算是真正的治理呢？我们可以从 4 个维度进行思考：</p>
<ul>
<li><p>可独立理解（认知治理）</p></li>
<li><p>可独立修改（演化治理）</p></li>
<li><p>可独立验证（测试治理）</p></li>
<li><p>可灵活组合（组合治理）</p></li>
</ul>
<blockquote>
<p>好的架构让复杂度可控 ——
不是消除复杂度（业务本来就复杂），而是让复杂度在每个局部都是可管理的。</p>
</blockquote>
<p>首先我们看认知治理：每个单元可以独立理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 无法独立理解（当前代码的问题）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processGameMode1</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 500+ 行代码</span></span><br><span class="line">    <span class="comment">// 既算分，又处理战队，又构建响应，又存储</span></span><br><span class="line">    <span class="comment">// 必须从头到尾读完才能理解任何一部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以独立理解</span></span><br><span class="line"><span class="keyword">type</span> ScoreCalculationProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    calculator ScoreCalculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ScoreCalculationProcessor)</span></span> Process(ctx context.Context, input *SettlementContext, result *SettlementResult) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 10行代码，一眼就能看懂：</span></span><br><span class="line">    <span class="comment">// 1. 遍历玩家</span></span><br><span class="line">    <span class="comment">// 2. 调用 calculator 计算分数</span></span><br><span class="line">    <span class="comment">// 3. 转换为奖励</span></span><br><span class="line">    <span class="comment">// 4. 存入 result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, player := <span class="keyword">range</span> input.Players &#123;</span><br><span class="line">        score := p.calculator.Calculate(player, input)</span><br><span class="line">        reward := p.calculator.ConvertToReward(score)</span><br><span class="line">        result.PlayerRewards[player.ID] = &amp;PlayerReward&#123;</span><br><span class="line">            PlayerID:    player.ID,</span><br><span class="line">            BaseReward:  reward,</span><br><span class="line">            TotalReward: reward.Clone(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;治理&quot;的体现：</span></span><br><span class="line"><span class="comment">// - 不需要理解 HTTP 层怎么工作</span></span><br><span class="line"><span class="comment">// - 不需要理解其他 Processor 做什么</span></span><br><span class="line"><span class="comment">// - 不需要理解数据如何存储</span></span><br><span class="line"><span class="comment">// - 只需要理解：输入玩家分数 → 输出奖励</span></span><br></pre></td></tr></table></figure>
<p>再来看演化治理：每个单元可以独立修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 无法独立修改</span></span><br><span class="line"><span class="comment">// 当前代码：要修改师徒加成逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processGameMode1</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 150行其他逻辑 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 师徒逻辑埋在这里</span></span><br><span class="line">    <span class="keyword">if</span> masterRelation != <span class="literal">nil</span> &#123;</span><br><span class="line">        bonus = baseReward * <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 又是100行其他逻辑 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：</span></span><br><span class="line"><span class="comment">// 1. 要修改师徒加成率，必须找到这段代码（在200+行中定位）</span></span><br><span class="line"><span class="comment">// 2. 修改后要测试整个 processGameMode1（影响面不清晰）</span></span><br><span class="line"><span class="comment">// 3. 无法确定是否影响了其他逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以独立修改</span></span><br><span class="line"><span class="keyword">type</span> MasterApprenticeProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    masterSvc MasterApprenticeService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MasterApprenticeProcessor)</span></span> Process(...) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 所有师徒逻辑都在这里</span></span><br><span class="line">    <span class="comment">// 修改时：</span></span><br><span class="line">    <span class="comment">// 1. 直接定位到这个文件</span></span><br><span class="line">    <span class="comment">// 2. 只需要测试这个 Processor</span></span><br><span class="line">    <span class="comment">// 3. 明确不会影响其他逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;治理&quot;的体现：</span></span><br><span class="line"><span class="comment">// - 需求变更有明确的修改边界</span></span><br><span class="line"><span class="comment">// - 影响范围可控</span></span><br><span class="line"><span class="comment">// - 回归测试范围可控</span></span><br></pre></td></tr></table></figure>
<p>再来看测试治理：每个单元可以独立验证。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 无法独立验证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessGameMode1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 要测试师徒加成，需要：</span></span><br><span class="line">    <span class="comment">// - 准备完整的房间数据</span></span><br><span class="line">    <span class="comment">// - Mock 所有数据库调用</span></span><br><span class="line">    <span class="comment">// - Mock 排名系统</span></span><br><span class="line">    <span class="comment">// - Mock 任务系统</span></span><br><span class="line">    <span class="comment">// - Mock 活动系统</span></span><br><span class="line">    <span class="comment">// ... 可能需要 500+ 行测试代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而且无法精确测试师徒加成逻辑</span></span><br><span class="line">    <span class="comment">// 只能测试整体是否工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以独立验证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMasterApprenticeProcessor</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只需要 mock 一个接口</span></span><br><span class="line">    mockSvc := &amp;MockMasterApprenticeService&#123;&#125;</span><br><span class="line">    processor := &amp;MasterApprenticeProcessor&#123;masterSvc: mockSvc&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备最小化的输入</span></span><br><span class="line">    input := &amp;SettlementContext&#123;&#125;</span><br><span class="line">    result := &amp;SettlementResult&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    err := processor.Process(ctx, input, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精确验证师徒加成逻辑</span></span><br><span class="line">    assert...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;治理&quot;的体现：</span></span><br><span class="line"><span class="comment">// - 20行代码就能测试核心逻辑</span></span><br><span class="line"><span class="comment">// - 测试用例清晰（输入100金币，加成20%，得到20金币）</span></span><br><span class="line"><span class="comment">// - 测试快速（无需数据库，无需 HTTP）</span></span><br><span class="line"><span class="comment">// - 测试稳定（不依赖外部状态）</span></span><br></pre></td></tr></table></figure>
<p>最后看组合治理：整体可以灵活组装。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 无法灵活组合</span></span><br><span class="line"><span class="comment">// 当前代码：要支持新的游戏模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *Api)</span></span> Settle(c *gin.Context) &#123;</span><br><span class="line">    <span class="keyword">if</span> mode == GameMode1 &#123;</span><br><span class="line">        result = api.processGameMode1(...)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == GameMode2 &#123;</span><br><span class="line">        result = api.processGameMode2(...)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == GameModeNew &#123;</span><br><span class="line">        <span class="comment">// 要添加新模式，必须：</span></span><br><span class="line">        <span class="comment">// 1. 修改这个主流程</span></span><br><span class="line">        <span class="comment">// 2. 实现一个新的 processGameModeXXX 函数</span></span><br><span class="line">        <span class="comment">// 3. 每个函数内部重复大量相同逻辑</span></span><br><span class="line">        result = api.processGameModeXXX(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以灵活组合</span></span><br><span class="line"><span class="comment">// 新增游戏模式时：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建新的 Pipeline（不需要修改现有代码）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *SettlementPipelineFactory)</span></span> CreateNewModePipeline() *SettlementPipeline &#123;</span><br><span class="line">    <span class="keyword">return</span> NewSettlementPipeline(</span><br><span class="line">        f.scoreCalc,       <span class="comment">// 复用</span></span><br><span class="line">        f.ranking,         <span class="comment">// 复用</span></span><br><span class="line">        f.activity,        <span class="comment">// 复用</span></span><br><span class="line">        <span class="comment">// 不需要师徒系统</span></span><br><span class="line">        <span class="comment">// 不需要任务系统</span></span><br><span class="line">        NewSpecialProcessor(), <span class="comment">// 新模式特有的处理器</span></span><br><span class="line">        f.persistence,     <span class="comment">// 复用</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册新接口</span></span><br><span class="line">router.POST(<span class="string">&quot;/game/newmode/settle&quot;</span>, &amp;NewModeHandler&#123;</span><br><span class="line">    pipeline: factory.CreateNewModePipeline(),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;治理&quot;的体现：</span></span><br><span class="line"><span class="comment">// - 90%的代码复用（Processor 都是通用的）</span></span><br><span class="line"><span class="comment">// - 只需要实现 10%的特殊逻辑</span></span><br><span class="line"><span class="comment">// - 不影响现有模式</span></span><br><span class="line"><span class="comment">// - 清晰的扩展点</span></span><br></pre></td></tr></table></figure>
<p>这里我给一个分治后的架构供各位读者参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">第1层：接口隔离</span><br><span class="line">  ├── /game/mode1/settle</span><br><span class="line">  ├── /game/mode2/settle</span><br><span class="line">  └── /game/mode3/settle</span><br><span class="line"></span><br><span class="line">第2层：HTTP处理层</span><br><span class="line">  ├── 请求解析</span><br><span class="line">  ├── 调用业务逻辑层</span><br><span class="line">  └── 响应构建</span><br><span class="line"></span><br><span class="line">第3层：应用逻辑层</span><br><span class="line">  ├── 调用Pipeline</span><br><span class="line">  ├── 异步副作用处理</span><br><span class="line">  └── 返回结果</span><br><span class="line"></span><br><span class="line">第4层：Pipeline编排层</span><br><span class="line">  └── 按游戏模式组装不同的Processor链</span><br><span class="line"></span><br><span class="line">第5层：业务处理层（独立的Processor）</span><br><span class="line">  ├── ScoreCalculationProcessor 分数计算</span><br><span class="line">  ├── MasterApprenticeProcessor 师徒系统</span><br><span class="line">  ├── TaskSystemProcessor       任务系统</span><br><span class="line">  ├── ActivityProcessor         活动系统</span><br><span class="line">  ├── RankingUpdateProcessor    排名系统</span><br><span class="line">  ├── AchievementProcessor      成就系统</span><br><span class="line">  ├── HonorUpdateProcessor      荣誉系统</span><br><span class="line">  └── PersistenceProcessor      成绩保存</span><br><span class="line"></span><br><span class="line">第6层：领域服务层</span><br><span class="line">  ├── ScoreCalculator           分数计算</span><br><span class="line">  ├── MasterApprenticeService   师徒系统</span><br><span class="line">  ├── TaskService               任务服务</span><br><span class="line">  ├── ActivityService           活动服务</span><br><span class="line">  └── RankingService            排行榜服务</span><br></pre></td></tr></table></figure>
<p>好处显而易见：</p>
<ol type="1">
<li>职责彻底分离：每个 Processor 只做一件事，15-30
行代码就能看清楚逻辑。</li>
<li>可组合性：底层的业务逻辑层和领域服务层可以复用给各个不同的游戏模式。</li>
<li>可测试性：每个单元都非常小，依赖尽可能少，测试难度大大降低。</li>
<li>性能可观测性：管道可以实现自动记录每个 Processor
的耗时，可以精准定位性能瓶颈。</li>
<li>错误隔离：任何一个 Processor 失败，都能清晰知道是哪个环节出问题</li>
<li>并行优化：如果某些 Processor 之间没有依赖，可以并行执行。</li>
</ol>
<blockquote>
<p>[!IMPORTANT]</p>
<p>总结一下，"分"只是手段，"治"才是目的的深刻含义：</p>
<ul>
<li><p>不要为了拆分而拆分 ——
如果拆分后没有提升治理能力，那就是过度设计。</p></li>
<li><p>拆分的目标是治理 ——
每次拆分都要问：<strong>这样拆是否让问题更容易控制？</strong></p></li>
<li><p>治理的四个标准：</p>
<ul>
<li><p>可独立理解（认知治理）</p></li>
<li><p>可独立修改（演化治理）</p></li>
<li><p>可独立验证（测试治理）</p></li>
<li><p>可灵活组合（组合治理）</p></li>
</ul></li>
<li><p>好的架构让复杂度可控 ——
不是消除复杂度（业务本来就复杂），而是让复杂度在每个局部都是可管理的</p></li>
</ul>
<p>游戏结算接口的例子完美诠释了这一点：不是要把 800 行代码拆成 80
个函数，而是要把不可控的复杂度转化为可控的、独立的、可组合的单元。这才是真正的"治理"。</p>
</blockquote>
<h2 id="分层">分层</h2>
<p>分层和分治看起来很像，不过在我看来它们的侧重点还是有所不同的。在我看来，分治面临的是一个问题<strong>规模过大</strong>，导致单个处理单元（人、CPU、服务）无法在有效时间内解决，或者逻辑过于复杂以至于无法一次性正确实现。它的思路是分解、解决和合并。而分层面临的问题是系统的各个部分<strong>过度耦合</strong>。当一个模块的实现细节（比如换个数据库）会影响到另一个模块（比如
UI 界面）时，系统就变得僵化和脆弱。概括来说：</p>
<ul>
<li><strong>分治</strong>侧重于<strong>高内聚</strong>，其原则是按单一变更理由（SRP）将逻辑<strong>聚合</strong>到同一单元。</li>
<li><strong>分层</strong>侧重于<strong>低耦合</strong>，其原则是按技术关注点（SoC）<strong>管理依赖方向</strong>，隔离实现细节。</li>
</ul>
<p>OK，我们还是尝试回归到第一性原理上：</p>
<blockquote>
<p>[!important]</p>
<p>分层到底"分"的是什么呢？ —— 变化速率。</p>
</blockquote>
<p>分层的最终目的其实是<strong>隔离变化</strong>。一个好的分层设计，其核心标准是：<strong>当系统的一部分发生变化时，其他部分应该尽可能少地受到影响。</strong>要做到这一点，不仅仅是画出几个框框然后把代码扔进去那么简单。这需要一套严格的原则和实践。</p>
<p>做好分层，关键在于回答三个问题：<strong>① 按什么标准分？ ②
层与层如何对话？ ③ 谁能依赖谁？</strong></p>
<h3 id="分层的原则">分层的原则</h3>
<h4
id="原则一按什么分以变化的速率作为切分标准">原则一：按什么分？以变化的速率作为切分标准</h4>
<p>这是最根本的原则。为什么表现层和数据访问层要分开？因为 UI
界面（颜色、布局）<strong>变化的频率和原因</strong>，与数据存储方式（用
MySQL 还是
PostgreSQL）<strong>变化的频率和原因</strong>是完全不同的。</p>
<ul>
<li><strong>高内聚：</strong>
把变化原因和速率相近的代码放在同一层。例如所有处理 HTTP 请求、解析
JSON、参数校验的代码，都属于表现层的职责，它们一起变化。</li>
<li><strong>低耦合：</strong>
变化速率不同的代码，应该被坚决地<strong>隔离</strong>在不同的层。</li>
</ul>
<p>很多失败的分层，是因为分错了。例如，在业务逻辑层（Service）里，既有核心业务规则（订单总价
&gt; 100 才能免运费），又混杂着数据格式的转换（把 <code>Entity</code>
转成 <code>DTO</code>）。核心业务规则（免运费策略）可能几个月不变，而
<code>DTO</code>（返回给 App 的 JSON
格式）可能每周都在变。把它们混在一起，就违反了按变化速率切分的原则。</p>
<h4 id="原则二谁依赖谁依赖倒置原则">原则二：谁依赖谁？依赖倒置原则</h4>
<p>这是<strong>做好分层</strong>的关键。相信不少读者跟我一样，在一开始学习
MVC 架构的时候，都是遵循传统的朴素分层：表现层 → 业务层 →
数据层。这种依赖是<strong>具体</strong>的，即表现层<strong>直接依赖</strong>业务层的<strong>具体实现</strong>；业务层<strong>直接依赖</strong>数据层的<strong>具体实现</strong>。例如，<code>UserService</code>
直接
<code>new UserRepositoryImpl()</code>）。它的问题在于业务逻辑层（高层策略）<strong>依赖</strong>了数据访问层（底层细节）。当底层细节（如数据库实现）更换时，业务逻辑层也可能需要修改。</p>
<p>而依赖倒置就不一样了，它的操作过程大致如下：</p>
<ol type="1">
<li><strong>高层（业务逻辑层）定义需求方接口（Interface）</strong>。例如：
<code>UserService</code> 定义一个 <code>IUserRepository</code>
接口，接口中声明它需要的方法，如
<code>User GetUser(string id)</code>。</li>
<li><strong>高层（业务逻辑层）只依赖这个需求方接口。</strong><code>UserService</code>
的代码只认识 <code>IUserRepository</code>，完全不知道数据库、Redis
或什么 <code>Impl</code> 的存在。</li>
<li><strong>低层（数据访问层）去实现这个需求方接口。</strong><code>UserRepositoryImpl</code>
实现 <code>IUserRepository</code> 接口。</li>
<li>通过依赖注入将<strong>具体实现</strong>注入给高层。</li>
</ol>
<p>系统的核心价值在于其<strong>业务规则</strong>（高层策略），而不是它用什么数据库（底层细节）。因此，<strong>策略不应该依赖细节，而应该是细节依赖于策略</strong>。这才是分层的精髓：保护高价值的<strong>业务逻辑</strong>不受低价值的<strong>实现细节</strong>的污染。</p>
<h4
id="原则三层与层如何对话严格的接口与封装">原则三：层与层如何对话？严格的接口与封装</h4>
<p>层与层之间绝对不能越级访问或泄露实现细节。上层只应该知道它所需要的<strong>最小接口</strong>。当数据需要跨越层的边界时，使用数据传输对象（DTO
/ VO / PO）来传递，而不是直接传递内部实现。</p>
<blockquote>
<p>在简单业务中，这可能看起来很繁琐，但这是保持分层纯洁性的代价，需要权衡，没有绝对的答案。</p>
</blockquote>
<h3 id="分层坏味道">分层坏味道</h3>
<p>在我的工作过程中，曾经见到过不少的坏分层，导致各种循环依赖、层次混乱，被它们折磨够呛，我将它们进行简单总结，如果在你的代码中也发现了这些情况，那可能就需要引起重视了。</p>
<ol type="1">
<li><strong>泄露的抽象</strong>：业务逻辑层（Service）向上（Controller）返回了一个<strong>数据库
ORM 的实体对象</strong>。这逼得 Controller
被迫知道了"数据库长什么样"，表现层和数据层被耦合了。</li>
<li><strong>层跳跃</strong>：Controller 为了图方便，绕过了
Service，<strong>直接调用</strong>了 Repository
来获取数据。短期内看似更简洁，实际上导致了业务逻辑被架空。未来如果这个获取数据需要增加权限校验或缓存逻辑（本应在
Service 层做），Controller 里的这处调用就会被遗漏。</li>
<li><strong>胖瘦不均</strong>：要么是 Service
层非常"瘦"，里面没有任何业务逻辑（或干脆没有 Service
层），只是简单地调用 Repository 的
<code>save()</code>、<code>get()</code>。所有的业务逻辑（如校验、计算）都堆积在
Controller 层。要么一个 GodService
类包含了上万行代码，处理了几十种不相关的业务。这违反了高内聚原则，分层失去了意义。</li>
<li><strong>依赖反向</strong>：Repository <strong>反过来
<code>import</code></strong> 了 Service/Controller
的代码。这是最痛苦的，这会造成循环依赖，这在逻辑上是致命的，说明职责划分彻底混乱。</li>
</ol>
<h3 id="分层的典范">分层的典范</h3>
<p>在现代软件工程中，洋葱架构或整洁架构（Clean
Architecture）是依赖倒置原则的最佳实践。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/308528-20170714161640900-366868890.jpg"
alt="洋葱架构" />
<figcaption aria-hidden="true">洋葱架构</figcaption>
</figure>
<p>如上图所示，它将分层想象成一个洋葱：</p>
<ol type="1">
<li><p><strong>最中心：领域实体 (Entities)</strong></p>
<p>企业级的核心业务规则，最稳定，变化最少。</p></li>
<li><p><strong>第二层：用例/应用服务 (Use Cases / Application
Services)</strong></p>
<p>具体的业务流程，编排“实体”来完成一个操作（例如“用户注册”用例）。</p></li>
<li><p><strong>第三层：接口适配器 (Interface Adapters)</strong></p>
<p><code>Controller</code>、<code>Presenter</code>、<code>Repository</code>
的实现。它们是“翻译官”。</p></li>
<li><p><strong>最外层：框架与驱动 (Frameworks &amp;
Drivers)</strong></p>
<p>Web 框架 (Gin, Spring)、数据库 (MySQL)、UI (Web) 等。</p></li>
</ol>
<p><strong>这个架构的唯一规则：依赖箭头永远指向内部。</strong></p>
<ul>
<li><code>Controller</code> (外) 依赖 <code>Use Case</code> (内)。</li>
<li><code>Repository</code> (外) <strong>实现</strong>
<code>Use Case</code> (内) <strong>定义的接口</strong>。</li>
</ul>
<p>通过这种方式，最核心的业务逻辑（Entities 和 Use
Cases）<strong>完全不知道</strong>外部世界有 Web、有 MySQL
的存在。你可以把 Web 替换成命令行，把 MySQL
替换成内存数据库，而<strong>中心的业务代码一行都不用改</strong>。</p>
<p>这，就是做好分层的终极目标：<strong>保护核心业务逻辑，让其独立于外部实现细节而存在。</strong></p>
<h3 id="分层的实践">分层的实践</h3>
<p>在软件工程出现之前，分层早已是系统工程的基石。所以这一小节，我想借这个机会，梳理一下我们司空见惯的那些计算机核心技术和编程语言（Go/Rust），它们在哪些地方都用到了分层的思想。</p>
<h4 id="网络协议">网络协议</h4>
<p>最经典的分层实践就是 OSI 七层协议了，如下图所示。</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gt3mt2poj8j30u016idmo.jpg"
alt="OSI 七层网络协议" />
<figcaption aria-hidden="true">OSI 七层网络协议</figcaption>
</figure>
<p>在实践中，TCP/IP 四层协议对其进行了简化：</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gt3mt1ojy7j31gq0katcz.jpg"
alt="TCP/IP 四层协议 vs. OSI 七层协议" />
<figcaption aria-hidden="true">TCP/IP 四层协议 vs. OSI
七层协议</figcaption>
</figure>
<p>TCP/IP 四层协议完美践行了关注点分离（SoC）：</p>
<ul>
<li><strong>应用层</strong>
(HTTP)：<strong>只</strong>关注应用数据的语义（比如
<code>GET /user</code> 这个请求）。</li>
<li><strong>传输层</strong>
(TCP)：<strong>只</strong>关注进程到进程的可靠性（如三次握手、丢包重传）。</li>
<li><strong>网络层</strong>
(IP)：<strong>只</strong>关注主机到主机的路由寻址。</li>
<li><strong>数据链路层</strong>
(Ethernet)：<strong>只</strong>关注物理帧的相邻传输。</li>
</ul>
<p>并且它也严格执行了单向依赖的原则，上层（如
HTTP）<strong>依赖</strong>下层（TCP）提供的可靠字节流服务。但
TCP（下层）<strong>完全不</strong>认识（也<strong>不</strong>依赖）HTTP。这种分层带来的低耦合是革命性的：</p>
<ul>
<li>我们可以在不修改 TCP 和 IP 的情况下，发明新的应用层协议（如
WebSocket，gRPC）。</li>
<li>我们也可以在不修改 HTTP 和 TCP 的情况下，将网络层从 IPv4
<strong>无缝</strong>升级到 IPv6。</li>
</ul>
<h4 id="操作系统">操作系统</h4>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/System-Call-in-Operating-System.jpg"
alt="操作系统用户态与内核态" />
<figcaption aria-hidden="true">操作系统用户态与内核态</figcaption>
</figure>
<p>操作系统的用户态和内核态也是分层的杰作。</p>
<ul>
<li><strong>用户态 (User Mode)：</strong> 关注业务逻辑（例如，我们用 Go
编写 Web 程序）。</li>
<li><strong>内核态 (Kernel Mode)：</strong>
关注硬件资源管理（如进程调度、内存分配、I/O 驱动）。</li>
</ul>
<p>它们之间的层就是<strong>系统调用接口 (System Call
Interface)</strong>。我们的 Go 程序（上层）通过系统调用请求
I/O，它<strong>不需要</strong>（也<strong>不</strong>知道）内核（下层）是如何与
Intel SATA 驱动还是三星 NVMe 驱动的实现细节打交道的。这导致了我们的 Go
程序<strong>只</strong>依赖 Linux
内核这一层，因此它可以移植到运行在任何实现了 Linux 内核 API
的物理机器上，<strong>隔离</strong>了硬件这个<strong>易变</strong>的实现。</p>
<h4 id="数据库系统">数据库系统</h4>
<p>即使是一个单一的程序，比如我们常用的数据库系统
MySQL，其内部也是<strong>严格分层</strong>的。</p>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/6389433535043459524065439.png" /></p>
<ul>
<li><strong>查询解析/优化器 (Query Optimizer)：</strong>
<strong>只</strong>关注 SQL
语句的语义和执行计划（如决定使用哪个索引）。</li>
<li><strong>存储引擎 (Storage Engine) (如 InnoDB)：</strong>
<strong>只</strong>关注数据的物理存取（如如何在 B+
树上读/写、如何管理事务日志）。</li>
</ul>
<p>它们之间通过<strong>存储引擎 API</strong>
这一层来通信。这种分层，使得 MySQL
可以<strong>可插拔地</strong>替换存储引擎。<code>Query Optimizer</code>（上层）<strong>不</strong>依赖
<code>InnoDB</code>（下层）的实现，它只依赖契约。这就是为什么 MySQL
既可以支持 <code>InnoDB</code>（事务型）也可以支持
<code>MyISAM</code>（非事务型）。</p>
<h4 id="go-网络编程">Go 网络编程</h4>
<p>Go
的网络编程模型同样完美践行了关注点分离（SoC），下图自顶向下清晰地展示了这种分层：</p>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lh6uxgk3j21770u0773.jpg"
alt="Go 网络编程" />
<figcaption aria-hidden="true">Go 网络编程</figcaption>
</figure>
<ul>
<li><strong>L6: 业务层 (Goroutine &amp; 编码风格)：</strong>
只关注业务逻辑。开发者只需用同步阻塞的风格（如
<code>conn.Read()</code>）编写业务。</li>
<li><strong>L5: Go 并发调度层 (GMP 调度器)：</strong> 只关注 Goroutine
的并发调度。它隐藏了 L3（<code>netpoller</code>）的 I/O 事件机制，当 L3
报告 I/O 就绪时，它（GMP）负责唤醒对应的 L6（Goroutine）。</li>
<li><strong>L4: Go 协议层 (net 包)：</strong> 只关注 TCP/UDP/HTTP
等网络协议的实现，并提供了平台无关的 API（如
<code>net.Conn</code>）。</li>
<li><strong>L3: Go Runtime 适配层 (network poller)：</strong>
只关注跨平台 I/O 多路复用。它封装（Wrapping）并屏蔽了
L2（<code>epoll/kqueue/iocp</code>）的平台差异。</li>
<li><strong>L2: OS I/O 机制层 (epoll/kqueue/iocp)：</strong>
只关注高性能 I/O 事件的通知机制。</li>
<li><strong>L1: OS 协议/资源层 (socket)：</strong>
只关注传输层协议（TCP/UDP）的内核实现和资源管理（文件描述符）。</li>
</ul>
<p>并且它也严格执行了多重的单向依赖原则：</p>
<ul>
<li>L6（业务）依赖 L5（GMP）提供的并发能力。</li>
<li>L5（GMP）依赖 L3（netpoller）提供的 I/O 就绪通知。</li>
<li>L4（net 包）依赖 L3（netpoller）提供的跨平台 I/O 能力。</li>
<li>L3（netpoller）依赖 L2（epoll 等）提供的 OS 事件能力。</li>
<li>L2（epoll 等）依赖 L1（socket）提供的资源。</li>
</ul>
<p>这种分层带来的低耦合是革命性的：</p>
<ul>
<li>开发者可以在<strong>不修改</strong>业务代码的情况下，享受 Go Runtime
团队对协程调度或 network poller 的性能优化。</li>
<li>Go 团队也可以在<strong>不修改</strong> <code>net</code>
包的情况下，将 <code>network poller</code>适配到 Linux 最新的
<code>io_uring</code>，开发者<strong>无需</strong>改动任何代码即可获得性能提升。</li>
<li>最重要的是，开发者可以<strong>只</strong>关注
<code>goroutine-per-connection</code>
这种同步的业务逻辑，而<strong>不</strong>必关心 Epoll/Kqueue
这些异步非阻塞的底层实现细节，极大地降低了高性能网络编程的认知负荷。</li>
</ul>
<h2 id="模块化">模块化</h2>
<p>分治是在思维层面上将大问题拆分为多个小问题，而分层更多专注在技术层面上的关注点分离。那模块化呢？在我看来，模块化是将一个更加广泛的概念，它跟分治和分层一样，都是为了解决一个高复杂度问题所采取的抽象行为，只不过模块化它的产物更加具体化，比如拆分成一个个的微服务、同一个系统内部的多个
module/package，或是具体到一个个负责不同职责的类。</p>
<p>可以理解为分层是模块化的一个特定应用，它按照技术职责进行模块化区分，如果
UI
层、接口层、业务逻辑层、数据访问层等。而分治的某些场景下的落地实现就是模块化，比如微服务的拆分、业务系统不同组件的拆分等。</p>
<p>在我看来，模块化的终极目标就是老生常谈的：高内聚、低耦合。</p>
<ul>
<li>高内聚：一个模块只做一件事，并把它做好。</li>
<li>低耦合：模块之间的互不依赖，只通过接口进行交互。</li>
</ul>
<p>而要做好模块化，主要是要做好两步：</p>
<ol type="1">
<li>封装：隐藏秘密。把自己的内部实现（私有函数、辅助函数）藏好。</li>
<li>接口：做出承诺。只对外暴露一个清晰、稳定、最小化的接口（契约），告诉别人我能做什么。</li>
</ol>
<h3 id="模块化的实践">模块化的实践</h3>
<h4 id="硬件与计算机体系结构总线与-pcle">硬件与计算机体系结构：总线与
PCle</h4>
<p>在电脑的主板上，CPU、内存、显卡（GPU）、硬盘（SSD）都是独立的模块。</p>
<ul>
<li>接口：它们通过统一的总线（如 PCle）进行通信。PCle
就是一个标准化的接口。</li>
<li>封装：NVIDIA 只需要按照 PCle 接口规范设计显卡，它不知道知道 Intel 的
CPU 如何工作，Intel 的 CPU 也不需要知道显卡内部是如何渲染图形的。</li>
<li>高内聚：显卡高度内聚，只负责图形处理。</li>
<li>低耦合：这使得我们可以随意插拔、更换不同厂商的显卡或
SSD（只要接口兼容），而系统其他部分完全不受影响。</li>
</ul>
<h4 id="操作系统从驱动程序到微内核">操作系统：从驱动程序到微内核</h4>
<p>操作系统是模块化设计的殿堂。它面临的第一个史诗级挑战就是：世界上有成千上万种硬件（网卡、显卡、磁盘），操作系统如何支持它们，而不让自己崩溃？if
else 肯定是行不通的道路，那 Linux 给出的答案就是驱动程序架构。</p>
<ul>
<li>模块：硬件驱动程序（如 NVIDIA 显卡驱动、Intel 网卡驱动）</li>
<li>接口：由操作系统内核（如 Linux
Kernel）定义的一组标准化的函数调用。例如，块驱动设备必须实现
<code>read</code>、<code>write</code>、<code>ioctl</code>
等接口；网络驱动必须实现
<code>open</code>、<code>stop</code>、<code>xmit</code> 等接口。</li>
<li>封装：
<ul>
<li>OS 内核的封装：NVIDIA 不需要知道 Linux 进程调度器和
VFS（虚拟文件系统）的内部实现。它只需要知道内核提供的网络设备接口长什么样。</li>
<li>驱动的封装：Linux 内核不需要知道显卡芯片是如何通过 CUDA
核心进行计算的。内核只关心一件事：我已经把数据包给你了（调用
<code>xmit</code> 接口），请你把它发出去。</li>
</ul></li>
<li>高内聚/低耦合：内核与驱动是极端的低耦合。我们可以随意更新显卡驱动，而无需重新编译整个内核系统。反而，内核升级时，只要不改变驱动接口（保持
ABI 稳定），老的驱动模块就可以继续工作。</li>
</ul>
<h4 id="计算机网络tcpip-协议栈">计算机网络：TCP/IP 协议栈</h4>
<p>我们之前提到的 OSI 七层协议和 TCP/IP
四层协议，即是分层的完美实践体现，也是模块化的典范。协议栈中的每一层就是一个模块，它们之前都定义了数据传递接口，使得每一层的关注点分离，从而实现了高内聚低耦合。</p>
<h4 id="数据库系统sql-与存储">数据库系统：SQL 与存储</h4>
<p>数据库系统也是一样的，以 MySQL
为例，可插拔存储引擎架构就是模块化的完美体现。</p>
<ul>
<li>模块：存储引擎（如 InnoDB、MyISAM）和 SQL 解析/优化器（Server
层）。</li>
<li>接口：MySQL 定义了一套存储引擎
API。任何存储引擎，只要实现了这套标准接口，就可以被集成为 MySQL
中。</li>
<li>封装：
<ul>
<li>SQL 层的封装：优化器（Server
层模块）只负责生成最优的执行计划。它不需要知道 InnoDB 是如何实现 MVCC
的，也不需要知道 MyISAM 是如何存储索引的。它只需要通过接口手：请你从
<code>idx_user_name</code> 索引中取出数据。</li>
<li>引擎的封装：InnoDB
模块（存储引擎）只负责管理数据页、事务日志、锁。它不需要知道 SQL
是如何被解析和优化的。</li>
</ul></li>
<li>高内聚/低耦合：Server 层和 Storage Engine
层是两个高度解耦的模块。Server 层高度内聚，只负责 SQL
解析、优化、网络连接；InnoDB
高度内聚，只负责事务和存储。这完美将"如何解析和优化
SQL"和"如何存储和管理数据"这两个核心且复杂的关注点进行彻底分离，使得它们可以独立演进而互不干扰。</li>
</ul>
<h4 id="redis插件系统">Redis：插件系统</h4>
<p>Redis Modules 同样的模块化运用的典范。</p>
<ul>
<li>模块：可加载的 .so 动态库（如
RediSearch、RedisJSON、RedisGraph）。</li>
<li>接口：<code>redismodule.h</code> 头文件。Redis 核心暴露了一整套 C
API，允许模块向 Redis
注册新明了、操作内部数据结构、甚至实现新的数据类型。</li>
<li>封装：
<ul>
<li>Redis 核心的封装：RediSearch 模块（全文搜索引擎）不需要知道 Redis
是如何处理网络事件循环或 RDB 快照的。它只需要通过 API 说：请帮我注册一个
FT.SEARCH 命令。</li>
<li>模块的封装：Redis 核心完全不知道 RediSearch
内部是如何构建倒排索引的。它只知道 RediSearch
是一个可加载的黑盒模块。</li>
</ul></li>
<li>高内聚/低耦合：Redis 通过 Modules API 将核心 K-V
功能与扩展功能完美解耦。这既保证了核心的轻量与稳定，又提供了无限扩展性。</li>
</ul>
<h4 id="kafka管道与插头的分离">Kafka：管道与插头的分离</h4>
<p>Kafka
的核心（Borker）是一个高内聚的模块，它只做一件事：高吞吐、可持久化的日志系统。但
Kafka 面临的挑战是：<font color="red"><u>数据如何流入（例如从 MySQL
Binlog），又如何流出（例如到 S3）？</u></font>如果让 Kafka
核心团队去写所有这些连接器，他们包顶不住的，核心系统也会变得异常臃肿。那
Kafka 给出的答案就是 Kafka Connect 框架。</p>
<ul>
<li>模块：Connect
框架作为主模块，负责所有脏活累活，如容错、偏移量提交、并行化、REST
API。Connecor 作为子模块，如<code>debezium-connector-mysql</code> 是一个
Source 模块，<code>kafka-connect-s3</code> 是一个 Sink 模块。</li>
<li>接口：Kafka Connect 定义了一组 API，如
SourceConnector、SinkConnector、Converter 等 Java 接口。</li>
<li>封装：
<ul>
<li>Kafka 核心的封装：<code>debezium-connector-mysql</code>
模块不需要知道 Kafka Broker 是如何实现 Raft 协议或管理磁盘 Log
文件的。它只需要通过接口说：请把这个 Change Event（数据）发送到
mysql-binlog topic。</li>
<li>Connector 的封装：Kafka Broker 核心完全不知道 Debezium
是如何通过伪装成 MySQL 从库来读取 binlog 的。Broker
只认识标准的接口数据。</li>
</ul></li>
<li>高内聚低耦合：这种模块化使得 Kafka Broker
高度内聚，只负责高吞吐、可持久化的日志系统。所有与外部系统的集成全部被解耦到了
Connect 模块中，这使得 Kafka
成为了一个万能插座，任何系统都可以通过编写一个 Connector
模块来接入。</li>
</ul>
<h4 id="rag-与-ai-agent天生的模块化">RAG 与 AI Agent：天生的模块化</h4>
<p>LLM
作为一个封闭的大脑，它不会使用工作，也没有长期记忆，更不知道我们私有的一些内部文档和资料。为了
AI 能更好的服务我们的实际需求，RAG 和 AI Agent 应运而生。在我看来，RAG
和 AI Agent 的架构天生就是模块的。</p>
<p>RAG 最主要就是两个模块：</p>
<ul>
<li>Retriever（检索器模块）：只负责根据查询从知识库检索相关文档</li>
<li>Generator（生成器模块，即
LLM）：只负责根据给定的上下文和查询生成答案。</li>
</ul>
<p>这使得我们可以随意替换不同的向量数据库、检索策略和 LLM。</p>
<p>AI Agent 最主要的是三个模块：</p>
<ul>
<li>Orchestrator（协调器模块 ）只负责解析 LLM 意图、循环执行。</li>
<li>LLM（大脑模块）：只负责思考和选择工具。</li>
<li>Tools（工具模块）：只负责执行一个具体的任务并给出结果。</li>
</ul>
<p>LLM 不需要知道工具是如何实现 API
调用的，它只知道这个工具的接口描述。这使得你可以无限地插拔新工具，赋予
AI Agent 无限想象的新能力。</p>
<h1 id="术构建与设计的指导框架">术：构建与设计的指导框架</h1>
<h2 id="solid-原则">SOLID 原则</h2>
<p>SOLID 原则由 Robert C. Martin (Uncle Bob)
提炼并推广，如果想要理解并运用好这五大原则，核心不在于我们把它们背诵得多么熟练，也不在于我们能多快速地识别现有代码符不符合哪些原则，关键是要将它们看成一个整体，去思考它们背后到底是在解决什么问题。</p>
<p>当我们聊 SOLID
原则时，我们不是在谈论五条独立的规则，而是在谈论一个统一的核心思想：在面向对象
(OOP)
范式下，如何科学地管理依赖关系，以应对软件的复杂性和持续不断的变化。</p>
<blockquote>
<p>当然，在非严格 OOP 编程语言上，也是可以借鉴类似思想的，如 Go 的
struct/interface 和 Rust 的 struct/trait。</p>
</blockquote>
<p>一个软件系统的生命周期中，最大的成本不是来自“首次开发”，而是来自“持续维护”——即修复
Bug、修改功能和添加新功能。</p>
<p>一个腐化的软件系统（高耦合、低内聚）在面对变化时，会表现出两个致命特征：</p>
<ol type="1">
<li><strong>僵化性
(Rigidity)</strong>：改动一个地方很困难，因为它牵连着许多其他模块。</li>
<li><strong>脆弱性
(Fragility)</strong>：改动一个地方，导致系统中许多不相关的地方出现了意料之外的
Bug。</li>
</ol>
<p>SOLID
原则就是一套组合拳，它们共同的目标是创建<strong>高内聚、低耦合</strong>的模块化结构，从而战胜这两种特征。最终产出的系统应该是：</p>
<ul>
<li><strong>易于修改的
(Flexible)</strong>：添加新功能时，对现有代码的影响最小。</li>
<li><strong>易于理解的
(Understandable)</strong>：模块边界清晰，职责单一。</li>
<li><strong>易于测试的
(Testable)</strong>：模块可以被独立地隔离和测试。</li>
</ul>
<h3 id="单一职责原则-srp---single-responsibility-principle">单一职责原则
(SRP - Single Responsibility Principle)</h3>
<ul>
<li><strong>它解决了什么：</strong> 模块的"边界"问题。</li>
<li><strong>它的角色：</strong> <strong>解耦的起点</strong>。</li>
<li><strong>逻辑：</strong>
它强制我们进行<strong>拆分</strong>。它定义了一个模块（在 OOP 中通常是
Class，Go/Rust 里面是
struct）应该具有高内聚性。高内聚意味着只为一个变化的原因而存在。如果一个类混合了业务逻辑、数据持久化和日志记录，那么这三个变化的原因中任何一个发生，都可能破坏这个类。SRP
通过拆分，<strong>首先在微观上隔离了变化</strong>。</li>
</ul>
<h3 id="开放封闭原则-ocp---openclosed-principle">开放封闭原则 (OCP -
Open/Closed Principle)</h3>
<ul>
<li><strong>它解决了什么：</strong> 系统的"扩展"问题。</li>
<li><strong>它的角色：</strong> <strong>解耦的目标</strong>。</li>
<li><strong>逻辑：</strong> 这是 SOLID
的核心目标。它指出系统应该对扩展开放，对修改封闭。这意味着当新需求（变化）到来时，我们应该通过<strong>添加新代码</strong>（例如实现一个新类）来完成，而不是通过<strong>修改旧的、已验证的代码</strong>。</li>
<li><strong>关键问题：</strong> OCP 只是一个目标，它没有说 <em>如何</em>
做到。SRP 拆分了模块，但 OCP
告诉我们这些模块之间必须依赖<strong>抽象</strong>，而不是具体实现。</li>
</ul>
<h3 id="里氏替换原则-lsp---liskov-substitution-principle">里氏替换原则
(LSP - Liskov Substitution Principle)</h3>
<ul>
<li><strong>它解决了什么：</strong> 抽象的"可靠性"问题。</li>
<li><strong>它的角色：</strong> <strong>实现 OCP 的基石</strong>。</li>
<li><strong>逻辑：</strong> OCP 依赖于抽象（如接口或基类）和多态。LSP
提供了<strong>实现多态的正确性规范</strong>。它确保任何子类（具体实现）都必须能够替换其父类（抽象）而程序的行为不发生任何改变。如果一个子类的实现违反了父类的约定（例如，一个
<code>Square</code> 类继承 <code>Rectangle</code>，并重写了
<code>setHeight</code> 方法导致其 <code>Width</code>
也发生变化），那么这个抽象就是不可靠的。</li>
<li><strong>作用：</strong> LSP 是<strong>保证 OCP
得以实现的行为契约</strong>。没有
LSP，抽象就毫无意义，对修改封闭也就无从谈起。</li>
</ul>
<h3 id="接口隔离原则-isp---interface-segregation-principle">接口隔离原则
(ISP - Interface Segregation Principle)</h3>
<ul>
<li><strong>它解决了什么：</strong> 抽象的"粒度"问题。</li>
<li><strong>它的角色：</strong> <strong>降低依赖的成本</strong>。</li>
<li><strong>逻辑：</strong> 即使我们有了 OCP（依赖抽象）和
LSP（抽象可靠），但如果这个抽象（接口）本身非常臃肿，它会强迫客户端（使用者）依赖它们根本不需要的方法。这种不必要的依赖会造成耦合。</li>
<li><strong>作用：</strong> ISP
告诉我们，抽象应该<strong>精细化、客户化</strong>。它本质上是 SRP
在接口设计上的应用。它通过拆分大接口，确保了依赖关系的<strong>最小化</strong>和<strong>精准化</strong>。</li>
</ul>
<h3 id="依赖倒置原则-dip---dependency-inversion-principle">依赖倒置原则
(DIP - Dependency Inversion Principle)</h3>
<ul>
<li><strong>它解决了什么：</strong> 依赖的"方向"问题。</li>
<li><strong>它的角色：</strong> <strong>解耦的架构蓝图</strong>。</li>
<li><strong>逻辑：</strong> 这是 SOLID
的最高层指导。它规定了系统中所有依赖关系的方向。
<ul>
<li>A. 高层模块（如业务策略）不应依赖低层模块（如数据库实现）。</li>
<li>B. 两者都应依赖于<strong>抽象</strong>（如接口）。</li>
</ul></li>
<li><strong>作用：</strong> DIP 将传统的"高层 -&gt;
低层"的依赖关系，<strong>倒置</strong> 为"高层 -&gt; 抽象"和"低层 -&gt;
抽象"。这使得系统的核心业务逻辑（高层）完全独立于任何具体的实现细节（低层）。<strong>这是实现对修改封闭的最强有力的架构手段</strong>。这也是
DDD 和洋葱架构的典型实现。</li>
</ul>
<h3 id="总结">总结</h3>
<p>SOLID 原则提供了一套完整的、从微观到宏观的解耦策略：</p>
<ul>
<li><strong>SRP</strong> 负责创建高内聚的模块。</li>
<li><strong>OCP</strong> 设定了依赖抽象的最终目标。</li>
<li><strong>LSP</strong> 保证了这些抽象的实现是可靠和可替换的。</li>
<li><strong>ISP</strong> 保证了这些抽象本身是精简和低耦合的。</li>
<li><strong>DIP</strong>
最终定义了整个系统的架构，确保了依赖关系朝向正确的（即稳定的）方向。</li>
</ul>
<h2 id="设计模式">设计模式</h2>
<h3 id="设计模式清单">设计模式清单</h3>
<ol type="1">
<li><p>创建型模式 (Creational
Patterns)：这些模式提供了不同种类的对象创建机制，使得一个系统在运行时可以选择其中的一个适当的创建方法来创建对象。</p>
<ul>
<li>单例模式 (Singleton
Pattern)：确保一个类只有一个实例，并提供全局访问点来访问该实例。</li>
<li>工厂模式 (Factory
Pattern)：定义一个用于创建对象的接口，让子类决定实例化哪个类来创建对象。</li>
<li>抽象工厂模式 (Abstract Factory
Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li>建造者模式 (Builder
Pattern)：将一个复杂对象的构造与其表示分离，使得同样的构造过程可以创建不同的表示。</li>
<li>原型模式 (Prototype Pattern)：通过复制现有的实例来创建新实例。</li>
</ul></li>
<li><p>结构型模式 (Structural
Patterns)：这些模式描述如何将类或对象组合成更大的结构，以满足特定的需求。</p>
<ul>
<li>适配器模式 (Adapter
Pattern)：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>桥接模式 (Bridge
Pattern)：将抽象部分与它的实现部分分离，使得它们都可以独立地变化。</li>
<li>装饰器模式 (Decorator
Pattern)：动态地给一个对象添加一些额外的职责。就增加功能而言，装饰器模式比生成子类更为灵活。</li>
<li>组合模式 (Composite
Pattern)：将对象组合成树形结构以表示“部分-整体”的层次结构。</li>
<li>外观模式 (Facade
Pattern)：为子系统中的一组接口提供一个一致的界面，该模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>享元模式 (Flyweight
Pattern)：运用共享技术有效地支持大量细粒度的对象。</li>
<li>代理模式 (Proxy
Pattern)：为其他对象提供一种代理以控制对这个对象的访问。</li>
</ul></li>
<li><p>行为型模式 (Behavioral
Patterns)：这些模式涉及到算法和对象间职责的分配，并描述了在对象之间的通信模式。</p>
<ul>
<li>责任链模式 (Chain of Responsibility
Pattern)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</li>
<li>命令模式 (Command
Pattern)：将请求封装成对象，从而让你使用不同的请求、队列或者日志来参数化其它对象。命令模式也可以支持撤销操作。</li>
<li>解释器模式 (Interpreter
Pattern)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li>
<li>迭代器模式 (Iterator
Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</li>
<li>中介者模式 (Mediator
Pattern)：用一个中介对象封装一系列的对象交互。中介者使得各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>
<li>备忘录模式 (Memento
Pattern)：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</li>
<li>观察者模式 (Observer
Pattern)：定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</li>
<li>状态模式 (State
Pattern)：允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类。</li>
<li>策略模式 (Strategy
Pattern)：定义一系列算法，把它们一个个封装起来，并使它们可以相互替换。本模式使得算法的变化可独立于使用它的客户端。</li>
<li>模板方法模式 (Template Method
Pattern)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤。</li>
<li>访问者模式 (Visitor
Pattern)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul></li>
</ol>
<blockquote>
<p>设计模式的代码实战可参考：https://github.com/hedon954/go-designmode</p>
</blockquote>
<h3 id="理解设计模式">理解设计模式</h3>
<p>看完前面梳理的 23
种设计模式，相信大多数人跟我一样头都大了，即便我已经做了简单的分类。我一直在思考如何更好地理解和运用设计模式，从而写出更加优雅的代码。AI
的出现，真的让我感觉非常幸运，AI
可以很好地从第一性原理和根本源头上对设计模式进行展示和阐述，所以在我跟
AI
进行深入探讨之后，我对设计模式的理解又更进一步了，这里做一下简单总结。</p>
<p>从第一性原理出发，当我们谈论设计模式时，我们主要在谈论两件事：</p>
<ol type="1">
<li><strong>一个共享的词汇库</strong>：设计模式提供了一套高带宽、无歧义的专业词汇，它让我们谈论复杂抽象的方案时，就像谈论变量或函数一样简单。</li>
<li><strong>一套经验的结晶</strong>：设计模式就是把这些被反复验证、证明是健壮的、优雅的解决方案提取出来，并给它们命了名。</li>
</ol>
<p>所以，设计模式<strong>不是最佳实践的清单</strong>，而是<strong>在特定上下文
(Context)中，针对特定问题 (Problem)的一种解决方案
(Solution)</strong>。它本质上是前人经验的固化。</p>
<p>理解 23
种设计模式的最好方法，不是去背诵它们，而是去<strong>分类</strong>和<strong>抓意图</strong>。你不需要记住
23 种模式的实现细节，你只需要理解 23
种<strong>问题</strong>，以及它们分别属于哪一类<strong>意图</strong>。</p>
<h4 id="创建型模式">创建型模式</h4>
<blockquote>
<p>如何才能在<strong>不暴露创建细节</strong>的情况下，<strong>灵活且可控地创建对象</strong>？
—— <strong>解耦对象的创建过程</strong></p>
</blockquote>
<ol type="1">
<li><strong>Singleton
(单例模式)</strong>：我需要保证这个类在整个应用程序中，<strong>有且仅有一个实例</strong>（比如，配置管理器、日志记录器）。</li>
<li><strong>Factory Method
(工厂方法)</strong>：我有一个基类（或接口），但我<strong>不想让客户端</strong>（调用方）<strong>直接</strong>
<code>new</code> 它的某个具体子类。我想把这个 <code>new</code>
的决定权<strong>推迟到子类</strong>去做。</li>
<li><strong>Abstract Factory
(抽象工厂)</strong>：我需要创建<strong>一系列相互关联的对象</strong>（一个产品族，比如
<code>UI</code> 的深色主题需要
<code>DarkButton</code>、<code>DarkCheckbox</code>），并且我想<strong>一键切换</strong>整个产品族（比如一键切换到浅色主题）。</li>
<li><strong>Builder
(建造者模式)</strong>：我要创建的这个对象<strong>太复杂了</strong>，它的构造函数有<strong>一大堆参数</strong>，其中很多还是可选的。我不想写一堆重载的构造函数，也不想让对象在创建过程中处于不完整状态。（在
Go 或 Rust 中可能更熟悉的是 <code>Option</code> 模式，这是 Builder
的一种变体）</li>
<li><strong>Prototype
(原型模式)</strong>：创建一个新对象的<strong>成本非常高</strong>（比如涉及
I/O
或复杂的计算）。如果我有一个已有的对象，通过<strong>复制（clone）</strong>它来创建新对象会快得多。</li>
</ol>
<h4 id="结构型模式">结构型模式</h4>
<blockquote>
<p>如何才能<strong>灵活地组合</strong>类与对象，形成<strong>更大的、功能更强的结构</strong>？——
<strong>解耦对象的组合方式</strong></p>
</blockquote>
<ol type="1">
<li><strong>Adapter
(适配器模式)</strong>：我有一个现成的类（A），它的功能很棒，但我<strong>无法直接使用</strong>，因为客户代码要求的是另一个<strong>不兼容的接口</strong>（B）。我需要一个"转换插头"。</li>
<li><strong>Decorator
(装饰器模式)</strong>：我想在<strong>不修改</strong>一个类（或对象）的代码的前提下，<strong>动态地</strong>给它<strong>添加</strong>新的功能（职责）。而且我想可以<strong>层层嵌套</strong>地添加（比如
<code>Buffered</code> -&gt; <code>Gzipped</code> -&gt;
<code>FileInputStream</code>）。</li>
<li><strong>Proxy
(代理模式)</strong>：我不想让客户端<strong>直接</strong>访问某个对象。我想在中间加一层代理，来<strong>控制</strong>对这个对象的访问（比如，权限检查、懒加载、日志记录、RPC）。</li>
<li><strong>Facade
(外观模式)</strong>：我这里有一个<strong>非常复杂的子系统</strong>，内部有一堆类和复杂的调用关系。我只想给客户端提供一个<strong>极其简单的、统一的访问入口</strong>。</li>
<li><strong>Bridge
(桥接模式)</strong>：我有<strong>两个独立变化的维度</strong>（比如形状和颜色）。我不想用继承（比如
<code>RedCircle</code>, <code>BlueCircle</code>, <code>RedSquare</code>…
导致类的爆炸），我想把这两个维度<strong>分开</strong>，让它们<strong>各自独立演化</strong>。</li>
<li><strong>Composite
(组合模式)</strong>：我需要处理一个<strong>树形结构</strong>（比如文件系统的文件和文件夹）。我希望能够用<strong>完全相同的方式</strong>（同一个接口）来对待单个对象（叶节点）和对象组合（分支节点）。</li>
<li><strong>Flyweight
(享元模式)</strong>：我需要创建<strong>海量</strong>的小对象，它们绝大多数的<strong>内部状态</strong>都是相同的。为了<strong>节省内存</strong>，我想把这些相同的状态<strong>共享</strong>（复用）起来。</li>
</ol>
<h4 id="行为型模式">行为型模式</h4>
<blockquote>
<p>如何才能高效地<strong>分配职责</strong>，并管理对象之间<strong>复杂的通信</strong>？
—— <strong>解耦对象间的通信与职责</strong></p>
</blockquote>
<ol type="1">
<li><strong>Strategy (策略模式)</strong>：我有一堆
<code>if...else if...else</code> 或者一个巨大的
<code>switch</code>，它们在根据不同条件<strong>选择不同的算法</strong>或行为。我想把这些<strong>算法</strong>（策略）<strong>独立</strong>出来，让它们可以<strong>互相替换</strong>。</li>
<li><strong>Observer
(观察者模式)</strong>：我有一个"主题"对象，当它的状态发生变化时，需要<strong>自动通知</strong>其他<strong>所有</strong>依赖它的"观察者"对象，但我又不想让"主题"<strong>直接</strong>知道"观察者"的具体实现（实现广播式解耦）。</li>
<li><strong>Command
(命令模式)</strong>：我想把一个<strong>操作（请求）封装成一个对象</strong>。这样我就可以把这个"命令"<strong>传递</strong>、<strong>排队</strong>、<strong>记录日志</strong>，甚至实现<strong>撤销（Undo）</strong>。</li>
<li><strong>Template Method
(模板方法)</strong>：我有一个算法，它的<strong>骨架（步骤）是固定不变的</strong>，但其中<strong>一两个步骤</strong>的具体实现是<strong>易变</strong>的。我想在基类中定义好"骨架"，让子类去实现那些"易变"的步骤。</li>
<li><strong>Iterator
(迭代器模式)</strong>：我有一个<strong>聚合对象</strong>（比如 List,
Map,
Set），我想让客户端能够<strong>遍历</strong>它，但又<strong>不想暴露</strong>它的<strong>内部实现细节</strong>。</li>
<li><strong>Mediator
(中介者模式)</strong>：我有一堆对象，它们之间<strong>互相通信</strong>，形成了一个<strong>复杂的网状结构</strong>（M-N
关系），导致高耦合。我想引入一个"中介"，让所有对象只和"中介"通信（M-1-N），<strong>简化</strong>这个通信网。</li>
<li><strong>State
(状态模式)</strong>：一个对象的<strong>行为</strong>完全取决于它的<strong>内部状态</strong>。我现在的代码里有<strong>一堆
<code>switch</code></strong>
在检查"当前状态"来决定下一步做什么。我想把每种"状态"下的行为封装成<strong>独立</strong>的类。</li>
<li><strong>Chain of Responsibility
(责任链模式)</strong>：一个请求需要被<strong>多个对象</strong>中的<strong>某一个</strong>处理。但我不确定是哪一个，或者我想让它们<strong>依次尝试</strong>处理（比如
<code>HTTP</code>
中间件）。我想把这些对象<strong>串成一条链</strong>，让请求沿着链传递下去。</li>
<li><strong>Visitor
(访问者模式)</strong>：我有一组<strong>稳定的</strong>对象结构（比如一个语法树），但我想为它们添加<strong>各种各样的新操作</strong>（比如类型检查、代码生成）。我不想每加一个操作就去<strong>修改</strong>那些稳定的对象类。</li>
<li><strong>Memento
(备忘录模式)</strong>：我需要<strong>保存</strong>一个对象的<strong>内部状态</strong>（创建快照），以便在未来某个时刻能<strong>恢复</strong>到这个状态（比如实现撤销或存档），同时我又不希望<strong>暴露</strong>这个对象内部的实现细节。</li>
<li><strong>Interpreter
(解释器模式)</strong>：我需要为一个<strong>简单的语言</strong>（比如正则表达式、SQL
查询）构建一个<strong>解释器</strong>。（这是最不常用的模式之一，通常有现成的工具）</li>
</ol>
<h3 id="用好设计模式">用好设计模式</h3>
<p>我觉得想要用好设计模式，只有一个途径，就是多用，甚至是刻意多用，也就是"手里拿着锤子，看什么都是钉子"那样的多用。用对了，你才能真实体验到设计模式给你带来的收益，你才会更理解它们的由来，你也才会更愿意在这方面花更多的思考和实践。用错了，发现过度设计了，发现代码变得更难理解和维护了，你才能真正感受到理论与实践的差距，你才能从另外一个角度去更全面理解你所运用的设计模式。当然，这种刻意多用，最好更多是在自己的个人项目中，而不是在工作项目上，因为后者的犯错成本要更高，风险也相应更大。当然，工作上的使用，总有第一次，所以不妨大胆一点，只要你是在思考，只要你是在努力做好事情，我觉得，一切都是不亏的。</p>
<p>我很庆幸在我刚入职两三个月的时候，就接手了重构一坨屎山代码的重任，并且在我使用模板方法设计模式对其进行彻底重构后，代码变得极其优雅并在后面的两年多中持续为我带来收益。这些体验和正反馈，让我对设计模式一直有一层滤镜，使得我这三年来一直愿意主动去思考如何将代码写得更加优雅。</p>
<p>这个项目是这样的，我们对接了 20
多个广告商，每个广告商下面有多个不同公司主体下的多个不同 APP，即存在 3
个维度，我们要去请求广告商的 API 去统一汇总所有 APP
的广告收入数据。之前的人开发的时候就是纯复制粘贴，重复代码直接爆了，而且相同步骤还存在非常多不一致的逻辑，这给代码阅读、问题排查、新增广告商/公司主体/APP、业务数据诉求等方面都带来了究极折磨。我发现其实所有广告数据获取都遵循这样一个步骤：<u>请求数据、格式统一、合并数据、异常处理、转存数据</u>。我发现只有请求数据和格式统一这两步是跟广告商
API
强相关且必须单独定制开发的，其他都是一样的逻辑。所以我就采用了<strong>模板方法设计模式</strong>，对这个流程进行了抽象和重构，并且由于骨架非常固定，我还顺带开发了代码生成
CLI
工具，进一步提高开发效率。就这样简单套用了一个设计模式，整个代码的风格和简洁度，焕然一新，又由于架构的简洁统一，使得后续的数据修复、问题排查、新增需求等操作都非常简单和高效高质量。</p>
<p>反面例子也有，我们组内其他同学在重构匹配服的时候，由于对接口定义理解的不足，同时对状态模式、策略模式的理解不足，但又强行套用，同时又有很多其他不必要的抽象操作，我称之为炫技。这一顿操作导致了我们的新匹配服过度抽象、接口定义不合理、架构混乱，进而导致了代码可读性较差、新人接手难度高等一系列问题。但是坦白说，这个失败的例子给我带来的收获和思考，并不比上面提到的成功的例子少。</p>
<p>"手里拿着锤子，看什么都是钉子"是我们刚接触设计模式时的通病，这往往会导致过度设计。我个人觉得想要减少"硬套"设计模式的核心原则是
：<strong><u>永远让问题驱动模式，而不是反过来</u></strong>。</p>
<ol type="1">
<li><strong>KISS (Keep It Simple, Stupid) 优先：</strong>
永远先写出最简单、最直白的代码。不要一开始就思考我该用哪个模式。</li>
<li><strong>YAGNI (You Ain't Gonna Need It) 原则：</strong>
不要为了未来可能的扩展性而去应用一个复杂的模式。如果现在简单的
<code>if...else</code>
就能解决问题，并且没有明确的迹象表明它马上会变得复杂，那就用
<code>if...else</code>。</li>
<li><strong>把模式当作重构的手段：</strong> 这是应用模式的最佳时机。
<ul>
<li>你的简单代码跑起来了。</li>
<li>随着需求（变化）的到来，你的简单代码开始变得腐化。</li>
<li><strong>此时</strong>，代码的坏味道已经清晰地暴露了问题。</li>
<li><strong>现在</strong>，你才应该引入设计模式，作为一种<strong>重构</strong>手段，去解决这个已经<strong>实际发生</strong>的、而不是臆想出来的设计问题。</li>
</ul></li>
<li><strong>评估引入的成本：</strong> 没有任何模式是银弹。
<ul>
<li><strong>Factory</strong> 带来了灵活性，但也增加了类的数量。</li>
<li><strong>Observer</strong>
实现了完美的解耦，但也让程序的控制流变得难以追踪（回调地狱）。</li>
<li><strong>Singleton</strong>
简化了访问，但也引入了全局状态，使测试变得极其困难。</li>
</ul></li>
</ol>
<p>当你决定要套用一个模式时，必须明确地问自己：<strong>为了解决我眼前的这个问题，我是否愿意支付这个模式带来的额外复杂性的代价？</strong></p>
<h2 id="架构模式">架构模式</h2>
<h3 id="什么是架构">什么是架构</h3>
<p>架构这个词，很多人都在谈，那到底什么是架构呢？架构师又是做啥的呢？<a
target="_blank" rel="noopener" href="https://book.douban.com/subject/37055698/">《P9
工作法：夯实技术硬实力、架构力和领导力》</a>一书总结得非常好。</p>
<p>书中说，架构师就是<u>运用技术架构的思维框架深入分析业务需求，识别关键问题，并通过持续的演进和迭代来提升系统能力，以支持业务实现商业成功</u>。可以用两组词来表述架构的概念：模块与关系、过程与结果。</p>
<ul>
<li><strong>模块与关系</strong>：软件架构是由哪些模块组成，这些模块由哪些领域模型组成，每个模块的权责边界是什么，以及模块间如何协作。</li>
<li><strong>过程与结果</strong>：软件架构是一个动词，代表一系列决策过程。这些决策主要从全局和未来视角出发，寻找解决实际问题的最佳架构。这就是“架构即过程”的含义。同时，软件架构也是一个名词，是技术解决实际问题、支撑业务发展的结果，也是不同角色进行协作的界面。</li>
</ul>
<p>当我们聊架构设计的时候，我们其实是在谈论一个完整的生命周期，我将其概括为以下
6 个步骤：</p>
<ol type="1">
<li><strong>理解商业与组织上下文：</strong>
我们在谈论深入挖掘利益相关方的真实诉求、明确用户核心痛点、对齐关键商业指标，并诚实评估我们团队现有的技术栈与组织能力。</li>
<li><strong>定义架构特性与约束：</strong>
我们在谈论从性能、可用性、成本等众多特性中，识别出对本次设计最关键的 3-5
个，并清晰定义那些不可逾越的约束红线，以此作为后续所有技术权衡
(trade-off) 的核心基准。</li>
<li><strong>探索方法与决策：</strong>
我们在谈论通过系统地探索多种可选方案、进行客观的利弊权衡与风险评估，最终做出理性的技术决策并将其（例如使用
ADR）沉淀为文档。</li>
<li><strong>设计实施路径与验证机制：</strong>
我们在谈论如何将架构蓝图转化为可执行的实施计划，包括通过 PoC
验证关键难点、拆解任务与里程碑，并通过构建适应度函数来持续验证架构特性的落地。</li>
<li><strong>部署、观测与效果衡量：</strong> 我们在谈论通过 CI/CD
将设计交付上线，并借助 APM
和业务指标监控来实时观测系统的运行状态与商业效果，以此获取最真实的反馈。</li>
<li><strong>复盘、沉淀与演进：</strong>
我们在谈论对线上问题进行彻底的根因分析、将经验教训沉淀为改进后的流程与原则，最终推动人员与组织的共同成长，并为下一轮架构演进做好准备。</li>
</ol>
<h3 id="架构选择的两大原理">架构选择的两大原理</h3>
<ul>
<li>第一原理：一切都是权衡。</li>
<li>第二原理：为什么比如何更重要。</li>
</ul>
<h3 id="架构原则">架构原则</h3>
<ul>
<li><strong>KISS (Keep It Simple, Stupid) 原则：</strong>
在所有解决方案中，优先选择最简单、最清晰的那一个。</li>
<li><strong>YAGNI (You Ain't Gonna Need It) 原则：</strong>
只实现你当前明确需要的功能，不要为"未来可能的需求"编写代码。</li>
<li><strong>DRY (Don't Repeat Yourself) 原则：</strong>
确保系统中的每一处知识（逻辑、数据）都只有一个权威的、明确的表示。</li>
<li><strong>TDA (Tell, Don't Ask) 原则：</strong>
你应该"告诉"对象去做事，而不是"询问"它的内部状态来替它做决策。</li>
<li><strong>SoC (Separation of Concerns) 原则：</strong>
将一个复杂的系统划分为多个独立的、只关注一个方面的模块。</li>
<li><strong>LoD (Law of Demeter) 原则：</strong>
一个对象应该尽可能少地了解其他对象的内部结构，只与其必要部分通信。</li>
</ul>
<p>这些原则共同服务于一个目标：<strong>创建一个易于理解、易于修改、易于维护的系统</strong>，从而在软件的整个生命周期内，<strong>最大化地控制住"复杂度"这个敌人</strong>。</p>
<p>你可以按照下面的思路在运用这六大原则：</p>
<ol type="1">
<li>当一个新需求来了，你首先用 <strong>YAGNI</strong> 和
<strong>KISS</strong>
来过滤它：我们真的需要它吗？我们能用最简单的方法实现它吗？</li>
<li>一旦决定要做，你用 <strong>SoC</strong>
来划分它的边界：这个功能应该属于哪个关注点？它是一个新模块吗？</li>
<li>在实现这个模块时，你用 <strong>DRY</strong>
来避免内部的重复代码，通过抽象来保证知识的唯一性。</li>
<li>当这个模块需要与外部模块通信时，你用 <strong>LoD</strong> 和
<strong>TDA</strong>
来指导你的交互设计：只和邻居说话（LoD），并且是告诉它们做事（TDA），而不是打听它们的内部状态。</li>
</ol>
<h3 id="常用架构模式">常用架构模式</h3>
<p>这里我梳理了<a
target="_blank" rel="noopener" href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of
Software
Architecture》</a>一书提到的最常用、最经典的架构模式，具体的描述和权衡之道可以参考我梳理的笔记：<a
href="https://hedon.top/2025/07/24/note/note-fosa/">读书笔记丨《Fundamentals
of Software Architecture》</a>。</p>
<ol type="1">
<li><strong>分层架构</strong>：分层架构的核心驱动力是关注点分离（Separation
of
Concerns）。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</li>
<li><strong>管道架构</strong>：又称为管道与过滤器架构（Pipes and Filters
Architecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</li>
<li><strong>微核架构</strong>：也被称为插件化架构（Plug-in
Architecture），是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的核心系统（Core
System）和一个由独立插件组件（Plug-in
Components）构成的可扩展生态。</li>
<li><strong>基于服务的架构</strong>：本质是一种将一个大型的单体应用，分解为少数几个、逻辑独立的、可独立部署的"服务"
的架构风格。SBA 的服务数量通常不多，一般在 4 到 12
个之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照核心的业务领域进行划分。</li>
<li><strong>事件驱动架构</strong>：对特定情况做出反应，并根据该事件采取行动。分为代理模式（broker）和中介者模式（mediator）两种模式，二者最大的区别在于后者具有一个统一的协调者，这会对异常处理、全局统筹有很好的管控手段，当同时也牺牲了系统的解耦程度、灵活度和性能。</li>
<li><strong>空间架构</strong>：名称来源于元组空间（Tuple
Space）多个并行处理器通过共享内存进行通信。SBA
的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（Processing
Units）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</li>
<li><strong>微服务架构</strong>：核心在于高度解耦。它倾向于复制而非耦合。这意味着，如果架构师的目标是高度解耦，那么他们会选择复制而不是重用。微服务通过物理上建模限界上下文（Bounded
Context）的逻辑概念来实现高度解耦。</li>
</ol>
<h2 id="领域驱动设计">领域驱动设计</h2>
<p>在复杂度管理的术篇最后，我想用
DDD（领域驱动设计）来收个尾。很遗憾我并没有在上份工作中积累 DDD
的相关经验，我们的业务复杂度其实已经到了难以管理甚至失控的程度了，领导也提出了要尝试使用
DDD
来进行治理，不过后面也不知为何就搁置了。团队这种习惯性有头无尾的风格，也是我下定决定离开的原因之一。</p>
<h3 id="ddd-存在的意义">DDD 存在的意义</h3>
<p>话回正题，我们一直在谈论复杂度管理。软件的复杂度有两个来源：</p>
<ol type="1">
<li><strong>技术复杂度</strong>：由技术选型、框架、性能、并发等引入的复杂度。</li>
<li><strong>领域复杂度
</strong>：业务本身固有的复杂度。比如一个电商系统的"优惠券计算规则"，一个金融系统的"估值模型"，一场联机游戏的"结算过程"。</li>
</ol>
<p>为什么传统开发的"术"在业务发展到一定规模的时候，在管理复杂度时往往会失效呢？</p>
<p>在很多项目中，我们花了大量时间在技术复杂度上，而对领域复杂度的处理，往往是数据驱动的：先设计数据库表
(DAO/Models)，然后写服务 (Service)，最后写接口
(Controller)。这种方式在业务初期很简单。</p>
<p>但随着业务发展，业务规则会变得极其复杂（比如，一场联机游戏的结算，可能要调用
10 个微服务，涉及 20 张表，处理 30 种运营活动策略）。</p>
<p>此时，业务逻辑被<strong>切割</strong>并<strong>分散</strong>在各个
Service、Helper、Utils 甚至 Controller
层中。代码（技术实现）与真实的业务（领域）之间的<strong>认知鸿沟</strong>越来越大。最终，系统变得无法维护，因为<strong>没有人能说清楚一个完整的业务流程到底是怎么运作的</strong>。</p>
<p><strong>软件的核心是其为用户解决的领域问题</strong>。因此，管理复杂度的根本，在于<strong>精准地捕获、表达和隔离领域复杂度</strong>。它要求我们从技术实现驱动转向领域模型驱动。这便是
DDD 存在的意义。</p>
<h3 id="ddd-两大核心">DDD 两大核心</h3>
<p>要想理解 DDD
的核心思想，重点在于弄清楚它的战略设计和战术设计，以及其背后的第一性原理。</p>
<h4 id="战略设计在宏观上划分战场">战略设计：在宏观上划分战场</h4>
<p>这是 DDD 最重要的部分，它决定了系统的宏观架构。</p>
<ul>
<li><strong>统一语言 (Ubiquitous
Language)</strong>：统一语言是业务专家、产品经理和开发团队在同一个限界上下文中共同锤炼、严格遵守的、无歧义的词汇表，它贯穿于所有沟通、文档和代码实现之中，是构建领域模型的基石。</li>
<li><strong>限界上下文 (Bounded
Context)</strong>：限界上下文是一个明确的业务边界（比如一个子系统或微服务），它封装并保护一个独立的领域模型，确保"统一语言"在该边界内的含义是唯一且自洽的，从而允许不同上下文对同一业务概念（如商品）拥有不同的模型。</li>
<li><strong>上下文映射 (Context
Map)</strong>：上下文映射是一种宏观架构图，它通过定义不同限界上下文之间的集成模式（如防腐层、共享内核或遵从者）来清晰地描绘它们之间的技术依赖和团队组织关系，从而在战略层面管理跨模型的集成复杂度。</li>
</ul>
<h4 id="战术设计在微观上保护模型">战术设计：在微观上保护模型</h4>
<p>当我们通过战略设计划分好了边界之后，战术设计提供了具体的编码方式，来<strong>确保</strong>我们在代码中实现的模型不被破坏。其中最核心的有三点：</p>
<ul>
<li><strong>聚合
(Aggregate)</strong>：聚合是将一个或多个实体与值对象（如订单和订单项）组合成一个业务上的一致性单元，外界只能通过其聚合根这唯一入口来访问，从而强制封装所有业务规则（不变量）并确保其作为一个整体被事务性地持久化。</li>
<li><strong>值对象 (Value
Object)</strong>：值对象是一种通过其属性（而非唯一
ID）来定义的对象（如金额或地址），它被设计为不可变的以消除副作用，并在领域模型中承载那些用于度量、描述或限定业务概念的值。</li>
<li><strong>资源库
(Repository)</strong>：资源库是定义在领域层的一个接口，它通过模拟一个内存中的集合来封装数据持久化的所有技术细节，其具体实现（如
SQL
查询）则被隔离在基础设施层，从而使领域模型（尤其是聚合根）保持纯洁，无需关心数据是如何存取的。</li>
</ul>
<p>目前我对于 DDD 的理解和实践仅在于阅读了<a
target="_blank" rel="noopener" href="https://book.douban.com/subject/37102014/">《悟道领域驱动设计》</a>一书，感兴趣的读者可以参考我梳理的<a
href="https://hedon.top/2025/03/11/note/note-ddd-awareness/">读书笔记丨《悟道领域驱动设计》</a>。</p>
<h1 id="器验证与洞察的质量手段">器：验证与洞察的质量手段</h1>
<p>如果说心法是道，术是招式，那么器就是"眼睛"和"标尺"。没有器，我们永远不知道招式打得对不对，也无从得知我们的道是不是走偏了。这里我想重点总结我认为
2
个最重要的工具：<strong>单元测试</strong>和<strong>可观测性</strong>。这也是我在第一份工作中做的最有成就感、也是我进步最大的两个专项：代码质量建设专项和服务监控建设专项。</p>
<p>我之所以认为单元测试和可观测性是管理软件复杂度的两大利器，是因为它们分别为软件生命周期中两个截然不同的复杂度阶段——<strong>静态复杂度</strong>和<strong>动态复杂度</strong>——提供了必不可少的<strong>反馈与控制机制</strong>。</p>
<ul>
<li><strong>静态复杂度</strong>：代码在"写下时"的复杂度。它关乎代码的结构、依赖、正确性和可读性。</li>
<li><strong>动态复杂度</strong>：系统在"运行时"的复杂度。它关乎成千上万个模块交互时所<strong>涌现</strong>出的、难以预测和跟踪的行为。</li>
</ul>
<h2 id="单元测试">单元测试</h2>
<figure>
<img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/81R7v9lnljL._CR2,0,1276,720_SR684,386_.jpeg"
alt="Unit Testing Principles, Practices, and Patterns" />
<figcaption aria-hidden="true">Unit Testing Principles, Practices, and
Patterns</figcaption>
</figure>
<p>这里我强烈建议所有软件工程师都去阅读<a
target="_blank" rel="noopener" href="https://book.douban.com/subject/34429421/">《Unit Testing
Principles, Practices, and
Patterns》</a>这本书！绝世好书！而且最好的阅读英文原版！我使用了 2
个月的时间（每天 1 个小时）完完整整阅读了这本书 2
次，它对我在单元测试和代码质量上的理解和实践能力都起到了非常大的帮助。</p>
<p>这里我就不再重复此书的内容，但是如果你曾经或是现在依旧被以下问题所困扰的话，建议你去仔细阅读一下这本书，也可以参考我整理的<a
href="https://hedon.top/2025/04/09/note/note-unit-testing/">读书笔记丨《Unit
Testing Principles, Practices, and Patterns》</a>。</p>
<ol type="1">
<li>为什么要写单元测试？单元测试的目标是什么？</li>
<li>单元测试的粒度是怎样的？什么叫单元？a class, a function, or a
behavior, or an observable behavior?</li>
<li>单测覆盖率真的有用吗？有什么用？又有哪些限制？</li>
<li>怎样才能写好单元测试？怎样才能写出性价比最高的单元测试？</li>
<li>如何判断一个单元测试的好坏？有没有具体可供参阅的维度？</li>
<li>哪些代码需要写单元测试，哪些代码没必要写单元测试？</li>
<li>单元测试和集成测试的边界是什么？</li>
<li>（单元丨集成）测试到底是要测什么东西？</li>
<li>单元测试的侧重点是什么？集成测试的侧重点是什么？二者的比例该是怎样的？</li>
<li>如何使用 Mock？哪些东西是需要 Mock 的？哪些东西是不应该 Mock
的？需要 Mock 的东西，应该在哪个层次进行 Mock？（你的 repository 层需要
Mock 吗？）</li>
<li>为什么你的测试代码很脆弱，总是需要频繁修改，维护起来难度很大？</li>
<li>如何减少测试结果的假阳性和假阴性？</li>
</ol>
<p>本篇我想强调的是，单元测试的价值<strong>远远大于</strong>找
Bug。它首先是一种<strong>设计工具</strong>，其次才是一种<strong>测试工具</strong>。它在三个层面上管理了静态复杂度。</p>
<p><strong>1. 它是高内聚低耦合的设计反馈机制</strong></p>
<p>在软件设计中，高内聚、低耦合（<code>模块化</code>心法）是最重要的目标之一。单元测试是检验这一目标是否达成的<strong>第一个，也是最快的反馈工具</strong>。</p>
<p>当你试图为一个模块（一个函数或一个类）编写单元测试时，如果发现测试很难写，这就是一个明确的设计缺陷信号。难写通常意味着该模块<strong>依赖了过多具体实现</strong>（高耦合），而不是依赖抽象（接口）。例如，你为了测试
<code>A</code>，不得不去实例化
<code>B</code>、<code>C</code>、<code>D</code> 等多个真实对象。</p>
<p>为了使 <code>A</code>
变得可测试，工程师<strong>被迫</strong>使用<code>抽象</code>心法和<code>依赖倒置</code>（术）。不再让
<code>A</code> 直接依赖 <code>B</code>，而是依赖一个 <code>IB</code>
接口。这样，在测试中就可以传入一个模拟（Mock）的 <code>B</code>。</p>
<p>这个时候，单元测试反向强迫工程师在设计时就必须遵守"低耦合"和"强抽象"的心法和术。</p>
<p><strong>2. 它是封装和重构的安全保障</strong></p>
<p>软件的复杂度会随时间腐化。封装（<code>抽象</code>心法）的目的是隐藏内部实现，以便未来可以安全地修改它。单元测试是实现这一目标的<strong>安全保障</strong>。</p>
<p>当一个模块拥有完备的单元测试覆盖时，工程师（尤其是新接手的工程师）获得了<strong>重构的信心</strong>。他们可以<strong>大胆地</strong>修改模块的内部实现（例如优化算法、更换数据结构），而<strong>无需</strong>在认知上承载该模块的全部历史逻辑。</p>
<p>只要在重构后，所有的单元测试依然通过，工程师就能获得极大的信心——<strong>内部实现被优化了，但外部承诺未被破坏</strong>。这从根本上抑制了代码的腐化，管理了维护的复杂度。</p>
<p><strong>3. 它是模块边界的精确定义</strong></p>
<p>文档会过时，但代码不会。单元测试是一种<strong>可执行的、活的文档</strong>。</p>
<p>一个写得好的测试用例（例如
<code>Test_Login_Fails_When_Password_Incorrect</code>），它以代码的形式，<strong>精确地、无歧义地</strong>定义了登录模块这个抽象在特定输入下的行为边界。</p>
<p>单元测试是理解一个模块功能和接口承诺的最快、最准确的途径，它极大地降低了新成员理解系统的认知复杂度。</p>
<h2 id="可观测性">可观测性</h2>
<p>单元测试在本地是完美的，但它对运行时的动态复杂度则无能为力。当 1000
个通过了单元测试的微服务（模块）被部署到网络上时，它们交互所产生的涌现行为，是单元测试无法覆盖的。</p>
<p>在我看来，可观测性一般包含 <code>metrics</code>、<code>trace</code>
和 <code>logs</code> 三大部分。</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 13%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr>
<th>组件</th>
<th>核心</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>metrics</td>
<td>帮助你判断是否有问题</td>
<td>统计埋点，包括系统监控、服务监控、业务监控。</td>
</tr>
<tr>
<td>trace</td>
<td>告诉你问题在哪里</td>
<td>实现链路追踪，展示系统拓扑图，梳理服务调用链路，洞察性能瓶颈点。</td>
</tr>
<tr>
<td>logs</td>
<td>帮助你定位到问题根源</td>
<td>制定日志规范，将规范灌输到日常开发的认知习惯中，尝试将部分规范集成到日志组件中，打更有意义的日志，
提高问题排查效率。</td>
</tr>
</tbody>
</table>
<p>利用好这 3 个组件，可以帮助我们：</p>
<ol type="1">
<li><p>出现问题时，提高问题排查效率。</p></li>
<li><p>问题快来时，提供全局视野，提供预知问题的能力。</p></li>
<li><p>问题没出现时，提高开发质量，减少问题。</p></li>
</ol>
<h3 id="可观测性的作用">可观测性的作用</h3>
<p>具体来说，可观测性在三个层面上管理了动态复杂度。</p>
<p><strong>1. 它是分布式系统的交互可视化工具</strong></p>
<p>在模块化的架构中，系统是一个分布式黑盒。任何一个请求都可能跨越几十个模块（服务）。单个模块（已通过单元测试）是正确的，但它们组合运行时的交互可能导致<strong>性能瓶颈</strong>、<strong>级联失败</strong>或<strong>数据不一致</strong>。</p>
<p><strong>分布式追踪 (Tracing)</strong>
提供了请求级的可视化。它能精确地描绘出一个请求从 <code>Service-A</code>
到 <code>Service-B</code> 再到 <code>Service-C</code>
的实际路径和耗时分布。它将黑盒的动态交互复杂度，降维为一张清晰的瀑布图或依赖拓扑图，使工程师能<strong>定位</strong>涌现出的性能瓶颈或错误路径。</p>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d20fefdb-e245-4b5a-ad23-ebef7ed07633.original.png" /></p>
<p><strong>2. 它是设计权衡的运行时数据</strong></p>
<p>我们所有的心法（<code>抽象</code>、<code>分治</code>、<code>分层</code>、<code>模块化</code>）都是有<strong>性能代价</strong>的。分层带来了数据复制的代价；模块化带来了网络调用的代价；消息队列（抽象）带来了延迟的代价。</p>
<p><strong>指标 (Metrics)</strong>
提供了<strong>量化</strong>这些代价的数据。例如 P99 延迟、GC
压力、队列深度会精确地告诉你："你为这个分层付出了 30% 的 GC
额外开销"，"你为这个模块化（微服务调用）付出了 40ms 的 P99 延迟"。</p>
<p><strong>可观测性提供了运行时的真实数据，使设计权衡（Trade-off）从拍脑袋变成了数据驱动</strong>。工程师可以基于数据，决定何时打破分层（例如合并
DTO 和 Model）或合并模块（例如合并微服务）以换取性能。</p>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/apm_vs_dt_metrics.webp" /></p>
<p><strong>3. 它是未知问题的上下文</strong></p>
<p>单元测试只能验证已知（Known）的场景。而系统在真实运行时，会遇到大量未知（Unknown）的、涌现的复杂问题。</p>
<p><strong>日志
(Logs)</strong>，尤其是结构化和高基数的日志，提供了高维度的<strong>上下文</strong>。</p>
<p>当黑天鹅事件（例如高并发+特定网络分区）发生时，只有
<code>Traces</code>、<code>Metrics</code> 和 <code>Logs</code>
结合，才能提供足够的<strong>现场信息</strong>，让工程师能事后回溯、定位和理解那些单元测试永远无法复现的动态复杂度。</p>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/p699774.png" /></p>
<h3 id="可观测性的本质">可观测性的本质</h3>
<p>可观测性到底在观测什么？<u>我们观测的是一个系统（尤其是模块化和分层后的分布式系统）在运行时所涌现出的、不可预测的动态复杂度。</u></p>
<p>我们观测的不是工具（metrics、trace、logs），而是系统在真实压力下的：</p>
<ol type="1">
<li>外在行为 (External Behavior)</li>
<li>内在状态 (Internal State)</li>
<li>交互关系 (Interactions)</li>
</ol>
<p><strong>1. 观测外在行为：系统在做什么？</strong></p>
<p>这是从外部看，我们的模块（服务）所承诺的接口（功能）是否正常。这通常对应
Google SRE 的黄金四信号中的前三个。</p>
<ul>
<li><strong>延迟 (Latency)</strong>：一个抽象的接口（如
API）完成它的承诺需要多长时间？这是<strong>性能</strong>的直接体现。</li>
<li><strong>流量
(Traffic)</strong>：有多少请求或任务正在压向服务？这是<strong>负载</strong>的直接体现。</li>
<li><strong>错误 (Errors)</strong>：有多少承诺没有被兑现（例如 HTTP
500）？这是<strong>正确性</strong>的直接体现。</li>
</ul>
<p><strong>2. 观测内在状态：系统花多大代价在做？</strong></p>
<p>这是从内部看，我们的模块（服务）为了完成上述外在行为，<strong>内部</strong>的资源和状态是什么样的。</p>
<ul>
<li><strong>饱和度 (Saturation)</strong>：例如，CPU
使用率、内存占用、磁盘
I/O、连接池大小、队列（Kafka）的积压长度。这是<strong>容量</strong>和<strong>健康度</strong>的直接体现。一个外在行为看起来正常（例如延迟低），但其内部状态可能已经处于崩溃边缘（例如队列积压
99%）。</li>
<li><strong>关键业务指标 (Business
Metrics)</strong>：例如，订单创建数、支付成功率、用户注册数。这连接了技术复杂度与<strong>业务价值</strong>。</li>
</ul>
<p><strong>3. 观测交互关系：行为和状态是如何关联的？</strong></p>
<p>动态复杂度的根源在于<strong>“交互”</strong>——<code>模块A</code> 调用
<code>模块B</code>，<code>B</code> 再调用
<code>C</code>。当下单这个行为变慢时，我们<strong>必须</strong>观测这个交互链条。</p>
<ul>
<li><strong>上下文的传播</strong>：观测一个请求<strong>如何穿透</strong>抽象边界、模块边界和分层边界。这就是
<code>TraceID</code> 所做的工作。</li>
<li><strong>高基数的上下文</strong>：我们不仅观测
<code>Latency = 500ms</code>，我们观测的是：<code>Latency&#123;service="payment", user_id="12345", region="eu-west", error="true"&#125;</code>。这允许我们事后去探索那些"<strong>未知的未知</strong>"。例如：为什么只有
<code>eu-west</code> 地区的 <code>VIP</code> 用户的支付行为会失败？</li>
</ul>
<h3 id="可观测性的方案">可观测性的方案</h3>
<p>对于落地可观测性，我的建议是尽可能拥抱
OpenTelemetry，它可以说是目前业界的唯一标准。不要自己去造轮子，不要在自己的业务项目中去"创造"一个自己的
traceID，去拥抱开源标准，你会享受到它的强大和遍历。</p>
<p>我在工作过程中，开源了一套 Go
语言的可观测性方案，感兴趣的读者可参考：<a
target="_blank" rel="noopener" href="https://github.com/hedon954/goapm">goapm</a>。</p>
<h1 id="总结-1">总结</h1>
<p>行文至此，我们完整地构建了"管理复杂度"的"道、法、术、器"四层体系。</p>
<p>我们从"道"出发，明确了软件工程的终极目标——对抗"复杂度"这唯一且根本的敌人。我们亲历的"屎山"、那些"龙卷风战术"，本质上都是复杂度失控后的"熵增"表象。</p>
<p>为了对抗"熵增"，我们找到了"法"——抽象、分治、分层、模块化。这不是空洞的理论，而是无数前辈总结出的、应对"认知局限"这一不变约束的四大“不变法则”。它们是我们的第一性原理，是我们构建一切“术”的基石。</p>
<p>"术"是我们手中的"招式"与"套路"。无论是
SOLID、设计模式，还是宏观的架构模式与
DDD，它们都是"法"在特定场景下的具象化应用。它们是"法"的实践工具箱，是确保我们的“招式”不走形、有据可依的“战法”。</p>
<p>最后，我们必须拥有"器"——单元测试与可观测性。它们是我们构建复杂系统的"双眼"。单元测试是我们管理"静态复杂度"的标尺，它在"设计时"强迫我们遵守"法"与"术"；可观测性是我们管理"动态复杂度"的明镜，它在"运行时"为我们揭示"涌现"出的未知。没有"器"，我们所有的"法"与"术"都只是盲人摸象。</p>
<p>回顾这三年的工作，我曾深陷"屎山"，也曾亲手造"山"。我所经历的痛苦、迷茫与挣扎，其根源就在于，我试图用"术"（例如某个设计模式）去解决"道"（复杂度失控）的问题，却又缺乏"器"（可观测性）来度量结果。</p>
<p>这篇复盘，便是我为那段经历寻找的答案。</p>
<p>"道、法、术、器"不是一个需要背诵的清单，它是一个<strong>完整的、自洽的、循环反馈的作战体系</strong>。它定义了一个软件工程师从“编码”走向“工程”的必经之路。</p>
<p>理解这套体系，不是为了在“屎山”上“雕花”，而是为了让我们在面对下一个"紧急"需求、下一次"龙卷风战术"时，拥有<strong>拒绝“熵增”的武器和底气</strong>。</p>
<h1 id="ai-时代下道法术器的进化">AI 时代下道法术器的进化</h1>
<p>对于管理复杂度这一话题，我不想止步于此，我想多思考一下：</p>
<blockquote>
<p>[!CAUTION]</p>
<p>在 AI 时代下的 AI
应用开发中，软件工程还有存在的意义吗？它的道法术器有什么变化吗？</p>
</blockquote>
<p>我的结论是：</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>AI 应用开发，它首先是一个软件工程问题，然后才是一个 AI
问题。软件工程的地位依旧无可撼动，并且它管理复杂度的"道"并没有发生变化，但是"法"、"术"和"器"必须进化，以应对新的变化和挑战。</p>
</blockquote>
<p>在 AI 时代，尤其是大模型 (LLM)
时代，<strong>抽象、分治、分层、模块化</strong>这四大法则不仅没有过时，反而变得<strong>前所未有地重要</strong>。因为
AI 引入了一种全新的、更棘手的复杂度：<strong>非确定性 (Non-Determinism)
复杂度</strong>。</p>
<p>传统的软件工程对抗的是<strong>逻辑复杂度</strong>（"If-Then-Else"
的复杂度）。 AI 时代的软件工程对抗的是<strong>逻辑复杂度 +
非确定性复杂度</strong>（黑盒模型、概率性输出、数据依赖）。</p>
<h2 id="道的进化从管理到驾驭">道的进化：从管理到驾驭</h2>
<p>AI 时代的软件工程，道依然是<strong>管理复杂度</strong>。但 AI
时代，复杂度本身发生了根本性的变化。</p>
<ul>
<li><strong>旧的复杂度</strong>：是<strong>确定性</strong>的。源于我们自己代码中组件间依赖关系的数量。它是可被推导的，只是过于庞大。</li>
<li><strong>新的复杂度</strong>：是<strong>非确定性</strong>和<strong>涌现性</strong>的。源于
LLM
这个黑盒的概率性本质。我们从管理"代码逻辑"转向管理"模型行为"；我们从"调试
Bug"转向"对抗幻觉"。</li>
</ul>
<p>因此，道的目标，在"管理复杂度"之外，增加了两个新的维度：</p>
<ol type="1">
<li><strong>管理非确定性</strong>：我们如何为"屎山"找到根源？我们如何为"幻觉"构建护栏？我们如何为"概率"设计"重试"与"校验"？</li>
<li><strong>驾驭涌现性</strong>：AI Agent
所展现的自主规划能力是一种涌现。我们的道不再是"自顶向下"地控制一切，而是自底向上地<strong>引导</strong>和<strong>驾驭</strong>这种涌现能力，让它在可控的边界内解决问题。</li>
</ol>
<h2
id="法的进化从逻辑抽象到能力抽象">法的进化：从逻辑抽象到能力抽象</h2>
<h3 id="抽象-1">抽象</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>不变的第一性原理 —— 隐藏实现细节，提供一个简洁、稳定的"接口"。</p>
</blockquote>
<p>传统的抽象隐藏的是<strong>清晰的逻辑</strong>（例如，<code>sort(list)</code>
隐藏了快排的实现）。而 AI
时代的抽象需要隐藏的是一个<strong>模糊的、概率性的黑盒</strong>（例如，<code>summarize(text)</code>
隐藏了 LLM 内部上千亿个参数的复杂推理）。</p>
<p>它的进化：</p>
<ol type="1">
<li><strong>从功能抽象到能力抽象：</strong>
<ul>
<li><em>传统：</em> 我们抽象一个函数
(Function)，它接受确定的输入，产生确定的输出（例如
<code>getUser(id)</code>）。</li>
<li><em>进化：</em> 我们抽象一种能力
(Capability)。例如，<code>OpenAI API</code>
本身就是一种强大的抽象。我们不关心它内部是 Transformer 还是
MoE，我们只关心它暴露了文本生成、图像理解的能力。</li>
</ul></li>
<li><strong>Prompt 成为新的 API：</strong>
<ul>
<li><em>传统：</em> API 是通过严格的函数签名 (Signature) 定义的。</li>
<li><em>进化：</em> <strong>Prompt Engineering
本身就是一种新的抽象实践</strong>。一个精心设计的
Prompt（例如，"你是一个专业的法律助手，请..."）就是创建了一个新的、更可控的抽象层，它将一个通用的
LLM（原始能力）抽象成了一个特定领域的专家（封装后的能力）。</li>
</ul></li>
<li><strong>特征存储成为数据抽象：</strong>
<ul>
<li><em>传统：</em> 我们抽象数据访问层 (DAO / Repository)。</li>
<li><em>进化：</em> 在 MLOps 中，<strong>Feature Store
(特征存储)</strong>
成为了关键的数据抽象。它向模型训练和推理隐藏了数据清洗、转换、聚合的复杂
ETL 过程。模型开发者（高层）不再关心数据（低层）是来自 Kafka 还是
MySQL，他们只关心获取
<code>user_7day_purchase_amount</code>这个被抽象出来的特征。</li>
</ul></li>
</ol>
<h3 id="分治-1">分治</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>不变的第一性原理 ——
将一个无法一次性解决的大问题，分解为多个同类型、可独立解决的小问题，最后再合并。</p>
</blockquote>
<p>在 AI 时代的新挑战
一个单一的、巨大的全能模型难以训练、难以调试、成本高昂。同时，一个复杂的现实问题（例如帮我规划一次东京旅行）也超出了单个
LLM 的能力范围。</p>
<p>它的进化：</p>
<ol type="1">
<li><strong>模型训练中的分治 (MoE)：</strong>
<ul>
<li><em>传统：</em> 归并排序、MapReduce。</li>
<li><em>进化：</em> <strong>混合专家模型 (Mixture of Experts,
MoE)</strong> 是分治思想在模型架构上的极致体现。
<ul>
<li><em>分解 (Divide)：</em> 不训练一个 1.7
万亿参数的巨无霸模型，而是训练（比如） 8 个 2000 亿参数的专家模型。</li>
<li><em>解决 (Conquer)：</em> 当一个 Token 进来时，一个路由器 (Gating
Network) 负责判断这个问题该由哪两个专家来解决？</li>
<li><em>合并 (Combine)：</em> 将这两个专家的输出加权合并。</li>
</ul></li>
</ul></li>
<li><strong>应用架构上的分治 (RAG)：</strong>
<ul>
<li><em>传统：</em> 微服务架构。</li>
<li><em>进化：</em> <strong>RAG (Retrieval-Augmented
Generation，检索增强生成)</strong> 是分治在 AI 应用架构上的最佳实践。
<ul>
<li><em>大问题：</em> 如何让 LLM 回答关于我私有知识库的最新问题？</li>
<li><em>分解 (Divide)：</em> 强迫 LLM
知道一切是不可行的。我们将问题分解为：① 检索 和 ② 生成。</li>
<li><em>解决 (Conquer)：</em>
<ul>
<li>用一个专门的检索模块（例如向量数据库）解决独立的小问题：找到最相关的知识片段。</li>
<li>用 LLM 解决另一个独立的小问题：基于这些片段，生成通顺的回答。</li>
</ul></li>
<li><em>合并 (Combine)：</em>
将检索到的片段（Context）和原始问题（Query）一起合并后，发给 LLM。</li>
</ul></li>
</ul></li>
<li><strong>AI 智能体 (Agents) 和工具使用 (Tool Use)：</strong>
<ul>
<li><em>进化：</em> 当 LLM
遇到一个复杂任务（例如明天天气怎么样？）时，它使用分治：
<ul>
<li><em>分解：</em> ① 我需要知道"明天"和"地点"。②
我需要一个工具来查天气。③ 我需要组织语言。</li>
<li><em>解决：</em> 它调用
<code>call_weather_api("beijing", "tomorrow")</code>，获得 JSON
结果。</li>
<li><em>合并：</em> 它将 JSON
结果合并到它的上下文中，生成最终答案。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="分层-1">分层</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>不变的第一性原理 ——
按"变化的速率"或"职责"划分，管理纵向依赖，上层依赖下层，隔离变化。</p>
</blockquote>
<p>AI
系统的依赖变得极其复杂。它不再只是代码依赖，还包括<strong>数据依赖</strong>、<strong>模型依赖</strong>、<strong>环境依赖</strong>。</p>
<p>它的进化：</p>
<ol type="1">
<li><strong>MLOps 成为新的分层标准：</strong>
<ul>
<li><em>传统：</em> 表现层 → 业务层 → 数据层。</li>
<li><em>进化：</em> <strong>AI
系统的技术栈被重新分层</strong>，每一层都隔离了不同速率的变化：
<ul>
<li><strong>应用层 (Application Layer)：</strong> 传统的 Web
后端。它变化最快（例如 UI 调整）。</li>
<li><strong>AI 编排层 (Orchestration Layer)：</strong> Prompt 模板、RAG
流程、Agent 逻辑。变化较快（例如调整 Prompt）。</li>
<li><strong>模型服务层 (Model Serving Layer)：</strong> API
Gateway、模型推理服务 (Triton,
vLLM)。变化中等（例如模型版本切换）。</li>
<li><strong>模型训练层 (Model Training Layer)：</strong>
训练流水线、实验跟踪 (MLflow)。变化较慢（例如重训模型）。</li>
<li><strong>数据/特征层 (Data/Feature Layer)：</strong>
特征存储、数据湖。变化最慢（例如增加新数据源）。</li>
</ul></li>
<li>这种分层确保了：我可以更新一个
Prompt（编排层），而<strong>无需</strong>重新训练模型（训练层）或重启服务（服务层）。</li>
</ul></li>
<li><strong>"数据-模型-代码" 的依赖分层：</strong>
<ul>
<li><em>进化：</em> 我们必须严格区分三种依赖。在 AI
工程中，<strong>数据是新的代码</strong>。</li>
<li>我们必须建立新的分层依赖规则：<strong>代码 (Code) → 模型 (Model) →
数据 (Data)</strong>。</li>
<li>这意味着，数据的变更会触发模型的重训；模型的变更会触发代码的适配。管理这些"依赖链"和"缓存失效"（例如，数据变了，哪些特征和模型需要重算？）是
AI 时代分层的核心任务。</li>
</ul></li>
</ol>
<h3 id="模块化-1">模块化</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>不变的第一性原理 ——
高内聚、低耦合。将系统划分为"横向"的功能单元，通过清晰的接口协作。</p>
</blockquote>
<p>在 AI 时代的新挑战是如何封装 AI
的非确定性？如何让一个概率性的模块与一个确定性的系统（例如支付模块）安全地协作？</p>
<p>它的进化：</p>
<ol type="1">
<li><strong>模型即模块 (Model as a Module)：</strong>
<ul>
<li><em>传统：</em> 一个 <code>.jar</code> 包或一个 Go
<code>package</code> 是一个模块。</li>
<li><em>进化：</em> <strong>一个经过训练并打包的模型（例如一个 Hugging
Face 仓库）就是 AI
时代的新模块</strong>。它具有极高的内聚性（封装了解决特定任务的所有知识）和极低的耦合性（通过标准的
API 暴露服务）。</li>
</ul></li>
<li><strong>可观测性成为接口的一部分：</strong>
<ul>
<li><em>传统：</em> 模块的接口是 API 签名。</li>
<li><em>进化：</em> AI
模块的接口不仅要包括输入/输出，还必须包括<strong>可观测性</strong>。因为我们无法
100% 信任它的输出，所以模块必须暴露它的内部状态：例如，它输出 "A"
的置信度是多少？它在推理时参考了哪些知识来源？</li>
</ul></li>
<li><strong>确定性外壳模块：</strong>
<ul>
<li><em>进化：</em>
这是模块化思想最重要的进化。我们<strong>不能</strong>让非确定性泄露到系统的其他部分。</li>
<li>我们必须创建一个确定性外壳模块（一个高内聚的封装）：
<ul>
<li><strong>内部 (非确定性)：</strong> 它调用 LLM、处理概率性输出。</li>
<li><strong>外壳 (确定性)：</strong> 它包含防护栏。例如：
<ol type="1">
<li><strong>解析与校验：</strong> 强迫 LLM 输出
JSON，如果解析失败则重试或返回错误。</li>
<li><strong>过滤：</strong> 检查输出是否包含敏感词或幻觉。</li>
<li><strong>回退：</strong> 如果 AI
失败或置信度低，则回退到传统的确定性逻辑（例如
<code>if-else</code>）。</li>
</ol></li>
</ul></li>
<li>这个外壳模块对外提供了一个<strong>看似确定</strong>、<strong>安全</strong>的接口，使得系统的其他部分（如订单处理、支付逻辑）可以安全地调用它。</li>
</ul></li>
</ol>
<h2
id="术的进化从管理逻辑到驾驭概率">术的进化：从管理逻辑到驾驭概率</h2>
<p>AI
时代催生了一系列全新的"术"，它们的核心不再是管理"逻辑的确定性"，而是转向<strong>管理"语义的非确定性"和"编排认知（Cognition）"</strong>。</p>
<p>以下是我认为最重要的四大术之进化：</p>
<h3 id="核心提示词工程与-ai-编排">核心：提示词工程与 AI 编排</h3>
<p>这是 AI
时代<strong>最根本的新"术"</strong>，它几乎重塑了"法"中的抽象和分治。</p>
<ul>
<li><strong>Prompt
即接口</strong>：传统的术是写代码来定义逻辑。全新的术是写
<code>Prompt</code>（自然语言）来<strong>定义能力和契约</strong>。<code>Prompt</code>
成为了我们与 AI 这个非确定性黑盒交互的<strong>新 API</strong>。</li>
<li><strong>编排即分治</strong>：单一 <code>Prompt</code>
无法解决复杂问题。因此，术进化为<strong>AI
编排</strong>（Orchestration），如 LangChain 或 LlamaIndex 所做的那样。
<ul>
<li><strong>RAG
(检索增强生成)</strong>：就是一种编排"术"。它将检索和生成这两个步骤分治开来，并通过编排合并结果。</li>
<li><strong>链式思考 (Chain-of-Thought)</strong>：这是一种引导 AI
分治其内部思维的"术"。</li>
<li><strong>AI 编排层</strong>：在 MLOps
分层中，这一层成为了新的核心。</li>
</ul></li>
</ul>
<h3 id="涌现智能体架构与工具调用">涌现：智能体架构与工具调用</h3>
<p>如果说 RAG 是"分治"的初级形态，那么 Agent
架构就是"术"在"分治"思想上的高级进化，它服务于"道"中"驾驭涌现性"的目标。</p>
<ul>
<li><strong>LLM
即认知引擎</strong>：传统的"术"是工程师自顶向下设计一切。Agent "术"则将
LLM 视为一个可以<strong>自主规划</strong>的认知引擎或中央处理器。</li>
<li><strong>工具即能力模块</strong>：这对应了"法"中的"模块化"。<code>Agent</code>
通过工具调用来扩展其能力。</li>
<li><strong>ReAct
循环</strong>：<code>Reason -&gt; Act -&gt; Observe</code> 的循环，是
<code>Agent</code> 架构中最核心的"术"，它为 AI
的涌现行为提供了一个可控的执行框架。</li>
</ul>
<h3 id="防护确定性外壳">防护：确定性外壳</h3>
<p>这是 AI
时代<strong>保障系统安全和可靠性</strong>的第一防卫术，它源于"法"中"模块化"的思想。</p>
<p>AI
的非确定性是剧毒的，它绝不能泄露到你的核心业务逻辑中（比如支付、订单）。这个"术"的核心就是<strong>封装黑盒、管理边界</strong>。</p>
<p>这个外壳模块 负责所有脏活累活：</p>
<ol type="1">
<li><strong>输入防护</strong>：检查 <code>Prompt</code>
是否合规（防注入）。</li>
<li><strong>输出解析</strong>：强迫 AI 输出
JSON，并进行严格的<strong>校验</strong>、<code>pydantic</code>
风格的类型转换。</li>
<li><strong>安全过滤</strong>：检查 AI
输出是否有害、有偏见、或包含敏感信息。</li>
<li><strong>回退机制</strong>：当 AI
失败、超时或输出"我不知道"时，<strong>回退</strong> 到一个确定的、经典的
<code>if-else</code> 逻辑。</li>
</ol>
<h3 id="工业mlops-与-ai-资产管理">工业：MLOps 与 AI 资产管理</h3>
<p>传统的"术"管理"代码"。AI
时代的"术"必须管理<strong>"代码、模型、数据"三位一体的复杂依赖链</strong>。这就是
MLOps。</p>
<ul>
<li><strong>模型即模块</strong>：AI 时代，一个（例如
<code>Hugging Face</code>
上的）模型，就是一个<strong>可版本化、可部署</strong>的新模块。</li>
<li><strong>数据即代码</strong>：数据是新的代码。因此，"术"必须进化到包含<strong>数据版本管理
(DVC)</strong>、<strong>特征工程 (Feature Engineering)</strong>
和<strong>特征存储 (Feature Store)</strong>。</li>
</ul>
<h2
id="器的进化从确定性标尺到非确定性明镜">器的进化：从确定性标尺到非确定性明镜</h2>
<h3 id="测试">测试</h3>
<p>在 AI 时代，尤其是 LLM
时代，传统测试的第一性原理受到了根本性的挑战。</p>
<ul>
<li><strong>传统测试：</strong> <strong>验证
(Verification)</strong>。其核心是 <strong>确定性
(Determinism)</strong>。我们要求 1+1 必须等于 2。</li>
<li><strong>AI 时代的测试：</strong> <strong>评估
(Evaluation)</strong>。其核心是 <strong>概率性 (Probabilism)</strong> 和
<strong>模糊性
(Fuzziness)</strong>。我们没有所谓的唯一确定的正确答案，但我们知道它应该是"简洁的"、"忠于原文的"、"通顺的"。</li>
</ul>
<p>因此，传统测试在 AI
时代<strong>仍然极端重要，但已远远不够</strong>。它必须进化。</p>
<h4 id="单元测试-1">单元测试</h4>
<p>在 AI
系统中，我们之前讨论过，模块化的进化是使用确定性外壳来包裹非确定性的 AI
内核。<strong>传统单元测试的职责，就是捍卫这个确定性外壳。</strong>它们不测试
AI <em>本身</em>，而是测试所有与 AI
交互的、确定性的<strong>管道和护栏</strong>。</p>
<ul>
<li><strong>测试 Prompt 模板</strong></li>
<li><strong>测试输出解析器 (Parsers)</strong></li>
<li><strong>测试回退逻辑 (Fallbacks)</strong></li>
<li><strong>测试工具调用 (Tool Use)</strong></li>
</ul>
<p>单元测试从"测试业务逻辑"后退到"测试 AI 的输入输出管道"。它保证了无论
AI
表现得多糟糕（例如胡言乱语），我们的系统都不会崩溃，而是会优雅地处理失败。</p>
<h4 id="集成测试">集成测试</h4>
<p><strong>集成测试的职责，是捍卫 AI
工作流的连通性。</strong>它测试的是我们之前讨论的分层与分治架构中，各个模块（服务、数据库、模型
API）之间的胶水层。</p>
<ul>
<li>测试 RAG 流程的集成</li>
<li>测试外部 API 的 Mocking</li>
</ul>
<p>集成测试保证了 AI 应用的骨架是通的。它保证了数据流（Data Flow）在 RAG
管道、微服务和外部 API 之间能正确流转。</p>
<h4 id="新型测试">新型测试</h4>
<p>这是全新的、最重要的一层。传统测试验证
<code>func(in) == out</code>，AI 测试评估
<code>eval(func(in), criteria)</code> 是否为
<code>True</code>。我们不再断言相等，而是评估品质。</p>
<ul>
<li>基于"黄金数据集"的回归测试：检测"新回答"与"理想的回答范例"之间的<strong>语义相似度</strong>。防止有益的修改导致意外的衰退。</li>
<li>基于"启发式"的评估：定义一系列可计算的规则，如上下文相关性、上下文精确度、答案相关性、答案有用度。</li>
<li>基于"对抗性"的测试：传统安全测试中的渗透测试，专门测试 AI
的独特漏洞。如 Prompt 注入、偏见与安全和鲁棒性。</li>
<li>LLM 作为评估者：使用一个更强大的 LLM 作为自动化评估的法官。</li>
</ul>
<h4 id="测试金字塔">测试金字塔</h4>
<p>AI 时代的测试不再是一个简单的金字塔，它演变成了一个双重结构：</p>
<ol type="1">
<li><strong>确定性金字塔 (传统软件 1.0)：</strong>
<ul>
<li><strong>单元测试</strong> (测试管道、解析器、护栏)</li>
<li><strong>集成测试</strong> (测试 RAG 流程、API 连通性)</li>
<li><strong>E2E 测试</strong> (测试 UI 交互)</li>
</ul></li>
<li><strong>概率性评估层 (AI 软件 2.0)：</strong>
<ul>
<li><strong>质量评估</strong> (基于黄金集、启发式、LLM-as-Judge)</li>
<li><strong>安全评估</strong> (对抗性测试、偏见测试)</li>
<li><strong>生产监控 (CI/CT)</strong> (A/B
测试、用户反馈、数据漂移检测)</li>
</ul></li>
</ol>
<p>最后，测试<strong>从部署前延伸到了部署后</strong>。A/B
测试和生产环境的用户反馈成为了持续测试 (Continuous Testing)
的最终闭环。</p>
<h3 id="可观测性-1">可观测性</h3>
<p>传统的动态复杂度是"服务 A 调用 B 变慢了"、"为什么服务 A
突然调不通服务 B 了？"。AI 时代的动态复杂度是"<strong><u>为什么 AI
突然开始胡言乱语了？</u></strong>"。我们必须观测那个<strong>非确定性黑盒的心智过程</strong>。</p>
<p>AI 时代的可观测性，<strong>其进化本质是从"监控系统健康"扩展到"评估 AI
行为与质量"</strong>。传统的三大支柱（metrics、trace、log）仍然是地基，但我们必须在上面加盖全新的楼层。</p>
<h4 id="从三大支柱到四大支柱">从三大支柱到四大支柱</h4>
<p>为了解决上述问题，可观测性正在演化，增加了一个全新的、专为 AI
服务的支柱，我称之为 <strong>AI 交互 (AI
Interactions)</strong>。这有时也被称为 <strong>LLM O11y</strong> 或
<strong>Trace-centric Observability</strong>。</p>
<p>这个新支柱专门捕获 AI 黑盒的"输入-处理-输出"全貌。</p>
<ul>
<li><strong>传统 Logs：</strong>
<code>&#123;"level": "info", "service": "payment", "msg": "payment processed"&#125;</code></li>
<li><strong>AI Logs/Traces ：</strong>
<ul>
<li><strong>Inputs：</strong> 捕获完整的
<strong>Prompt</strong>（包括我们注入的 RAG 上下文、Few-shot
示例）。</li>
<li><strong>Outputs：</strong> 捕获完整的 <strong>Response</strong>（LLM
的原始回答）。</li>
<li><strong>Metadata：</strong>
<ul>
<li><strong>模型参数：</strong> <code>model_name</code> (gpt-4o,
claude-3-sonnet), <code>temperature</code>,
<code>max_tokens</code>。</li>
<li><strong>使用情况 (Usage)：</strong> <code>prompt_tokens</code>,
<code>completion_tokens</code>, <code>total_tokens</code>。</li>
<li><strong>成本 (Cost)：</strong> <code>cost_in_usd</code> (例如
$0.0015)。</li>
<li><strong>延迟 (Latency)：</strong> <code>time_to_first_token</code>,
<code>total_time</code>。</li>
</ul></li>
</ul></li>
</ul>
<p>这个新支柱是后续所有进化的数据基础。</p>
<h4 id="metrics从系统健康到-ai-质量">metrics：从系统健康到 AI 质量</h4>
<p>传统 Metrics 关注 <strong>RED</strong>（速率, 错误率, 耗时）。在 AI
时代，我们增加了全新的 AI 质量指标。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th><strong>指标维度</strong></th>
<th><strong>传统可观测性</strong></th>
<th><strong>AI 时代可观测性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>系统健康</strong></td>
<td><code>http_requests_total</code>
<br><code>http_errors_rate</code><br> <code>cpu_usage</code></td>
<td>(全部保留)<br> <code>llm_api_error_rate</code> (如 429 限流)</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td><code>http_request_duration_p99</code></td>
<td><code>llm_time_to_first_token_p95</code>
<br><code>llm_token_generation_speed</code> (tokens/sec)</td>
</tr>
<tr>
<td><strong>AI 质量</strong></td>
<td>(无)</td>
<td><code>hallucination_rate</code> (幻觉率)<br>
<code>toxicity_score</code> (有毒内容评分) <br>
<code>pii_leakage_count</code> (个人隐私泄露计数) <br>
<code>user_feedback_score</code> (用户点赞/点踩率)</td>
</tr>
<tr>
<td><strong>成本</strong></td>
<td>(无，或模糊的服务器成本)</td>
<td><code>total_cost_per_day</code> (按模型/按用户)
<br><code>cost_per_request</code> (单次请求成本)
<br><code>total_tokens_per_service</code></td>
</tr>
</tbody>
</table>
<p>这意味着可观测性平台 (如 Grafana) 上，除了 CPU
和延迟的图表，<strong>还必须有"每日成本"、"幻觉率"和"用户满意度"的图表</strong>。</p>
<h4 id="tracing从调用链到思维链">tracing：从调用链到思维链</h4>
<ul>
<li><strong>传统 Trace (OpenTelemetry)：</strong>关注的是<strong>操作
(Operations)</strong>。一个 Span (跨度) 代表一个函数调用或一次 RPC。如
<code>Service A</code> -&gt; <code>Service B (Redis GET)</code> -&gt;
<code>Service C (DB Query)</code>。它回答的是请求的瓶颈和问题点出现在哪里？</li>
<li><strong>AI Trace (如 LangSmith,
OpenInference)：</strong>关注的是<strong>上下文 (Context)</strong> 和
<strong>AI 的思考步骤</strong>。
<ul>
<li>一个 Span 不仅代表操作，更代表 AI
链条中的一步，并<strong>富含语义信息</strong>。</li>
<li>以一个 RAG (检索增强生成) 应用为例，一个 AI Trace 必须清晰地展示：
<ol type="1">
<li><strong>[Span 1: Parse Query]</strong> 用户的原始问题。</li>
<li><strong>[Span 2: Embed Query]</strong>
用户的查询被转换成了哪个向量。</li>
<li><strong>[Span 3: Vector Search]</strong>
从向量数据库中<strong>检索到了哪几块(Chunks)文本</strong>？</li>
<li><strong>[Span 4: Build Prompt]</strong> 系统将这些 Chunks
和原始问题<strong>组装成了什么样的最终 Prompt</strong>？</li>
<li><strong>[Span 5: LLM Call]</strong> 调用 LLM (附带 Tokens, Cost
等元数据)。</li>
<li><strong>[Span 6: Parse Output]</strong> 得到 LLM
的原始回答，并解析。</li>
</ol></li>
</ul></li>
</ul>
<p>AI Trace 是<strong>富上下文</strong>的。当一个 RAG 回答错误时，SRE
或工程师需要打开这个 Trace，<strong>一目了然地看到是 Vector Search
没查到相关文档，还是 Prompt 组装错了，还是 LLM 产生了幻觉</strong>。</p>
<h4 id="log从事件记录到评估数据集">log：从事件记录到评估数据集</h4>
<ul>
<li><strong>传统 Logs：</strong> 主要用于事后排障。</li>
<li><strong>AI Logs：</strong>
<ol type="1">
<li><strong>主动排障 (Proactive)：</strong> AI Logs (尤其是捕获的
Prompt/Response) 会被<strong>实时</strong>送入一个评估模型
(Evaluator)。例如，用一个 LLM (如 GPT-4) 去评估另一个 LLM (如 Llama 3)
的回答是否有害。如果评估不通过，<strong>立即触发告警</strong>。</li>
<li><strong>黄金数据集 (Golden Dataset)：</strong>
生产环境中的高质量问答对 (来自 AI Logs) 会被筛选出来，用于微调
(Fine-tuning) 未来的模型，形成一个持续改进的闭环。</li>
</ol></li>
</ul>
<p>可观测性系统不再只是一个"看"的系统，它成了一个"评估"和"再训练"的数据源头。</p>
<h4 id="总结-2">总结</h4>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 37%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th><strong>方面</strong></th>
<th><strong>传统可观测性 (O11y 1.0)</strong></th>
<th><strong>AI 时代可观测性 (O11y 2.0)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心目标</strong></td>
<td>监控系统<strong>健康</strong> (Health)</td>
<td>监控系统健康 + 评估 AI <strong>质量</strong> (Quality)</td>
</tr>
<tr>
<td><strong>主要挑战</strong></td>
<td>分布式系统的复杂性</td>
<td>LLM 的非确定性、黑盒性、幻觉</td>
</tr>
<tr>
<td><strong>Metrics</strong></td>
<td>RED 指标 (速率、错误、耗时)</td>
<td>RED + <strong>质量指标</strong> (幻觉率、满意度) +
<strong>成本指标</strong> (Tokens, Cost)</td>
</tr>
<tr>
<td><strong>Tracing</strong></td>
<td><strong>操作链</strong> (Operation Chain) (如 OpenTelemetry)</td>
<td><strong>思维链 / 上下文链</strong> (Context Chain) (如 LangSmith,
OpenInference)</td>
</tr>
<tr>
<td><strong>Logs</strong></td>
<td>事后排障的<strong>事件记录</strong></td>
<td><strong>评估数据集</strong>，用于实时告警和模型微调</td>
</tr>
<tr>
<td><strong>核心工具</strong></td>
<td>Prometheus, Grafana, Jaeger, ELK</td>
<td>(保留上述工具) + <strong>LLM O11y 平台</strong> (如 LangSmith, Arize
AI, W&amp;B)</td>
</tr>
</tbody>
</table>
<p>总而言之，AI 时代的可观测性，是传统 SRE/DevOps 和 MLOps/Data Science
两个领域的<strong>强制融合</strong>。我们不仅需要工程师，还需要懂 AI
质量评估的专家，共同盯着仪表盘。</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享
4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://hedon.top/2025/11/14/first-job-review-01-tech-01-manager-complexity/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://hedon.top/2025/11/14/first-job-review-01-tech-01-manager-complexity/&title=三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度 - HedonWang&pics=/banner/first-job-review-01-tech-01-manager-complexity.jpg&summary=三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=三年工作复盘丨技术篇：软件工程是什么丨（一）管理复杂度 - HedonWang&amp;body=https://hedon.top/2025/11/14/first-job-review-01-tech-01-manager-complexity/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://hedon.top/2025/11/14/first-job-review-01-tech-01-manager-complexity/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/11/16/go/go-slice/">Go 底层原理丨slice 从第一性原理到实现细节</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/10/14/note/note-obsidian/">读书笔记丨《上头Obsidian：手把手教你用AI做好知识管理》</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="hedon954/hedonspace" data-repo-id="R_kgDOKt17sQ" data-category="Q&A" data-category-id="DIC_kwDOKt17sc4CbAt-" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Hedon Wang</a> 使用 <a
target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar
1.29.1</a> 主题创建。 本博客所有文章除特别声明外，均采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA
4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%93%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E7%BB%88%E6%9E%81%E7%9B%AE%E6%A0%87"><span class="toc-text">道：管理复杂度是我们的终极目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%95%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-text">法：管理复杂度的四大核心原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">抽象的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-text">抽象的难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">抽象的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">技术层面的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%B1%82%E9%9D%A2%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">业务层面的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%93%AA"><span class="toc-text">接口定义在哪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">抽象的时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-text">分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">分治的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-text">分治的边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%86%E6%B2%BB"><span class="toc-text">真正的分治</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-text">分层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">分层的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%E6%8C%89%E4%BB%80%E4%B9%88%E5%88%86%E4%BB%A5%E5%8F%98%E5%8C%96%E7%9A%84%E9%80%9F%E7%8E%87%E4%BD%9C%E4%B8%BA%E5%88%87%E5%88%86%E6%A0%87%E5%87%86"><span class="toc-text">原则一：按什么分？以变化的速率作为切分标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%E8%B0%81%E4%BE%9D%E8%B5%96%E8%B0%81%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-text">原则二：谁依赖谁？依赖倒置原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%E5%B1%82%E4%B8%8E%E5%B1%82%E5%A6%82%E4%BD%95%E5%AF%B9%E8%AF%9D%E4%B8%A5%E6%A0%BC%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-text">原则三：层与层如何对话？严格的接口与封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%9D%8F%E5%91%B3%E9%81%93"><span class="toc-text">分层坏味道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E5%85%B8%E8%8C%83"><span class="toc-text">分层的典范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-text">分层的实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">网络协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="toc-text">数据库系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">Go 网络编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-text">模块化的实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%BF%E4%B8%8E-pcle"><span class="toc-text">硬件与计算机体系结构：总线与
PCle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%88%B0%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">操作系统：从驱动程序到微内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcpip-%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-text">计算机网络：TCP&#x2F;IP 协议栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9Fsql-%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="toc-text">数据库系统：SQL 与存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Redis：插件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka%E7%AE%A1%E9%81%93%E4%B8%8E%E6%8F%92%E5%A4%B4%E7%9A%84%E5%88%86%E7%A6%BB"><span class="toc-text">Kafka：管道与插头的分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rag-%E4%B8%8E-ai-agent%E5%A4%A9%E7%94%9F%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">RAG 与 AI Agent：天生的模块化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8C%87%E5%AF%BC%E6%A1%86%E6%9E%B6"><span class="toc-text">术：构建与设计的指导框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#solid-%E5%8E%9F%E5%88%99"><span class="toc-text">SOLID 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-srp---single-responsibility-principle"><span class="toc-text">单一职责原则
(SRP - Single Responsibility Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99-ocp---openclosed-principle"><span class="toc-text">开放封闭原则 (OCP -
Open&#x2F;Closed Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-lsp---liskov-substitution-principle"><span class="toc-text">里氏替换原则
(LSP - Liskov Substitution Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-isp---interface-segregation-principle"><span class="toc-text">接口隔离原则
(ISP - Interface Segregation Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99-dip---dependency-inversion-principle"><span class="toc-text">依赖倒置原则
(DIP - Dependency Inversion Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B8%85%E5%8D%95"><span class="toc-text">设计模式清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">理解设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">创建型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">结构型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">行为型模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A5%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">用好设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%B6%E6%9E%84"><span class="toc-text">什么是架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%8E%9F%E7%90%86"><span class="toc-text">架构选择的两大原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99"><span class="toc-text">架构原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">常用架构模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">领域驱动设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ddd-%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">DDD 存在的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ddd-%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83"><span class="toc-text">DDD 两大核心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E5%9C%A8%E5%AE%8F%E8%A7%82%E4%B8%8A%E5%88%92%E5%88%86%E6%88%98%E5%9C%BA"><span class="toc-text">战略设计：在宏观上划分战场</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1%E5%9C%A8%E5%BE%AE%E8%A7%82%E4%B8%8A%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%9E%8B"><span class="toc-text">战术设计：在微观上保护模型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%99%A8%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%B4%9E%E5%AF%9F%E7%9A%84%E8%B4%A8%E9%87%8F%E6%89%8B%E6%AE%B5"><span class="toc-text">器：验证与洞察的质量手段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-text">可观测性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">可观测性的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">可观测性的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-text">可观测性的方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ai-%E6%97%B6%E4%BB%A3%E4%B8%8B%E9%81%93%E6%B3%95%E6%9C%AF%E5%99%A8%E7%9A%84%E8%BF%9B%E5%8C%96"><span class="toc-text">AI 时代下道法术器的进化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%93%E7%9A%84%E8%BF%9B%E5%8C%96%E4%BB%8E%E7%AE%A1%E7%90%86%E5%88%B0%E9%A9%BE%E9%A9%AD"><span class="toc-text">道的进化：从管理到驾驭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%95%E7%9A%84%E8%BF%9B%E5%8C%96%E4%BB%8E%E9%80%BB%E8%BE%91%E6%8A%BD%E8%B1%A1%E5%88%B0%E8%83%BD%E5%8A%9B%E6%8A%BD%E8%B1%A1"><span class="toc-text">法的进化：从逻辑抽象到能力抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-1"><span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB-1"><span class="toc-text">分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82-1"><span class="toc-text">分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-1"><span class="toc-text">模块化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E7%9A%84%E8%BF%9B%E5%8C%96%E4%BB%8E%E7%AE%A1%E7%90%86%E9%80%BB%E8%BE%91%E5%88%B0%E9%A9%BE%E9%A9%AD%E6%A6%82%E7%8E%87"><span class="toc-text">术的进化：从管理逻辑到驾驭概率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E4%B8%8E-ai-%E7%BC%96%E6%8E%92"><span class="toc-text">核心：提示词工程与 AI 编排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%8C%E7%8E%B0%E6%99%BA%E8%83%BD%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8"><span class="toc-text">涌现：智能体架构与工具调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%A4%96%E5%A3%B3"><span class="toc-text">防护：确定性外壳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%B8%9Amlops-%E4%B8%8E-ai-%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86"><span class="toc-text">工业：MLOps 与 AI 资产管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%A8%E7%9A%84%E8%BF%9B%E5%8C%96%E4%BB%8E%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%A0%87%E5%B0%BA%E5%88%B0%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%98%8E%E9%95%9C"><span class="toc-text">器的进化：从确定性标尺到非确定性明镜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-1"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-text">集成测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%9E%8B%E6%B5%8B%E8%AF%95"><span class="toc-text">新型测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-text">测试金字塔</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-1"><span class="toc-text">可观测性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%B8%89%E5%A4%A7%E6%94%AF%E6%9F%B1%E5%88%B0%E5%9B%9B%E5%A4%A7%E6%94%AF%E6%9F%B1"><span class="toc-text">从三大支柱到四大支柱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#metrics%E4%BB%8E%E7%B3%BB%E7%BB%9F%E5%81%A5%E5%BA%B7%E5%88%B0-ai-%E8%B4%A8%E9%87%8F"><span class="toc-text">metrics：从系统健康到 AI 质量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tracing%E4%BB%8E%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%B0%E6%80%9D%E7%BB%B4%E9%93%BE"><span class="toc-text">tracing：从调用链到思维链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log%E4%BB%8E%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%E5%88%B0%E8%AF%84%E4%BC%B0%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">log：从事件记录到评估数据集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":"https://site-info-api-hedon.vercel.app/api/v1?url={href}"},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img, .md-text img:not([class]), .md-text .image img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
