
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Go 底层原理丨网络编程 - HedonWang</title>

  
    <meta name="description" content="本文立足于 Go 1.25 版本源码，系统拆解 Go 网络编程模型的底层机制，解析 Goroutine 如何实现同步代码，异步执行、net 包的核心实现，以及 I&#x2F;O 多路复用背后的第一性原理，带你从源码视角理解 Go 网络高并发的秘密。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 底层原理丨网络编程">
<meta property="og:url" content="https://hedon.top/2025/11/23/go/go-net/index.html">
<meta property="og:site_name" content="HedonWang">
<meta property="og:description" content="本文立足于 Go 1.25 版本源码，系统拆解 Go 网络编程模型的底层机制，解析 Goroutine 如何实现同步代码，异步执行、net 包的核心实现，以及 I&#x2F;O 多路复用背后的第一性原理，带你从源码视角理解 Go 网络高并发的秘密。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5leaayjlcj20u010zn0e.jpg">
<meta property="article:published_time" content="2025-11-23T04:00:00.000Z">
<meta property="article:modified_time" content="2025-12-04T12:15:29.767Z">
<meta property="article:author" content="Hedon Wang">
<meta property="article:tag" content="epoll">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5leaayjlcj20u010zn0e.jpg">
  
  
  
  <meta name="keywords" content="epoll,网络编程,Go">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="HedonWang" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">


  
    <link rel="shortcut icon" href="/assets/favicon.png">
  

  

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.png"><link rel="shortcut icon" href="/assets/favicon.png"><meta name="theme-color" content="#f8f8f8"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/markmap.css"><script src="https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18"></script>
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/assets/favicon.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/"><div class="main" ff="title">HedonWang</div><div class="sub cap">君子求诸己，律己则安。</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="专栏" href="/topic/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于我" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="思维导图" href="/html/mindmap.html" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">
<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">专栏：Go 底层原理</span></div><div class="widget-body"><a class="item active" href="/2025/11/23/go/go-net/"><span class="title">Go 底层原理丨网络编程</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/11/22/go/go-channel/"><span class="title">Go 底层原理丨channel</span></a><a class="item" href="/2025/11/21/go/go-lock/"><span class="title">Go 底层原理丨锁</span></a><a class="item" href="/2025/11/19/go/go-gc-green-tea-gc/"><span class="title">Go 底层原理丨垃圾回收（green tea gc）</span></a><a class="item" href="/2025/11/17/go/go-gc-tri-color-marking/"><span class="title">Go 底层原理丨垃圾回收（三色标记法）</span></a><a class="item" href="/2025/11/17/go/go-memory-model/"><span class="title">Go 底层原理丨内存模型</span></a><a class="item" href="/2025/11/17/go/go-interface/"><span class="title">Go 底层原理丨interface</span></a><a class="item" href="/2025/11/16/go/go-map-swiss/"><span class="title">Go 底层原理丨map（Swiss Table 版本）</span></a><a class="item" href="/2025/11/16/go/go-map-no-swiss/"><span class="title">Go 底层原理丨map（非 swiss 版本）</span></a><a class="item" href="/2025/11/16/go/go-slice/"><span class="title">Go 底层原理丨slice 从第一性原理到实现细节</span></a><a class="item" href="/2025/06/30/go/go-gin/"><span class="title">Go 底层原理丨深度剖析 Gin 框架核心机制：从 HTTP 请求生命周期到高性能设计哲学</span></a><a class="item" href="/2024/03/28/go/go-defer/"><span class="title">深入浅出 Go 语言的 defer 机制</span></a><a class="item" href="/2024/03/09/go/go-struct/"><span class="title">深入 Go 语言核心：结构体的全方位解析</span></a><a class="item" href="/2024/01/20/go/go-gpm/"><span class="title">深入浅出 Go 语言的 GPM 模型（Go1.21）</span></a><a class="item" href="/2023/12/07/go/go-start/"><span class="title">Go1.21.0 程序启动过程</span></a><a class="item" href="/2023/11/29/go/go-compilation/"><span class="title">Go1.21.0 程序编译过程</span></a></div></widget>

<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/11/17/go/go-gc-tri-color-marking/"><span class="title">Go 底层原理丨垃圾回收（三色标记法）</span></a><a class="item title" href="/2025/12/09/redis/redis-datatype/"><span class="title">盘点 Redis 各种数据类型</span></a><a class="item title" href="/2025/11/17/go/go-memory-model/"><span class="title">Go 底层原理丨内存模型</span></a><a class="item title" href="/2025/12/08/mysql/mysql-binlog-practice/"><span class="title">MySQL Binlog 实践 CDC</span></a><a class="item title" href="/2025/04/09/note/note-unit-testing/"><span class="title">读书笔记丨《Unit Testing Principles, Practices, and Patterns》</span></a><a class="item title" href="/2025/04/09/note/note-unit-testing-excerpt/"><span class="title">书籍摘抄丨《Unit Testing Principles, Practices, and Patterns》</span></a><a class="item title" href="/2025/06/12/note/note-rust-atomics-and-locks/"><span class="title">读书笔记丨《Rust Atomics and Locks》</span></a><a class="item title" href="/2025/10/14/note/note-obsidian/"><span class="title">读书笔记丨《上头Obsidian：手把手教你用AI做好知识管理》</span></a><a class="item title" href="/2025/07/24/note/note-fosa/"><span class="title">读书笔记丨《Fundamentals of Software Architecture》</span></a><a class="item title" href="/2025/03/11/note/note-ddd-awareness/"><span class="title">读书笔记丨《悟道领域驱动设计》</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/11/23/go/go-net/">Go 底层原理</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-11-23T04:00:00.000Z">2025-11-23</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-12-04T12:15:29.767Z">2025-12-04</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Go 底层原理丨网络编程</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>本篇我们将讨论 Go 语言底层的网络编程原理，本篇将揭示 Go
语言是如何做到<strong>同步的代码，异步的执行</strong>。</p>
<p>特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro
共创所作，非常庆幸在当今 AI
时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p>
<p>在开启本章之前，你最好对下列知识有一点的了解：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://hedon954.github.io/noteSite/cs/cn/cn-transfer-layer.html">计算机网络
- 传输层</a></li>
<li><a
target="_blank" rel="noopener" href="https://hedon954.github.io/noteSite/cs/cn/cn-apply-layer.html#_5-socket">计算机网络
- 应用层 - Socket</a></li>
<li><a
target="_blank" rel="noopener" href="https://hedon954.github.io/noteSite/linux/linux-io/0-concept.html">Linux
IO 模型</a></li>
<li><a
target="_blank" rel="noopener" href="https://hedon954.github.io/noteSite/backend/golang/high/net.html">Go
网络编程</a></li>
<li><a
href="https://hedon.top/2025/11/23/linux-io-epoll/">从第一性原理理解
epoll</a></li>
</ul>
<h1 id="宏观概述">1. 宏观概述</h1>
<p>要从根本上理解 Go
的网络编程模型，我们需要剥离掉语法糖，回到计算机体系结构和操作系统原理的
<strong>第一性原理</strong>：<strong>如何高效地处理 CPU 计算与 I/O
等待之间的速度差异？</strong></p>
<p>Go
的网络模型之所以强大，是因为它在一个极其优雅的抽象层（Goroutine）下，完美隐藏了复杂的异步
I/O 细节。</p>
<p>接下来让我们尝试由表及里，从编程模型到内核实现，分三个层级来剖析。</p>
<h2 id="第一层编程模型-同步的代码异步的执行">2.1 第一层：编程模型 ——
同步的代码，异步的执行</h2>
<p>在 Go 1.25 中，网络编程的依然遵循着 Go
诞生之初的哲学：<strong>Goroutine-per-connection</strong>。开发者编写的是标准的
<strong>同步阻塞式（Synchronous Blocking）</strong> 代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发者视角：逻辑是线性的</span></span><br><span class="line">listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, _ := listener.Accept() <span class="comment">// 看起来这里阻塞了，直到有新连接</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        n, _ := c.Read(buf) <span class="comment">// 看起来这里阻塞了，直到有数据</span></span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果按照 C 语言或早期 Java
的传统线程模型，上述代码意味着每个连接需要一个 OS
线程。但线程太重了（栈内存约 1MB - 8MB，上下文切换成本高）。但是在 Go
语言中，当你调用 <code>c.Read</code> 时，当前的 Goroutine
确实"暂停"了，但底层的操作系统线程（M）并没有阻塞，而是去干别的活了。这样开发者拥有了编写简单线性逻辑的权利，同时享受了非阻塞
I/O 的高性能。</p>
<h2 id="第二层系统调用层-非阻塞-io-的伪装">2.2 第二层：系统调用层 ——
非阻塞 I/O 的伪装</h2>
<p>为了实现上述同步阻塞的假象，Go 在底层实际上使用的是 <strong>非阻塞
I/O（Non-blocking I/O）</strong>。</p>
<p>在 Go 1.25 的 <code>net</code> 包内部，当你创建一个 socket 时，Go
Runtime 会通过系统调用（如 Linux 下的 <code>socket</code> +
<code>fcntl</code>）显式地将该文件描述符（File Descriptor, FD）设置为
<strong>Non-blocking</strong> 模式。</p>
<p>当你调用 <code>conn.Read()</code> 时，Go 底层实际执行了以下逻辑：</p>
<ol type="1">
<li><strong>直接尝试读取：</strong> 直接对 FD 发起 <code>read</code>
系统调用。</li>
<li><strong>EAGAIN 错误：</strong> 绝大多数时候，内核缓冲区是空的。因为
FD 是非阻塞的，操作系统不会让线程睡眠，而是立刻返回一个
<code>EAGAIN</code>（或
<code>EWOULDBLOCK</code>）错误，表示现在没数据，别堵在这。</li>
<li><strong>捕获错误并挂起：</strong> Go
的网络库捕获到这个错误，意识到"现在读不到数据"。于是，它不会让代码报错，而是通过
Runtime 调度器将当前的 <strong>Goroutine</strong> 状态置为
<code>Gwaiting</code>（等待中），并将该 Goroutine 移出 CPU
执行队列。</li>
</ol>
<h2 id="第三层runtime-核心-netpoller-与-gmp-的联动">2.3 第三层：Runtime
核心 —— Netpoller 与 GMP 的联动</h2>
<p>这是 Go 网络模型的心脏。Go 引入了一个名为 <strong>Netpoller</strong>
的组件，它是 Go Runtime 与操作系统 I/O 多路复用机制（I/O
Multiplexing）之间的桥梁。</p>
<p>Netpoller 并不是一个一直运行的独立线程，而是 Runtime
中的一组函数逻辑。它封装了不同操作系统的多路复用技术：</p>
<ul>
<li><strong>Linux:</strong> <code>epoll</code></li>
<li><strong>macOS/FreeBSD:</strong> <code>kqueue</code></li>
<li><strong>Windows:</strong> <code>IOCP</code></li>
</ul>
<p>在 Linux 的 <code>epoll</code> 中，包含 3 个核心函数：</p>
<ul>
<li>新建多路复用器：<code>epoll_create()</code></li>
<li>插入监听事件：<code>epoll_ctl()</code></li>
<li>查询发生了什么事件：<code>epoll_wait()</code></li>
</ul>
<p>Go 的 Netpoller 提供了对各个平台多路复用器的抽象和适配：</p>
<ul>
<li><code>netpollinit</code> -&gt; <code>epoll_create</code></li>
<li><code>netpollopen</code> -&gt; <code>epoll_ctl</code></li>
<li><code>netpoll</code> -&gt; <code>epoll_wait</code></li>
</ul>
<p>让我们回到刚才 <code>conn.Read()</code> 返回 <code>EAGAIN</code>
的时刻：</p>
<ol type="1">
<li><strong>注册（Register）：</strong> 当前运行的 Goroutine (G)
在被挂起前，会将自己的 FD 和期望的事件（如可读）注册到 Netpoller
中。本质上是调用了 <code>epoll_ctl</code> 将 FD 加入监听列表。</li>
<li><strong>让出（Park）：</strong> G
停止运行，M（系统线程）现在空闲了。M 会根据 GMP 调度模型，从
P（处理器）的本地队列中抓取下一个可运行的 G 去执行。</li>
<li><strong>监控（Poll）：</strong> 什么时候唤醒原来的 G？
<ul>
<li><strong>被动触发：</strong> 当系统监控线程 <code>sysmon</code>
运行，或者调度器发现没有 G 可运行时，会调用
<code>runtime.netpoll</code>。</li>
<li><strong>底层机制：</strong> <code>runtime.netpoll</code> 内部调用
<code>epoll_wait</code>，询问操作系统我关注的那些 FD
有哪些数据到了。</li>
</ul></li>
<li><strong>唤醒（Ready）：</strong> 操作系统返回就绪的 FD
列表。Netpoller 根据 FD 找到当初阻塞在上面的 Goroutine，将其状态改为
<code>Grunnable</code>（可运行），并将其注入到当前 P
的本地队列或全局队列中。</li>
<li><strong>执行：</strong> 在下一轮调度中，原来的 G 被 M 拿到，继续执行
<code>conn.Read()</code> 后面的代码。</li>
</ol>
<h2 id="小节">2.4 小节</h2>
<p>如果用文字总结这套机制的精髓，可以概括为：<strong>用户态的阻塞，内核态的非阻塞；线性的逻辑，事件驱动的内核。</strong></p>
<p><strong>完整的数据流向图解：</strong></p>
<ol type="1">
<li><strong>User:</strong> <code>conn.Read(buf)</code></li>
<li><strong>Go Runtime (Poll):</strong> <code>syscall.Read(fd)</code>
-&gt; 返回 <code>EAGAIN</code></li>
<li><strong>Go Scheduler:</strong>
<ul>
<li>调用 <code>netpollOpen</code> (注册 epoll)</li>
<li>调用 <code>gopark</code> (挂起当前 G，状态 -&gt; Gwaiting)</li>
<li>线程 M 切换去执行其他 G</li>
</ul></li>
<li><strong>--- 时间流逝，网络包到达网卡 ---</strong></li>
<li><strong>OS Kernel:</strong> 中断处理，数据拷贝到内核缓冲区，FD 变为
Readable。</li>
<li><strong>Go Runtime (Monitor/Schedule):</strong>
<ul>
<li><code>sysmon</code> 或 调度器执行 <code>netpoll</code>
(<code>epoll_wait</code>)</li>
<li>发现 FD 就绪</li>
<li>调用 <code>goready</code> (找到对应的 G，状态 -&gt; Grunnable)</li>
</ul></li>
<li><strong>Go Scheduler:</strong> G 被放入队列，最终被 M 执行。</li>
<li><strong>User:</strong> <code>conn.Read</code> 从挂起处恢复，再次执行
<code>syscall.Read</code>，成功读取数据。</li>
</ol>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant G as User Goroutine (G)
    participant NP as Netpoller (Internal)
    participant Sched as Go Scheduler (M/P)
    participant OS as OS Kernel (epoll/IO)

    Note over G, Sched: 阶段一：发起读请求 (User Space)

    G->>NP: 1. conn.Read(buf)
    activate G
    activate NP

    NP->>OS: 2. syscall.Read(fd) (非阻塞)
    OS-->>NP: 3. 返回 EAGAIN (无数据)

    Note right of NP: 判定需要挂起

    NP->>OS: 4. netpollOpen / epoll_ctl<br/>(注册 FD 到 epoll 实例)
    NP->>Sched: 5. gopark (请求挂起 G)
    deactivate NP
    deactivate G

    activate Sched
    Note over G: 状态: Grunning -> Gwaiting
    Note over Sched: 6. 线程 M 解绑当前 G<br/>M 切换去执行其他 G
    deactivate Sched

    Note over G, OS: 阶段二：异步等待 (Kernel Space)

    G-x G: (Goroutine 暂停，不消耗 CPU)
    Note over OS: ... 时间流逝 ...
    Note over OS: 7. 网络包到达 -> 中断处理<br/>数据拷入内核缓冲区 -> FD Readable

    Note over G, OS: 阶段三：唤醒与执行 (Runtime Monitor)

    loop Sysmon 或 调度器检查
        Sched->>OS: 8. netpoll (epoll_wait)
        OS-->>Sched: 9. 返回就绪 FD 列表
    end

    activate Sched
    Sched->>Sched: 根据 FD 找到对应的 G
    Sched->>Sched: 10. goready(G)
    Note over G: 状态: Gwaiting -> Grunnable

    Sched-->>G: 11. G 被放入本地/全局队列<br/>最终被 M 捕获并执行
    deactivate Sched

    activate G
    Note over G: 从 gopark 处恢复代码执行

    G->>NP: 12. 再次调用 internal read
    activate NP
    NP->>OS: 13. syscall.Read(fd)
    OS-->>NP: 14. 返回实际数据 (Data)
    NP-->>G: 15. 返回 n, err
    deactivate NP
    deactivate G</pre>
<h1 id="源码剖析">2. 源码剖析</h1>
<p>在对 Go
的网络编程模型有了一定的宏观了解后，本篇我们将深入底层源码来剖析 Go
Runtime 是如何实现上面这些能力的。</p>
<h2 id="go-的系统调用的封装">2.1 Go 的系统调用的封装</h2>
<p>在 Go1.16 左右的版本（笔者之前研究的是 Go.16
版本，对其他版本可能不太熟悉），Go 对
<code>epoll_create</code>、<code>epoll_ctl</code>
等系统调用，每个都有单独的汇编实现，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int32 runtime·epollcreate(int32 size);</span></span><br><span class="line">TEXT runtime·epollcreate(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVL    size+<span class="number">0</span>(FP), DI</span><br><span class="line">	MOVL    $SYS_epoll_create, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	MOVL	AX, ret+<span class="number">8</span>(FP)</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// func epollctl(epfd, op, fd int32, ev *epollEvent) int</span></span><br><span class="line">TEXT runtime·epollctl(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVL	epfd+<span class="number">0</span>(FP), DI</span><br><span class="line">	MOVL	op+<span class="number">4</span>(FP), SI</span><br><span class="line">	MOVL	fd+<span class="number">8</span>(FP), DX</span><br><span class="line">	MOVQ	ev+<span class="number">16</span>(FP), R10</span><br><span class="line">	MOVL	$SYS_epoll_ctl, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	MOVL	AX, ret+<span class="number">24</span>(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>但是当最近笔者在阅读 Go 1.25 版本的源码时，发现 Go
已经统一了系统调用的入口了，如 linux amd64 平台上，Go
将系统调用统一封装在 <a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/asm_linux_amd64.s">internal/runtime/syscall/asm_linux_amd64.s</a>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)</span><br><span class="line">TEXT ·Syscall6&lt;ABIInternal&gt;(SB),NOSPLIT,$0</span><br><span class="line">	// a6 already in R9.</span><br><span class="line">	// a5 already in R8.</span><br><span class="line">	MOVQ	SI, R10 // a4</span><br><span class="line">	MOVQ	DI, DX  // a3</span><br><span class="line">	MOVQ	CX, SI  // a2</span><br><span class="line">	MOVQ	BX, DI  // a1</span><br><span class="line">	// num already in AX.</span><br><span class="line">	SYSCALL</span><br><span class="line">	CMPQ	AX, $0xfffffffffffff001</span><br><span class="line">	JLS	ok</span><br><span class="line">	NEGQ	AX</span><br><span class="line">	MOVQ	AX, CX  // errno</span><br><span class="line">	MOVQ	$-1, AX // r1</span><br><span class="line">	MOVQ	$0, BX  // r2</span><br><span class="line">	RET</span><br><span class="line">ok:</span><br><span class="line">	// r1 already in AX.</span><br><span class="line">	MOVQ	DX, BX // r2</span><br><span class="line">	MOVQ	$0, CX // errno</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>我们不用太纠结它的具体实现，通过注释，我们可以知道这段汇编对应的就是
Go 里面的 <code>Syscall6</code>，具体位于 <a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L17">runtime/syscall/syscall_linux.go#L17</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syscall6 calls system call number &#x27;num&#x27; with arguments a1-6.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall6</span><span class="params">(num, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2, errno <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>
<p>它的具体运用在 <a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/syscall/syscall_linux.go#L95">syscall/syscall_linux.go#L95</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:uintptrkeepalive</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:linkname Syscall6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno) &#123;</span><br><span class="line">	runtime_entersyscall()</span><br><span class="line">	r1, r2, err = RawSyscall6(trap, a1, a2, a3, a4, a5, a6)</span><br><span class="line">	runtime_exitsyscall()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:uintptrkeepalive</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:norace</span></span><br><span class="line"><span class="comment">//go:linkname RawSyscall6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RawSyscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno) &#123;</span><br><span class="line">	<span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">	r1, r2, errno = runtimesyscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)</span><br><span class="line">	err = Errno(errno)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候 <code>epollo_create</code>、<code>epollo_wait</code> 和
<code>epollo_ctl</code> 就很好实现了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCreate1</span><span class="params">(flags <span class="type">int32</span>)</span></span> (fd <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	r1, _, e := Syscall6(SYS_EPOLL_CREATE1, <span class="type">uintptr</span>(flags), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _zero <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollWait</span><span class="params">(epfd <span class="type">int32</span>, events []EpollEvent, maxev, waitms <span class="type">int32</span>)</span></span> (n <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> ev unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(events) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ev = unsafe.Pointer(&amp;events[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ev = unsafe.Pointer(&amp;_zero)</span><br><span class="line">	&#125;</span><br><span class="line">	r1, _, e := Syscall6(SYS_EPOLL_PWAIT, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(ev), <span class="type">uintptr</span>(maxev), <span class="type">uintptr</span>(waitms), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCtl</span><span class="params">(epfd, op, fd <span class="type">int32</span>, event *EpollEvent)</span></span> (errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	_, _, e := Syscall6(SYS_EPOLL_CTL, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(op), <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(event)), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="go-对-epoll-的抽象---network-poller">2.2 Go 对 Epoll 的抽象 -
network poller</h2>
<blockquote>
<p>本文仅介绍针对 Linux AMD64 的实现。</p>
</blockquote>
<p>Go NetWork Poll 是对各个平台多路复用器的抽象和适配：</p>
<ul>
<li><code>netpollinit</code> -&gt; <code>epoll_create</code></li>
<li><code>netpollopen</code> -&gt; <code>epoll_ctl</code></li>
<li><code>netpoll</code> -&gt; <code>epoll_wait</code></li>
</ul>
<h3 id="netpollinit---epoll_create">2.1.1 netpollinit -&gt;
epoll_create</h3>
<p>系统指令：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L14">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_CREATE1 = <span class="number">291</span></span><br></pre></td></tr></table></figure>
<p>Go 中的声明：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L19">EpolloCreate1</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCreate1</span><span class="params">(flags <span class="type">int32</span>)</span></span> (fd <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	r1, _, e := Syscall6(SYS_EPOLL_CREATE1, <span class="type">uintptr</span>(flags), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">	epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_EPOLL_CLOEXEC</code>：创建的 epfd 会设置
<code>FD_CLOEXEC</code>，它是一个 fd 的标识说明，用来设置文件的
close-on-exec 状态的。当 close-on-exec 状态为 0 时，调用 exec 时，fd
不会被关闭；非零状态时则会被关闭，这样做可以防止 fd 泄露给执行 exec
后的进程。</li>
</ul>
<p>针对 Linux 的实现：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L21">runtime/netpoll_epoll.go</a></strong></p>
<ol type="1">
<li><strong>创建 epoll 实例</strong>：创建 Linux 的 I/O
多路复用器，用于同时监控成千上万个网络连接。</li>
<li><strong>创建
eventfd</strong>：创建一个特殊的文件描述符，用于唤醒阻塞线程。</li>
<li><strong>将 eventfd 注册到
epoll</strong>：这样既能等网络事件，也能被主动唤醒。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建多路复用器，这个函数在 Go 程序启动时被调用一次，用于初始化 Linux 平台的网络轮询器（netpoller）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">  <span class="comment">// 1. 创建一个 epoll 实例，返回的文件描述符存储在全局变量 `epfd` 中</span></span><br><span class="line">  <span class="comment">//		`EPOLL_CLOEXEC` 标志确保在 `exec` 时自动关闭这个 fd</span></span><br><span class="line">	epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 2. 创建一个 eventfd，这是 Linux 的一种特殊文件描述符</span></span><br><span class="line">  <span class="comment">// 		设置为非阻塞模式（EFD_NONBLOCK）和 exec 时关闭（EFD_CLOEXEC）</span></span><br><span class="line">  <span class="comment">// 		eventfd 用于唤醒阻塞在 `epoll_wait` 上的线程。这是 Go netpoller 的关键机制！</span></span><br><span class="line">	efd, errno := syscall.Eventfd(<span class="number">0</span>, syscall.EFD_CLOEXEC|syscall.EFD_NONBLOCK)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: eventfd failed with&quot;</span>, -errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: eventfd failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 3. 构造 epollo 事件结构，syscall.EPOLLIN 表示监听可读事件</span></span><br><span class="line">	ev := syscall.EpollEvent&#123;</span><br><span class="line">		Events: syscall.EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 4. 将 netpollEventFd 的地址存储到 ev.Data 中</span></span><br><span class="line">  <span class="comment">//		当 epoll 返回事件时，我们需要知道是哪个 fd 触发的事件。</span></span><br><span class="line">  <span class="comment">//		通过 Data 字段，我们可以区分：</span></span><br><span class="line">  <span class="comment">//			- 是 eventfd 触发的（唤醒信号）</span></span><br><span class="line">  <span class="comment">//			- 还是某个网络连接 fd 触发的（真正的网络 I/O）</span></span><br><span class="line">	*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) = &amp;netpollEventFd</span><br><span class="line">  <span class="comment">// 5. 使用 `EPOLL_CTL_ADD` 操作将 eventfd 添加到 epoll 实例中</span></span><br><span class="line">  <span class="comment">//		当 eventfd 变为可读时，epoll_wait 会返回</span></span><br><span class="line">	errno = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, efd, &amp;ev)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 6. 将 eventfd 保存到全局变量中</span></span><br><span class="line">  <span class="comment">//		后续 `netpollBreak()` 函数会使用这个 fd 来唤醒阻塞的 epoll_wait</span></span><br><span class="line">	netpollEventFd = <span class="type">uintptr</span>(efd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netpollopen---epoll_ctl">2.1.2 netpollopen -&gt; epoll_ctl</h3>
<p>系统指令：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L12">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_CTL     = <span class="number">233</span></span><br></pre></td></tr></table></figure>
<p>Go 中的声明：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L37">EpolloCtl</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCtl</span><span class="params">(epfd, op, fd <span class="type">int32</span>, event *EpollEvent)</span></span> (errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	_, _, e := Syscall6(SYS_EPOLL_CTL, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(op), <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(event)), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epfd</code>：epoll_create
函数返回的文件描述符，用于标识内核中的 epoll 实例</li>
<li><code>op</code>：对 fd 文件描述符的操作类型：
<ul>
<li><code>EPOLL_CTL_ADD</code>：向 interest list
添加一个需要监视的描述符</li>
<li><code>EPOLL_CTL_DEL</code>：向 interest list 删除一个描述符</li>
<li><code>EPOLL_CTL_MOD</code>：修改 interst list 中的一个描述符</li>
</ul></li>
<li><code>fd</code>：需要被操作的文件描述符</li>
<li><code>event</code>：一个指向名为 epoll_event
的结构的指针，它存储了我们实际要监视的 fd 的事件
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可以读。</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可以写。</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误。</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断。</li>
<li><code>EPOLLRDHUP</code>：表示对端关闭连接或半关闭写端。</li>
<li><code>EPOLLET</code>： 将 epoll 设为边缘触发（Edge
Triggered）模式，相对于水平触发（Level Triggered）来说的。</li>
</ul></li>
</ul>
<p>针对 Linux 的实现：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L49">runtime/netpoll_epoll.go</a></strong></p>
<ol type="1">
<li>传入一个 socket 的 fd，和 pollDesc 指针，pollDesc 是 Go 中对 socket
的抽象。pollDesc 中记录了 socket 的详细信息，以及哪个协程休眠在等待此
socket；</li>
<li>将 socket 的可读、可写、断开事件注册到 epoll 中；</li>
<li>将 epoll 设置为 ET 模式。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 fd 的四个事件 syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET 注册到 epfd 上</span></span><br><span class="line"><span class="comment">// 开始监控其 I/O 事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">	ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET</span><br><span class="line">	tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())</span><br><span class="line">	*(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp</span><br><span class="line">	<span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netpoll---epoll_wait">2.1.3 netpoll -&gt; epoll_wait</h3>
<p>系统指令：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L13">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_PWAIT   = <span class="number">281</span></span><br></pre></td></tr></table></figure>
<p>Go 中的声明：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L26">EpolloWait</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollWait</span><span class="params">(epfd <span class="type">int32</span>, events []EpollEvent, maxev, waitms <span class="type">int32</span>)</span></span> (n <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> ev unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(events) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ev = unsafe.Pointer(&amp;events[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ev = unsafe.Pointer(&amp;_zero)</span><br><span class="line">	&#125;</span><br><span class="line">	r1, _, e := Syscall6(SYS_EPOLL_PWAIT, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(ev), <span class="type">uintptr</span>(maxev), <span class="type">uintptr</span>(waitms), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epfd</code>：epoll_create
函数返回的文件描述符，用于标识内核中的 epoll 实例。</li>
<li><code>ev</code> 已经分配好的 epoll_event 结构体数组，epoll
会把发生的事件存入 events 中。</li>
<li><code>maxev</code>：告诉内核最多返回的事件数量有多大，必须大于
0。</li>
<li><code>waitms</code>：超时时间，<strong>-1</strong> 表示 epoll
将无限制等待下去。</li>
</ul>
<p>针对 Linux 的实现：<strong><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L99">runtime/netpoll_epoll.go</a></strong></p>
<ol type="1">
<li>根据 delay 确定要轮询多久；</li>
<li>创建一个长度为 128 的事件列表；</li>
<li>调用系统底层的 epollwait，查询有多少事件发生了；</li>
<li>新建一个协程列表；</li>
<li>遍历事件列表；</li>
<li>获取 go 中对 fd 的抽象结构体的值 pd；</li>
<li>将 pd 中的 g 取出来加入到 toRun 列表中；</li>
<li>返回可执行的 <font color="red">goroutine</font> 列表。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意返回的是一个可执行的 Goroutine 列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> (gList, <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. 计算超时时间</span></span><br><span class="line">	<span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">	<span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;  <span class="comment">// 无限等待，阻塞直到有事件</span></span><br><span class="line">		waitms = <span class="number">-1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;  <span class="comment">// 非阻塞，立即返回</span></span><br><span class="line">		waitms = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;</span><br><span class="line">		waitms = <span class="number">1</span> <span class="comment">// 小于 1 微秒的延迟，至少等待 1 毫秒，毫秒是最小粒度，0 会变成非阻塞</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;</span><br><span class="line">		waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)  <span class="comment">// 正常范围：转换纳秒到毫秒 (1ms = 1e6 ns)</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		waitms = <span class="number">1e9</span> <span class="comment">// 超大延迟，限制为约 11.5 天</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 准备接收最多 128 个就绪事件</span></span><br><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// 3. 调用 epoll_wait 等待事件</span></span><br><span class="line">	n, errno := syscall.EpollWait(epfd, events[:], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errno != _EINTR &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, errno)</span><br><span class="line">			throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 初始化返回值</span></span><br><span class="line">	<span class="keyword">var</span> toRun gList      <span class="comment">// 就绪的 goroutine 列表</span></span><br><span class="line">	delta := <span class="type">int32</span>(<span class="number">0</span>)    <span class="comment">// netpollWaiters 的调整值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.处理所有返回的事件</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := events[i]</span><br><span class="line">		<span class="keyword">if</span> ev.Events == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6. 判断是否是 eventfd 的唤醒信号，eventfd 用于从外部唤醒 epoll_wait</span></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) == &amp;netpollEventFd &#123;</span><br><span class="line">			<span class="comment">// eventfd 应该只产生 EPOLLIN 事件</span></span><br><span class="line">			<span class="keyword">if</span> ev.Events != syscall.EPOLLIN &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;runtime: netpoll: eventfd ready for&quot;</span>, ev.Events)</span><br><span class="line">				throw(<span class="string">&quot;runtime: netpoll: eventfd ready for something unexpected&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 消费唤醒信号</span></span><br><span class="line">			<span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> one <span class="type">uint64</span></span><br><span class="line">				read(<span class="type">int32</span>(netpollEventFd), noescape(unsafe.Pointer(&amp;one)), <span class="type">int32</span>(unsafe.Sizeof(one)))</span><br><span class="line">				<span class="comment">// 清除唤醒标志，允许下次 netpollBreak</span></span><br><span class="line">				netpollWakeSig.Store(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 跳过 eventfd，继续处理其他事件，eventfd 只是唤醒机制，不对应真实的网络 I/O</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7.根据触发的事件设置读写模式</span></span><br><span class="line">		<span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// [可读事件] 检查各种可读条件</span></span><br><span class="line">		<span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// EPOLLIN: 有数据可读</span></span><br><span class="line">			<span class="comment">// EPOLLRDHUP: 对端关闭写端（半关闭）</span></span><br><span class="line">			<span class="comment">// EPOLLHUP: 连接挂断</span></span><br><span class="line">			<span class="comment">// EPOLLERR: 发生错误</span></span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [可写事件] 检查各种可写条件</span></span><br><span class="line">		<span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// EPOLLOUT: 可以写入数据</span></span><br><span class="line">			<span class="comment">// EPOLLHUP: 连接挂断</span></span><br><span class="line">			<span class="comment">// EPOLLERR: 发生错误</span></span><br><span class="line">			mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 注意：mode 可能是 &#x27;r&#x27;(114), &#x27;w&#x27;(119), 或 &#x27;r&#x27;+&#x27;w&#x27;(233)</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 8. 获取 netpoller 对 socket 的抽象实例 pollDesc</span></span><br><span class="line">			tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))</span><br><span class="line">			pd := (*pollDesc)(tp.pointer())</span><br><span class="line">			tag := tp.tag() <span class="comment">// 提取序列号标签</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 9. 检查是否是过期事件</span></span><br><span class="line">			<span class="keyword">if</span> pd.fdseq.Load() == tag &#123;</span><br><span class="line">				<span class="comment">// 序列号匹配，这是有效的事件</span></span><br><span class="line">				<span class="comment">// 原因：防止 ABA 问题（fd 被关闭后重新打开复用）</span></span><br><span class="line">				pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 10. 将就绪的 goroutine 加入运行队列</span></span><br><span class="line">				delta += netpollready(&amp;toRun, pd, mode)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// else: 序列号不匹配，忽略过期事件，说明这个 pollDesc 已经被新的连接复用了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 11. 返回就绪的 goroutine 列表和等待计数调整值</span></span><br><span class="line">	<span class="keyword">return</span> toRun, delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>netpollready()</code> 表示 pd 底层的 fd 已经可以进行 I/O
操作了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(rg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="谁在调用-netpoll">2.1.4 谁在调用 netpoll()？</h3>
<h4 id="垃圾回收循环">2.1.4.1 垃圾回收循环</h4>
<p><code>runtime/proc.go</code> 中的 <a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/proc.go#L1768">startTheWorldWithSema()</a>
会调用 <code>netpoll()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(emitTraceEvent <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">		list := netpoll(<span class="number">0</span>)   <span class="comment">//调用 netpoll</span></span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runtime/mgc.go</code> 中的 <a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L744">gcStart()</a>
会调用 <code>startTheWorldWithSema()</code>，而 <code>gcStart()</code>
又会被我们的 g0 协程一直循环执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcStart starts the GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Concurrent mark.</span></span><br><span class="line">  systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now = startTheWorldWithSema(trace.enabled)	<span class="comment">// 调用 startTheWorldWithSema</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且 <code>g0</code> 协程在循环 gc 的时候，顺带执行了
<code>netpoll()</code> 来检查是否有事件发生。</p>
<h4 id="协程调度">2.1.4.2 协程调度</h4>
<p>在 <a href="https://hedon.top/2024/01/20/go/go-gpm/">深入浅出 Go
语言的 GPM 模型（Go1.21）</a> 中，我们提到了 Go 协程调度最核心的函数
<code>schedule()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">	gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程调度的时候会去执行 <code>findRunnable()</code> 寻找可以运行的
Goroutine，这里面也会调用 <code>netpoll()</code>
检查是否有网络事件发生。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">	<span class="comment">// Poll network until next timer.</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; (netpollAnyWaiters() || pollUntil != <span class="number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//..</span></span><br><span class="line">		list, delta := netpoll(delay) <span class="comment">// block until new work is available</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="network-poll-对-socket-的抽象-polldesc">2.2 network poll 对
socket 的抽象 —— pollDesc</h2>
<p>Go 的 netpoller 需要进一步对 socket 进行抽象，是为了解决 2
个核心问题：</p>
<ol type="1">
<li><strong>状态同步问题</strong>：如何让 Go
调度器（用户态）和操作系统内核（内核态）共享同一个 socket
的状态（是读还是写？是谁在等？）。</li>
<li><strong>生命周期错位问题</strong>：操作系统内核的通知是异步的，可能在
Go
已经关闭或复用了文件描述符（FD）之后，内核才发来一个旧的就绪通知。这会导致严重的内存腐坏或逻辑错误。</li>
</ol>
<p>为此，Go 定义了两个数据结构：<code>pollDesc</code> 和
<code>pollCache</code>。我们将 <code>pollDesc</code>
看作<strong>"桥梁"</strong>，将 <code>pollCache</code>
看作<strong>"安全区"</strong>。</p>
<h3 id="polldesc">2.2.1 pollDesc</h3>
<p><a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll.go#L75">pollDesc</a>
是 Go
运行时为每个网络文件描述符（socket）创建的轮询描述符对象，用于管理该 fd
的异步 I/O 状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network poller descriptor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// No heap pointers.</span></span><br><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	_     sys.NotInHeap</span><br><span class="line">	link  *pollDesc      <span class="comment">// in pollcache, protected by pollcache.lock</span></span><br><span class="line">	fd    <span class="type">uintptr</span>        <span class="comment">// constant for pollDesc usage lifetime</span></span><br><span class="line">	fdseq atomic.Uintptr <span class="comment">// protects against stale pollDesc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// atomicInfo holds bits from closing, rd, and wd,</span></span><br><span class="line">	<span class="comment">// which are only ever written while holding the lock,</span></span><br><span class="line">	<span class="comment">// summarized for use by netpollcheckerr,</span></span><br><span class="line">	<span class="comment">// which cannot acquire the lock.</span></span><br><span class="line">	<span class="comment">// After writing these fields under lock in a way that</span></span><br><span class="line">	<span class="comment">// might change the summary, code must call publishInfo</span></span><br><span class="line">	<span class="comment">// before releasing the lock.</span></span><br><span class="line">	<span class="comment">// Code that changes fields and then calls netpollunblock</span></span><br><span class="line">	<span class="comment">// (while still holding the lock) must call publishInfo</span></span><br><span class="line">	<span class="comment">// before calling netpollunblock, because publishInfo is what</span></span><br><span class="line">	<span class="comment">// stops netpollblock from blocking anew</span></span><br><span class="line">	<span class="comment">// (by changing the result of netpollcheckerr).</span></span><br><span class="line">	<span class="comment">// atomicInfo also holds the eventErr bit,</span></span><br><span class="line">	<span class="comment">// recording whether a poll event on the fd got an error;</span></span><br><span class="line">	<span class="comment">// atomicInfo is the only source of truth for that bit.</span></span><br><span class="line">	atomicInfo atomic.Uint32 <span class="comment">// atomic pollInfo</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// rg, wg are accessed atomically and hold g pointers.</span></span><br><span class="line">	<span class="comment">// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)</span></span><br><span class="line">	rg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for read or pdNil</span></span><br><span class="line">	wg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for write or pdNil</span></span><br><span class="line"></span><br><span class="line">	lock    mutex <span class="comment">// protects the following fields</span></span><br><span class="line">	closing <span class="type">bool</span></span><br><span class="line">	rrun    <span class="type">bool</span>      <span class="comment">// whether rt is running</span></span><br><span class="line">	wrun    <span class="type">bool</span>      <span class="comment">// whether wt is running</span></span><br><span class="line">	user    <span class="type">uint32</span>    <span class="comment">// user settable cookie</span></span><br><span class="line">	rseq    <span class="type">uintptr</span>   <span class="comment">// protects from stale read timers</span></span><br><span class="line">	rt      timer     <span class="comment">// read deadline timer</span></span><br><span class="line">	rd      <span class="type">int64</span>     <span class="comment">// read deadline (a nanotime in the future, -1 when expired)</span></span><br><span class="line">	wseq    <span class="type">uintptr</span>   <span class="comment">// protects from stale write timers</span></span><br><span class="line">	wt      timer     <span class="comment">// write deadline timer</span></span><br><span class="line">	wd      <span class="type">int64</span>     <span class="comment">// write deadline (a nanotime in the future, -1 when expired)</span></span><br><span class="line">	self    *pollDesc <span class="comment">// storage for indirect interface. See (*pollDesc).makeArg.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心字段解析：</p>
<ol type="1">
<li><p><strong><code>fd</code></strong>：这是最原始的操作系统文件描述符（例如
Linux 上的 <code>int</code> 类型的 5, 6 等）。它是连接到
<code>epoll</code> / <code>kqueue</code> 的物理句柄。</p></li>
<li><p><strong><code>rg</code> (Read Group) / <code>wg</code> (Write
Group)</strong>：<strong>这是最重要的字段。</strong>
它们实现了无锁（Lock-free）的状态流转。它们不仅仅存储 Goroutine
的指针（<code>*g</code>），还是一个多状态的原子变量：</p>
<ul>
<li><code>0 (pdNil)</code>: 没有任何 Goroutine 在等待。</li>
<li><code>1 (pdReady)</code>: I/O
已经就绪（网卡有数据了），不需要等待，直接读。</li>
<li><code>2 (pdWait)</code>: 正在准备挂起，作为中间状态。</li>
<li><code>&gt; 2 (G Pointer)</code>: <strong>存储了正在阻塞等待的
Goroutine 的内存地址。</strong></li>
</ul>
<p>当 <code>epoll_wait</code> 返回就绪事件时，Netpoller 会通过
<code>rg</code> 或 <code>wg</code> 里的地址找到那个 G，然后调用
<code>goready(G)</code> 唤醒它。</p></li>
<li><p>超时管理（<strong><code>rt</code></strong>、<strong><code>wt</code></strong>、<strong><code>rd</code></strong>、<strong><code>wd</code></strong>）：管理读写操作的
deadline。Go 的 <code>SetReadDeadline</code> 和
<code>SetWriteDeadline</code>
就是在这里实现的。每个网络连接自带两个定时器。如果超时触发，定时器回调会强制将
<code>rg</code> 或 <code>wg</code> 状态置为错误，并唤醒 G。G
醒来后发现是超时导致的唤醒，于是返回
<code>timeout error</code>。</p></li>
<li><p>防止过时通知（<strong><code>fdseq</code></strong>、<strong><code>rseq</code></strong>、<strong><code>wseq</code></strong>）：通过序列号防止在
<code>fd</code> 复用后收到旧的就绪通知。</p></li>
<li><p><strong><code>link</code></strong>：指向下一个空闲的
<code>pollDesc</code>，后面会详细分析。</p></li>
</ol>
<h3 id="pollcache">2.2.1 pollCache</h3>
<p>网络程序中会频繁地打开和关闭连接，每个连接都需要一个
<code>pollDesc</code>。如果每次都分配新对象并最终让 GC
回收，会带来巨大的性能开销。<a
target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll.go#L192">pollCache</a>
通过对象池模式复用
<code>pollDesc</code>，大幅提升性能。用一句话概述就是：<code>pollCache</code>
是一个专门用于分配 <code>pollDesc</code> 的链表式缓存池。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex					<span class="comment">// 锁</span></span><br><span class="line">	first *pollDesc			<span class="comment">// 指向 pollDesc 链表的第一个节点，即下一个可用的空闲节点（头插法）</span></span><br><span class="line">	<span class="comment">// PollDesc objects must be type-stable,</span></span><br><span class="line">	<span class="comment">// because we can get ready notification from epoll/kqueue</span></span><br><span class="line">	<span class="comment">// after the descriptor is closed/reused.</span></span><br><span class="line">	<span class="comment">// Stale notifications are detected using seq variable,</span></span><br><span class="line">	<span class="comment">// seq is incremented when deadlines are changed or descriptor is reused.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信不少读者都会注意到注释中的这句话：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PollDesc objects must be type-stable,</span></span><br></pre></td></tr></table></figure>
<p>为什么呢？想象下面这样一个流程：</p>
<ol type="1">
<li>你打开了一个 Socket，FD 为 10。</li>
<li>Go 将 FD 10 注册给
<code>epoll</code>，由于内核并没有给我们回调函数，<code>epoll</code>
内部通常存储的是 <code>pollDesc</code> 的<strong>内存地址</strong>作为
<code>user_data</code>。</li>
<li>你关闭了连接。Go 回收了 FD 10，也释放了 <code>pollDesc</code>
的内存。</li>
<li><strong>危险时刻</strong>：假设这块内存立刻被 Go 的 GC 分配给了一个
<code>string</code> 或者是其他对象。</li>
<li><strong>延迟通知</strong>：此时，内核里积压的一个关于 FD 10
的"可读"事件突然触发了（或者是一个极端的竞态条件）。<code>epoll</code>
返回了那个旧的 <code>pollDesc</code> 内存地址，告诉 Runtime
这里"可读"。</li>
<li><strong>崩溃</strong>：Runtime 以为这还是个
<code>pollDesc</code>，试图去修改它的 <code>rg</code>
字段。但这块内存现在存的是一个字符串！<strong>结果：内存腐坏（Memory
Corruption），程序直接崩溃且极难调试。</strong></li>
</ol>
<p><strong>解决方案：Type-Stable Memory（类型稳定内存）</strong></p>
<p><code>pollCache</code>
保证了通过它分配出去的内存块，<strong>即使被释放回收了，也永远只能作为
<code>pollDesc</code> 存在，绝不会被 GC 挪作他用。</strong></p>
<ul>
<li><code>sys.NotInHeap</code>: 标记这个结构体不在普通的 GC
堆上管理，而是手动管理的（<code>pollDesc</code> 的第一个字段）。</li>
<li><strong>链表管理</strong>:
<ul>
<li><code>lock</code>: 保护链表。</li>
<li><code>first</code>: 指向链表头部的空闲 <code>pollDesc</code>。</li>
<li><strong>分配</strong>: 从 <code>first</code> 取一个。如果链表空，向
OS 申请一大块内存（4KB），切分成多个 <code>pollDesc</code>
串到链表上。</li>
<li><strong>释放</strong>: 并不是真的 <code>free</code>
掉内存，而是把它放回 <code>first</code>
链表头，留给下一个连接复用。</li>
</ul></li>
</ul>
<p>这就保证了：即使内核发来一个过期的通知，Runtime
访问的那个内存地址依然是一个合法的 <code>pollDesc</code>
结构体（虽然它可能不再关联任何活跃连接），最多就是读到一个无效状态，而不会导致内存越界或类型错误。</p>
<h4 id="分配-alloc">2.2.1.1 分配 alloc</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 1. 未初始化，则先进行初始化，一次性分配 n 个 pollDesc</span></span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">type</span> pollDescPadded <span class="keyword">struct</span> &#123;</span><br><span class="line">			pollDesc</span><br><span class="line">			pad [tagAlign - unsafe.Sizeof(pollDesc&#123;&#125;)]<span class="type">byte</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDescPadded&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Must be in non-GC memory because can be referenced</span></span><br><span class="line">		<span class="comment">// only from epoll/kqueue internals.</span></span><br><span class="line">		mem := persistentalloc(n*pdSize, tagAlign, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">			pd.rt.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">			pd.wt.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">			pd.link = c.first</span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 2. 取出链表头部的空闲节点</span></span><br><span class="line">	pd := c.first</span><br><span class="line">  <span class="comment">// 3. 移动到下一个空闲节点</span></span><br><span class="line">	c.first = pd.link</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回收-free">2.2.1.2 回收 free</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> free(pd *pollDesc) &#123;</span><br><span class="line">	<span class="comment">// pd can&#x27;t be shared here, but lock anyhow because</span></span><br><span class="line">	<span class="comment">// that&#x27;s what publishInfo documents.</span></span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 自增 fdseq，避免处理过期事件造成生命周期错位问题</span></span><br><span class="line">	fdseq := pd.fdseq.Load()</span><br><span class="line">	fdseq = (fdseq + <span class="number">1</span>) &amp; (<span class="number">1</span>&lt;&lt;tagBits - <span class="number">1</span>)</span><br><span class="line">	pd.fdseq.Store(fdseq)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 重置 pollDesc</span></span><br><span class="line">	pd.publishInfo()</span><br><span class="line"></span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 放回链表头部</span></span><br><span class="line">	pd.link = c.first</span><br><span class="line">	c.first = pd</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便内存类型安全了，我们还面临逻辑上的 <strong>ABA
问题</strong>：</p>
<ol type="1">
<li>Goroutine A 使用 FD 10 (<code>pollDesc</code> 地址 0x123)。</li>
<li>A 关闭连接，释放 FD 10，释放 <code>pollDesc</code> (0x123
返回缓存池)。</li>
<li>Goroutine B 建立新连接，刚好系统又分配了 FD 10，且
<code>pollCache</code> 又把 0x123 分配给了 B。</li>
<li><strong>此时，内核发来了 A 时代的 FD 10 的就绪事件。</strong></li>
<li>Runtime 拿着 0x123，以为是 B 的数据来了，错误地唤醒了
B（或者处理了错误的数据）。</li>
</ol>
<p><strong><code>fdseq</code> 的作用：</strong> 每次
<code>pollDesc</code> 被复用（从缓存池拿出来）时，<code>fdseq</code>
都会自增。</p>
<ul>
<li>当注册 <code>epoll</code> 时，Go 会把当前的 <code>fdseq</code>
记录在某个地方（或者在检查时比对）。</li>
<li>当事件回来时，Runtime
会检查：<code>Event.seq == pollDesc.seq?</code></li>
<li>如果不相等，说明是个过期事件，直接忽略，不进行唤醒操作。</li>
</ul>
<h3 id="总结">2.2.3 总结</h3>
<ol type="1">
<li><strong><code>pollDesc</code> (State)</strong>: 使用
<code>atomic.Uintptr</code> 存储 Goroutine 指针，实现了<strong>用户态 G
与内核态 I/O 事件的高效无锁传递</strong>。</li>
<li><strong><code>pollCache</code> (Memory)</strong>:
使用<strong>类型稳定内存（Type-Stable
Memory）</strong>，从物理内存布局的层面消灭了异步 I/O
可能导致的内存腐坏风险。</li>
<li><strong><code>fdseq</code> (Logic)</strong>:
使用<strong>版本号机制</strong>，解决了资源复用带来的逻辑混淆（ABA
问题）。</li>
</ol>
<p>这就是为什么 Go
的网络库在高并发、高动态（大量连接建立和断开）场景下，依然稳如磐石的底层原因。</p>
<h2 id="network-poller-工作细节">2.3 network poller 工作细节</h2>
<h3 id="初始化-poll_runtime_pollserverinit">2.3.1 初始化
poll_runtime_pollServerInit</h3>
<p>通过原子操作 &amp; 双重检查来执行一次
<code>netpollinit()</code>，创建一个 epoll。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 类似于 双重检查 的单例模式</span></span><br><span class="line">  <span class="comment">// 保证只执行一次 netpollinit()</span></span><br><span class="line">	<span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">		lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">		lockInit(&amp;pollcache.lock, lockRankPollCache)</span><br><span class="line">		lock(&amp;netpollInitLock)</span><br><span class="line">		<span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">			netpollinit() <span class="comment">// epoll_create() 创建一个多路复用器</span></span><br><span class="line">			netpollInited.Store(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;netpollInitLock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin colorful note" color="green"><div class="title"><strong><p>补充：go:linkname</p>
</strong></div><div class="body"><p>补充：go:linkname</p><blockquote><p>The //go:linkname directive instructs the compiler to use“importpath.name” as the object file symbol name for the variable orfunction declared as “localname” in the source code. Because thisdirective can subvert the type system and package modularity, it is onlyenabled in files that have imported “unsafe”.</p></blockquote><p><code>//go:linkname</code>的目的是告诉编译器使用<code>importpath.name</code>来对本来不可导出的（localname）函数或者变量实现导出功能。由于这种方法是破坏了Go语言的模块化规则的，所以必须在导入了<code>"unsafe"</code>包的情况下使用。</p><p>即：</p><blockquote><p>由于 Go语法规则限制，小写字母开头的函数或者变量是本模块私有的，不可被包外的代码访问；但是如果必须要能被外部模块访问到，又要限制为私有方法呢？只能在编译器上做手脚，通过一个特殊的<strong>标记</strong> 来实现这种功能。</p></blockquote><p>具体到上面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br></pre></td></tr></table></figure><ul><li>表示调用 <code>internal/poll.runtime_pollServerInit</code>相当于调用当前的 <code>poll_runtime_pollServerInit</code>。</li></ul></div></div>
<h3 id="新增监听-poll_runtime_pollopen">2.3.2 新增监听
poll_runtime_pollOpen</h3>
<ol type="1">
<li>在 pollcache 链表中分配一个 pollDesc，用来描述要新增将它的
socket；</li>
<li>初始化 pollDesc，主要是将 rg、wg 置为 0；</li>
<li>调用 netpollopen，将底层 socket 及其读、写和断开事件注册到 epoll
上；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 分配一个 pollDesc，用来描述要新增监听的 socket</span></span><br><span class="line">	pd := pollcache.alloc()</span><br><span class="line">  <span class="comment">// 2. 上锁</span></span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line">	wg := pd.wg.Load()</span><br><span class="line">	<span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	rg := pd.rg.Load()</span><br><span class="line">	<span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 3. 赋值</span></span><br><span class="line">	pd.fd = fd</span><br><span class="line">	<span class="keyword">if</span> pd.fdseq.Load() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The value 0 is special in setEventErr, so don&#x27;t use it.</span></span><br><span class="line">		pd.fdseq.Store(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pd.closing = <span class="literal">false</span></span><br><span class="line">	pd.setEventErr(<span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	pd.rseq++</span><br><span class="line">	pd.rg.Store(pdNil)	<span class="comment">// 初始值，还没感兴趣的 Goroutine</span></span><br><span class="line">	pd.rd = <span class="number">0</span></span><br><span class="line">	pd.wseq++</span><br><span class="line">	pd.wg.Store(pdNil)	<span class="comment">// 初始化，还没感兴趣的 Goroutine</span></span><br><span class="line">	pd.wd = <span class="number">0</span></span><br><span class="line">	pd.self = pd</span><br><span class="line">	pd.publishInfo()</span><br><span class="line">  <span class="comment">// 4. 解锁</span></span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 调用 netpollopen  -&gt; epoll_ctl</span></span><br><span class="line">  <span class="comment">// 将 pd 关联的 fd 的相关事件注册到 epoll 上</span></span><br><span class="line">	errno := netpollopen(fd, pd)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		pollcache.free(pd)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否就绪-poll_runtime_pollwait">2.3.3 判断是否就绪
poll_runtime_pollWait</h3>
<ol type="1">
<li>协程要对 socket 进行 read 或者 write 的时候，底层就会调用
poll_runtime_pollWait；</li>
<li>该方法循环调用 netpollblock()，直到 netpollblock() 返回 true，表明
rg 或 wg 已经置为 pdReady 了，可以进行读或者写了。</li>
<li>netpollblock()：
<ol type="1">
<li>根据 mode，取出 rg 或者 wg，命名为 gpp；</li>
<li>如果 gpp 是 pdReady，直接返回 true，否则，置为 pdWait，返回
false。</li>
</ol></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;waiting for unsupported file type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">	<span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_pollWait</span><span class="params">(ctx <span class="type">uintptr</span>, mode <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 循环调用 netpollblock，直到 netpollblock 返回 true</span></span><br><span class="line">   <span class="comment">// 也就是 rg 或 wg 已经置为 pdReady 了，可以读 / 写了</span></span><br><span class="line">   <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns true if IO is ready, or false if timed out or closed</span></span><br><span class="line"><span class="comment">// waitio - wait only for completed IO, ignore errors</span></span><br><span class="line"><span class="comment">// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc</span></span><br><span class="line"><span class="comment">// can hold only a single waiting goroutine for each mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 根据 mode，看看是要读还是要写</span></span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 已经 pdReady 了，返回 true，完成</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(pdReady, pdNil) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 没有 pdReady，则先置为 pdWait，再往下走</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(pdNil, pdWait) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 调用 gopark 阻塞当前 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 当 gopark 返回时，表示被唤醒，重置为 pdNil</span></span><br><span class="line">	old := gpp.Swap(pdNil)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 如果是 pdReady，则返回 true，否则可能是超时等原因，返回 false</span></span><br><span class="line">	<span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">	<span class="keyword">if</span> r &#123;</span><br><span class="line">		<span class="comment">// Bump the count of goroutines waiting for the poller.</span></span><br><span class="line">		<span class="comment">// The scheduler uses this to decide whether to block</span></span><br><span class="line">		<span class="comment">// waiting for the poller if there is nothing else to do.</span></span><br><span class="line">		netpollAdjustWaiters(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调度协程去读写-socket">2.3.4 调度协程去读写 socket</h3>
<ul>
<li><p>socket 已经可以读写：</p>
<ol type="1">
<li><p><font color="red">runtime</font> 循环调用 netpoll() 方法；</p>
<blockquote>
<p>前面分析过了，是 g0 协程在 gc 的时候顺便调用了 netpoll。</p>
</blockquote></li>
<li><p>发现 socket 可读写时，给对应的 rg 或 wg 置为
pdReady(1)；</p></li>
<li><p><font color="red">协程</font>调用 poll_runtime_pollWait() 判断
socket 是否就绪；判断 rg 或者 wg 已经置为
<strong>pdReady(1)</strong>，那就返回 0；</p></li>
<li><p>runtime 就知道 socket 可以操作了。</p></li>
</ol></li>
<li><p>socket 暂时不可读写：</p>
<ol type="1">
<li><font color="red">runtime</font> 循环调用 netpoll() 方法；</li>
<li>netpoll 中没有监听到任何事件，执行不到 netpollready，没有对 pd
做任何改变；</li>
<li><font color="red">协程</font>调用 poll_runtime_pollWait() 判断
socket 是否就绪：
<ol type="1">
<li>判断 rg 或 wg 还是 <strong>pdNil(0)</strong>，就将 rg 或者 wg 置为
<strong>pdWait(2)</strong>；</li>
<li>调用 gopark 将协程进行休眠等待；</li>
<li>然后再进入 netpollblockcommit 将 rg 或者 wg 置为 <strong>G
pointer</strong>；</li>
</ol></li>
<li>假如 runtime 后面再循环调用 netpoll() 方法；</li>
<li>发现 socket 可读写时，进入 netpollready 再检查对应的 rg 或者
wg；</li>
<li>netpollready 再进入 netpollunblock，它会检查 rg 或者 wg；</li>
<li>若为 <strong>G pointer</strong>，那么就将 rg 或者 wg 置为
<strong>pdReady</strong>，然后返回协程地址给 runtime；</li>
<li>runtime 就会去调度对应协程进行 socket 的读写操作。</li>
</ol></li>
<li><p>读写后都会再将 rg 或者 wg 置为 <strong>nil</strong></p></li>
</ul>
<h3 id="总结-1">2.3.5 总结</h3>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5laualr25j21im0u079y.jpg" /></p>
<p>Go 的网络操作底层为 <strong>阻塞模型（协程调度） +
多路复用（系统底层）</strong>，具体情况为：</p>
<ul>
<li>BIO：go
协程从网络读取数据，读取失败并且返回<code>syscall.EAGAIN</code>
时，依次调用
<code>waitRead-&gt;runtime_pollWait-&gt;poll_runtime_pollWait-&gt;netpollblock-&gt;gopark</code>
将当前协程挂起。</li>
<li>NIO：runtime 的 g0 协程在 gc 的时候会顺便调用 <code>netpoll()</code>
检查 socket 事件是否发生，当 socket
可操作的时候，重新唤醒对应协程，进行调度。</li>
</ul>
<p>具体细节为：</p>
<ul>
<li>runtime
<ol type="1">
<li>runtime 会一直循环去检查 socket 的可读写状态 ——
<code>netpoll()</code></li>
<li>然后再看是否有协程在等待对应的 socket：——
<code>netpollready()</code>
<ol type="1">
<li>没有，那就单纯记录 pollDesc；</li>
<li>有那就唤醒协程，将 g 加入 toRun 列表，进行调度 ——
<code>netpollunblock()</code></li>
</ol></li>
</ol></li>
<li>goroutine
<ol type="1">
<li>表明想要操作 socket ——
<code>poll_runtime_pollWait(pd,mode)</code></li>
<li>循环检查自己关心的 socket 是否可操作 —— <code>netpollblock()</code>
<ol type="1">
<li>可以操作，goroutine 就会对 socket 进行读或写操作了；</li>
<li>不可操作：
<ol type="1">
<li>就将自己休眠 —— <code>gopark()</code>；</li>
<li>将 rg 或 wg 置为自己的地址 —— <code>netpollblockcommit()</code></li>
</ol></li>
</ol></li>
</ol></li>
</ul>
<h2 id="net-包">2.4 net 包</h2>
<ul>
<li><p>net 包是 go 原生的网络包；</p></li>
<li><p>net 包实现了 TCP、UDP、HTTP 等网络操作；</p></li>
<li><p>使用 <code>net.Listen()</code> 可以得到 <code>LISTEN</code>
状态的 socket —— listener；</p></li>
<li><p>使用 <code>listener.Accept()</code> 可以得到
<code>ESTABLISHED</code> 状态的 socket —— conn；</p></li>
<li><p><code>conn.Read() / Writer()</code> 可以进行读写 socket
的操作；</p></li>
<li><p>network poll 作为上述功能的底层支撑；</p>
<blockquote>
<p>本文仅介绍 TCP 相关的部分。</p>
</blockquote></li>
</ul>
<h3 id="net.netfd">2.4.1 net.netFD</h3>
<p><code>netFD</code> 是 Go 中 net 包对 socket
之类的网络文件描述符的抽象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">	pfd poll.FD</span><br><span class="line"></span><br><span class="line">	<span class="comment">// immutable until Close</span></span><br><span class="line">	family      <span class="type">int</span></span><br><span class="line">	sotype      <span class="type">int</span></span><br><span class="line">	isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">	net         <span class="type">string</span></span><br><span class="line">	laddr       Addr</span><br><span class="line">	raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5ldvdxiy6j21h80i6759.jpg" /></p>
<h3 id="net.listen-listenter">2.4.2 net.Listen() Listenter</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="type">string</span>)</span></span> (Listener, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> lc ListenConfig</span><br><span class="line">	<span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>新建 socket，并执行 bind 操作；</li>
<li>新建一个 netFD，它是 net 包对 socket 的详情描述；</li>
<li>返回一个 TCPListener 对象，底层是调用了 runtime_pollOpen 方法，将
TCPListener 的 FD 信息加入监听。TCPListener 对象本质是一个
<strong>LISTEN</strong> 状态的 socket。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5leaayjlcj20u010zn0e.jpg" style="zoom:50%;" /></p>
<h3 id="listener.accept">2.4.3 listener.Accept()</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept implements the Accept method in the [Listener] interface; it</span></span><br><span class="line"><span class="comment">// waits for the next call and returns a generic [Conn].</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> !l.ok() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, syscall.EINVAL</span><br><span class="line">	&#125;</span><br><span class="line">	c, err := l.accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;accept&quot;</span>, Net: l.fd.net, Source: <span class="literal">nil</span>, Addr: l.fd.laddr, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>调用 tcpListener 的 accept，本质上就是调用处于 LISTEN 状态的 socket
的 accept 方法，看看有无新的连接；</li>
<li>如果失败，休眠等待新的连接，底层调用了 runtime_pollWait；</li>
<li>如果有新的连接，那就包装成一个新的 socket，最后返回为一个 TCPConn
变量，底层是调用了 runtime_pollOpen 方法，将 TCPConn 的 FD
信息加入监听。TCPConn 对象本质是一个 <strong>ESTABLISHED</strong> 状态的
socket。</li>
</ol>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lf3th4jjj21cz0u0gpf.jpg" /></p>
<h3 id="conn.read-conn.write">2.4.4 conn.Read() / conn.Write()</h3>
<p>这两个方法原理差不多，下面以 Read() 为例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements the Conn Read method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   n, err := c.fd.Read(b)</span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 循环读数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">   	<span class="comment">// 1. 调用系统命令 syscall.Read，读取 sysfd 上的数据，然后往 p 写数据</span></span><br><span class="line">		n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 2. syscall.EAGAIN 说明还没数据，得先等等</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">        <span class="comment">// 3. 挂起，休眠等待</span></span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="comment">// 4. 当有数据来的时候，会被唤醒走到这里，然后在回到 for 循环读取数据</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>底层直接调用 socket
原生读写方法（syscall.Read、syscall.Write）；</li>
<li>成功则直接返回；</li>
<li>如果失败，休眠等待可读 / 可写事件的发生；</li>
<li>被唤醒后重新调用系统 socket 进行读写；</li>
</ol>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lfqryruej21ir0u0n3b.jpg" /></p>
<h3 id="net.dialtcp">2.4.5 net.DialTCP()</h3>
<p><code>Dial()</code> 方法支持 TCP、UDP、IP、unix、unixgram 和
unixpacket 网络通讯方式，它是一个统共的方法，通过传入
<code>network</code>
字段来区分不同的网络类型，所以它前面很多的操作，都是在判断当前是什么网络类型。本文主要讲
TCP 的实现底层，故直接进入 <code>DialTCP()</code>
即可，其他的网络类型，也是大同小异的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTCP</span><span class="params">(network <span class="type">string</span>, laddr, raddr *TCPAddr)</span></span> (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 看看具体是哪种 tcp 连接</span></span><br><span class="line">	<span class="keyword">switch</span> network &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;tcp6&quot;</span>:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(network)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raddr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: <span class="literal">nil</span>, Err: errMissingAddress&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建一个系统的网络连接工具</span></span><br><span class="line">	sd := &amp;sysDialer&#123;network: network, address: raddr.String()&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		c   *TCPConn</span><br><span class="line">		err <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行 TCP 连接</span></span><br><span class="line">	<span class="keyword">if</span> sd.MultipathTCP() &#123;</span><br><span class="line">		c, err = sd.dialMPTCP(context.Background(), laddr, raddr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c, err = sd.dialTCP(context.Background(), laddr, raddr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> dialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> h := sd.testHookDialTCP; h != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h(ctx, sd.network, laddr, raddr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h := testHookDialTCP; h != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h(ctx, sd.network, laddr, raddr)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 4. 进入 doDialTCP</span></span><br><span class="line">	<span class="keyword">return</span> sd.doDialTCP(ctx, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> sd.doDialTCPProto(ctx, laddr, raddr, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> doDialTCPProto(ctx context.Context, laddr, raddr *TCPAddr, proto <span class="type">int</span>) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">	ctrlCtxFn := sd.Dialer.ControlContext</span><br><span class="line">	<span class="keyword">if</span> ctrlCtxFn == <span class="literal">nil</span> &amp;&amp; sd.Dialer.Control != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctrlCtxFn = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>, c syscall.RawConn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> sd.Dialer.Control(network, address, c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// 5. 有了前面的基础，到这就明白了</span></span><br><span class="line"> 	<span class="comment">// internetSocket 创建一个 fd，生成一个新的 socket，并注册到 epoll 中监听</span></span><br><span class="line">	fd, err := internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, proto, <span class="string">&quot;dial&quot;</span>, ctrlCtxFn)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			fd.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		fd, err = internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, proto, <span class="string">&quot;dial&quot;</span>, ctrlCtxFn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 6. 返回一个 TCPConn</span></span><br><span class="line">	<span class="keyword">return</span> newTCPConn(fd, sd.Dialer.KeepAlive, sd.Dialer.KeepAliveConfig, testPreHookSetKeepAlive, testHookSetKeepAlive), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>创建一个系统的网络连接工具 sysDialer；</li>
<li>dial 进行 TCP 连接，连接不上那就是 connect refused；</li>
<li>连接上的话，创建一个新的 socket，并最后返回为一个 TCPConn
变量，底层是调用了 runtime_pollOpen 方法，将 TCPConn 的 FD
信息加入监听。TCPConn 对象本质是一个 <strong>ESTABLISHED</strong> 状态的
socket。</li>
</ol>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lgqvxxivj21nd0u0q67.jpg" /></p>
<h1 id="总结-2">3. 总结</h1>
<p><img
src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lh6uxgk3j21770u0773.jpg" /></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享
4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://hedon.top/2025/11/23/go/go-net/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://hedon.top/2025/11/23/go/go-net/&title=Go 底层原理丨网络编程 - HedonWang&summary=本文立足于 Go 1.25 版本源码，系统拆解 Go 网络编程模型的底层机制，解析 Goroutine 如何实现同步代码，异步执行、net 包的核心实现，以及 I/O 多路复用背后的第一性原理，带你从源码视角理解 Go 网络高并发的秘密。"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=Go 底层原理丨网络编程 - HedonWang&amp;body=https://hedon.top/2025/11/23/go/go-net/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://hedon.top/2025/11/23/go/go-net/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/11/23/linux-io-epoll/">从第一性原理理解 epoll</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/11/22/go/go-channel/">Go 底层原理丨channel</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="hedon954/hedonspace" data-repo-id="R_kgDOKt17sQ" data-category="Q&A" data-category-id="DIC_kwDOKt17sc4CbAt-" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Hedon Wang</a> 使用 <a
target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar
1.29.1</a> 主题创建。 本博客所有文章除特别声明外，均采用 <a
target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA
4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 宏观概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%B1%82%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BC%82%E6%AD%A5%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text">2.1 第一层：编程模型 ——
同步的代码，异步的执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%B1%82%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%B1%82-%E9%9D%9E%E9%98%BB%E5%A1%9E-io-%E7%9A%84%E4%BC%AA%E8%A3%85"><span class="toc-text">2.2 第二层：系统调用层 ——
非阻塞 I&#x2F;O 的伪装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%B1%82runtime-%E6%A0%B8%E5%BF%83-netpoller-%E4%B8%8E-gmp-%E7%9A%84%E8%81%94%E5%8A%A8"><span class="toc-text">2.3 第三层：Runtime
核心 —— Netpoller 与 GMP 的联动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%8A%82"><span class="toc-text">2.4 小节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">2. 源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">2.1 Go 的系统调用的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E5%AF%B9-epoll-%E7%9A%84%E6%8A%BD%E8%B1%A1---network-poller"><span class="toc-text">2.2 Go 对 Epoll 的抽象 -
network poller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netpollinit---epoll_create"><span class="toc-text">2.1.1 netpollinit -&gt;
epoll_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netpollopen---epoll_ctl"><span class="toc-text">2.1.2 netpollopen -&gt; epoll_ctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netpoll---epoll_wait"><span class="toc-text">2.1.3 netpoll -&gt; epoll_wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E5%9C%A8%E8%B0%83%E7%94%A8-netpoll"><span class="toc-text">2.1.4 谁在调用 netpoll()？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">2.1.4.1 垃圾回收循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">2.1.4.2 协程调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#network-poll-%E5%AF%B9-socket-%E7%9A%84%E6%8A%BD%E8%B1%A1-polldesc"><span class="toc-text">2.2 network poll 对
socket 的抽象 —— pollDesc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#polldesc"><span class="toc-text">2.2.1 pollDesc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pollcache"><span class="toc-text">2.2.1 pollCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D-alloc"><span class="toc-text">2.2.1.1 分配 alloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6-free"><span class="toc-text">2.2.1.2 回收 free</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">2.2.3 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#network-poller-%E5%B7%A5%E4%BD%9C%E7%BB%86%E8%8A%82"><span class="toc-text">2.3 network poller 工作细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-poll_runtime_pollserverinit"><span class="toc-text">2.3.1 初始化
poll_runtime_pollServerInit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9B%91%E5%90%AC-poll_runtime_pollopen"><span class="toc-text">2.3.2 新增监听
poll_runtime_pollOpen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%B0%B1%E7%BB%AA-poll_runtime_pollwait"><span class="toc-text">2.3.3 判断是否就绪
poll_runtime_pollWait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%8D%8F%E7%A8%8B%E5%8E%BB%E8%AF%BB%E5%86%99-socket"><span class="toc-text">2.3.4 调度协程去读写 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">2.3.5 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#net-%E5%8C%85"><span class="toc-text">2.4 net 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net.netfd"><span class="toc-text">2.4.1 net.netFD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net.listen-listenter"><span class="toc-text">2.4.2 net.Listen() Listenter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listener.accept"><span class="toc-text">2.4.3 listener.Accept()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conn.read-conn.write"><span class="toc-text">2.4.4 conn.Read() &#x2F; conn.Write()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net.dialtcp"><span class="toc-text">2.4.5 net.DialTCP()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">3. 总结</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":"https://site-info-api-hedon.vercel.app/api/v1?url={href}"},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img, .md-text img:not([class]), .md-text .image img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
